# 数据链路层

## 数据链路层的功能

### 数据链路层所处的地位

<img src="../images/image-202511031035.png" style="zoom:80%;" />

<u>数据链路层</u>使用<u>物理层</u>提供的“<span style="color:#4A70A9; font-weight:bold">比特传输</span>”服务。

<u>数据链路层</u>为<u>网络层</u>提供服务，将网络层的 <span style="color:#A72703; font-weight:bold">IP 数据报（分组）</span>封装成**帧**，传输给下一个相邻节点。

**物理链路**：传输介质（0 层）+ 物理层（1 层）实现了相邻节点间的“<span style="color:#F87B1B">物理链路</span>”。

**逻辑链路**：数据链路层需要基于“物理链路”，实现相邻节点间逻辑上无差错的“<span style="color:#F87B1B">数据链路（逻辑链路）</span>”。

---

<img src="../images/image-202511031037.webp" style="zoom:80%;" />

## 组帧

**知识总览**：

<img src="../images/image-202511051147.webp" style="zoom: 50%;" />

> [!tip]
>
> - **帧定界**：Frame Delimiting
> - **透明传输**：Transparent Transmission

### 字符计数法

字符计数法，Character Count Method。

<img src="../images/image-202511051220.webp" style="zoom: 50%;" />

- **原理**：在每个帧的开头，用一个<span style="color:#0046FF">定长计数字段</span>表示帧长。
- **最大缺点**：任何一个计数字段出错，都会导致后续<u>_所有帧_</u>无法定界。

### 字节填充法

字节填充法，Byte Stuffing。

<img src="../images/image-202511051314.webp" style="zoom: 50%;" />

> [!tip]
>
> - SOH: Start of Header
> - EOT: End of Transmission

为避免将数据中的字符误识别为控制字符，引入了转义字符机制：

<img src="../images/image-202511051318.webp" style="zoom:80%;" />

若数据部分中也包含转义字符，可在其前再添加一个转义字符以进行转义：

<img src="../images/image-202511051331.webp" style="zoom:80%;" />

如果帧的数据部分包含“特殊字符”，则<span style="color:#63A361; font-weight:bold">发送方</span>需要<span style="color:#63A361; font-weight:bold">在这些“特殊字符”前填充“转义字符 ESC”</span>（<span style="color:#63A361; font-weight:bold">接收方</span>要做<span style="color:#63A361; font-weight:bold">逆处理</span>）。

### 零比特填充法

零比特填充法，Bit Stuffing。

<img src="../images/image-202511071624.webp" style="zoom:80%;" />

- **发送方**需要对帧的数据部分进行处理，<span style="color:#DC0E0E">每当遇到连续 5 个 1，就填充一个 0</span>。
- **接收方**需要对帧的数据部分进行逆处理，<span style="color:#DC0E0E">每当遇到连续 5 个 1，就删掉后面的 0</span>。

> [!tip]
>
> 数据链路层的 HDLC、PPP 协议均使用零比特填充法进行组帧。

### 违规编码法

违规编码法，Violation Coding。

<img src="../images/image-202511071709.svg" style="zoom:80%;" />

---

**知识回顾**：

<img src="../images/image-202511071726.webp" style="zoom:80%;" />

## 差错控制

**知识总览**：

<img src="../images/image-202511092356.png" style="zoom: 50%;" />

### 奇偶校验码

**知识总览**：

<img src="../images/image-202511092359.png" style="zoom:50%;" />

奇偶校验码，Parity Check Code。

- **奇校验码**：整个校验码（有效信息位和校验位）中“1”的个数为奇数。
- **偶校验码**：这个校验码（有效信息位和校验位）中“1”的个数为偶数。

<img src="../images/image-202511100002.png" style="zoom:50%;" />

举例，给出两个编码 1001101 和 1010111 的奇校验码和偶校验码。

设最高位为校验位，余 7 位是信息位，则对应的奇偶校验码为：

- **奇校验**：<u>1</u>1001101；<u>0</u>1010111。
- **偶校验**：<u>0</u>1001101；<u>1</u>1010111。

偶校验的硬件实现：各信息位经异或（即模 2 加）运算后，所得结果即为偶校验位。

> [!tip]
>
> 模 2 加本质上就是不进位的二进制加法。

$\oplus $：异或（模 2 加）。

- $0 \oplus 0 = 0$

- $0 \oplus 1 = 1$

- $1 \oplus 0 = 1$

- $1 \oplus 1 = 0$

两比特相“异”时，结果为 1。

求偶校验位可以：

$$
1 \oplus 0 \oplus 0 \oplus 1 \oplus 1 \oplus 0 \oplus 1 = 1 \\
1 \oplus 0 \oplus 1 \oplus 0 \oplus 1 \oplus 1 \oplus 1 = 1
$$

进行偶校验（所有位进行异或，若结果为 1 说明出错）：

$$
0 \oplus 1 \oplus 0 \oplus 0 \oplus 1 \oplus 1 \oplus 0 \oplus 1 = 0\\
1 \oplus 1 \oplus 0 \oplus 1 \oplus 0 \oplus 1 \oplus 1 \oplus \underline{0} = 1\\
1 \oplus 1 \oplus 0 \oplus 1 \oplus 0 \oplus 1 \oplus \underline{0} \oplus \underline{0} = 1
$$

可以发现第二个最后一位发生了跳变，结果为 1，说明出错；但是最后一个有两个比特发生了跳变，结果却仍未 0。

因此，数据的接收方无法检测出<u>_偶数位错误_</u>。

> [!tip]
>
> 偶校验比奇校验更为常用，且在硬件上仅需异或门即可生成并验证偶校验位。

---

**知识回顾**：

<img src="../images/image-202511100029.png" style="zoom:80%;" />

### 循环冗余校验

**知识总览**：

<img src="../images/image-202511100857.png" style="zoom: 50%;" />

循环冗余校验（Cyclic Redundancy Check, <span style="color:#DC0E0E">CRC</span>）。

#### 基本思想

约定一个除数，接收方用检测数据除以该除数，检查余数是否发生了改变从而判断数据传输过程中是否出现了错误。

<img src="../images/image-202511100900.png" style="zoom:67%;" />

循环冗余检验码的思想：数据发送方、接收方约定一个“<span style="color:#0046FF">除数</span>”，数据出错导致余数改变——检测到错误。

<img src="../images/image-202511100907.png" style="zoom:50%;" />

<span style="color:#F87B1B">K 个信息位 + R 个检验位</span>作为“<span style="color:#F87B1B">被除数</span>”，添加检验位后需保证除法的余数为 0。

收到数据后，进行<span style="color:#F87B1B">除法</span>检查余数是否为 0。

若余数非 0 则说明出错，则进行重传或纠错。

#### 求解步骤

例题，设生成多项式为 $G(x) = x^3 + x^2 + 1$，信息码为 101001，求对应的 CRC 码。

1. 确定 K、R 以及生成多项式对应的二进制码。

   K = 信息码的长度 = 6，R = 生成多项式最高次幂 = 3。

   $$
   \begin{align*}
   G(x)
   &= x^3 + x^2 + 1 \\
   &= \underline{1} \cdot x^3 + \underline{1} \cdot x^2 + \underline{0} \cdot x^1 + \underline{1} \cdot x^0
   \end{align*}
   $$

   对应二进制码为 <span style="color:#FF3F7F">1101</span>。

2. 移位：

   信息码左移 R 位，低位补 0。

3. 相除：

   对移位后的信息码，用生成多项式进行<span style="color:#FF3F7F">模 2 除法</span>，产生余数。

   <img src="../images/image-202511100921.png" style="zoom:50%;" />

   对应的 CRC 码为 101001<u>001</u>。

4. 检错和纠错：

   发送：101001001，记为：$C_9C_8C_7C_6C_5C_4C_3C_2C_1$。

   接受：101001001，使用约定好的除数 1101 进行模 2 除，余数为 000，代表没有出错。

   接受（出错情况）：1010010<u>1</u>1，使用 1101 进行模 2 除，余数为 010，代表 $C_2$ 出错。（<u>_此处余数和校验码不可直接对应_</u>）

|                     接受                      | 余数 | 出错位 |
| :-------------------------------------------: | :--: | :----: |
| 101001 00<span style="color:#DD0303">0</span> | 001  |   1    |
| 101001 0<span style="color:#DD0303">1</span>1 | 010  |   2    |
| 101001 <span style="color:#DD0303">1</span>01 | 100  |   3    |
| 10100<span style="color:#DD0303">0</span> 001 | 101  |   4    |
| 1010<span style="color:#DD0303">1</span>1 001 | 111  |   5    |
| 101<span style="color:#DD0303">1</span>01 001 | 011  |   6    |
| 10<span style="color:#DD0303">0</span>001 001 | 110  |   7    |
| 1<span style="color:#DD0303">1</span>1001 001 | 001  |   8    |
| <span style="color:#DD0303">0</span>01001 001 | 010  |   9    |

举另外一个例子：

<img src="../images/image-202511101020.png" style="zoom: 50%;" />

对于 K 个信息位与 R 个校验位，若生成多项式选择得当且满足 $2^R \ge K + R + 1$，则 CRC 码可纠正 1 位错。（$K + R$ 代表单比特错误的所有情况，1 表示 1 中正确状态）

> [!tip]
>
> 实际应用中，信息位通常达数千位，检验位仅数个，因此 CRC 码一般仅用于检错。

理论上可以证明循环冗余检验码的检错能力有以下特点：

1. 可检测出所有奇数个错误
2. 可检测出所有双比特错误
3. 可检测出所以小于等于检验位长度的连续错误

---

**知识回顾**：

<img src="../images/image-202511101028.png" style="zoom:67%;" />

### 海明校验码

海明校验码，Hamming Code。

**知识总览**：

<img src="../images/image-202511101313.png" style="zoom: 50%;" />

#### 基本思想

由前文奇偶校验的原理可知，其 1 位检验位仅能判断数据是否出错，无法提供其他额外信息。

**海明码设计思路**：将信息位分组进行偶校验 → 多个校验位 → 多个检验位标注出错位置。

> [!tip]
>
> 多个校验位可承载多种状态信息，包括正误及错误位置。

<img src="../images/image-202511101330.png" style="zoom: 50%;" />

| n   | 1   | 2~4 | 5~11 | 12~26 | 27~57 | 58~120 |
| --- | --- | --- | ---- | ----- | ----- | ------ |
| k   | 2   | 3   | 4    | 5     | 6     | 7      |

#### 求解步骤

<img src="../images/image-202511101335.png" style="zoom: 50%;" />

1. 确认海明码的位数：$2^k \ge n + k + 1$。

   因此有 n = 4 → k = 3，设信息位 $D_4D_3D_2D_1(1010)$，共 4 位；检验位 $P_3P_2P_1$，共 3 位。对应的海明码为 $H_7H_6H_5H_4H_3H_2H_1$。

2. 确认校验位的分布：

   | $H_7$ | $H_6$ | $H_5$ | $H_4$ | $H_3$ | $H_2$ | $H_1$ |
   | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
   | $D_4$ | $D_3$ | $D_2$ | $P_3$ | $D_1$ | $P_2$ | $P_1$ |
   | 1     | 0     | 1     | 0     | 0     | 1     | 0     |

   将校验位 $P_i$ 放到海明位号为 $2^{i - 1}$ 的位置上，信息位按顺序放到其余位置。

3. 求检验位的值：

   $H_3$：3 → 011

   $H_5$：5 → 101

   $H_6$：6 → 110

   $H_7$：7 → 111

   从低到高，第一位为 1 的归为 $P_1$，第二位为 1 的归为 $P_2$，第三位为 1 的归为 $P_3$，以此类推。

   $$
   P_1 = H_3 \oplus H_5 \oplus H_7 = D_1 \oplus D_2 \oplus D_4 = 0 \oplus 1 \oplus 1 = 0 \\
   P_2 = H_3 \oplus H_6 \oplus H_7 = D_1 \oplus D_3 \oplus D_4 = 0 \oplus 0 \oplus 1 = 1\\
   P_3 = H_5 \oplus H_6 \oplus H_7 = D_2 \oplus D_3 \oplus D_4 = 1 \oplus 0 \oplus 1 = 0
   $$

   三个分组，分别求出其偶校验位（即模 2 加）。

4. 纠错：

   校验方程：

   $$
      S_1 = P_1 \oplus D_1 \oplus D_2 \oplus D_4 \\
      S_2 = P_2 \oplus D_1 \oplus D_3 \oplus D_4 \\
      S_3 = P_3 \oplus D_2 \oplus D_3 \oplus D_4
   $$

接收到 1010010（无错误）：

$$
   S_1 = P_1 \oplus D_1 \oplus D_2 \oplus D_4 = 0 \oplus 0 \oplus 1 \oplus 1 = 0\\
   S_2 = P_2 \oplus D_1 \oplus D_3 \oplus D_4 = 1 \oplus 0 \oplus 0 \oplus 1 = 0\\
   S_3 = P_3 \oplus D_2 \oplus D_3 \oplus D_4 = 0 \oplus 1 \oplus 0 \oplus 1 = 0
$$

接收到 10100<u>0</u>0（有错误）：

$$
   S_1 = P_1 \oplus D_1 \oplus D_2 \oplus D_4 = 0 \oplus 0 \oplus 1 \oplus 1 = 0\\
   S_2 = P_2 \oplus D_1 \oplus D_3 \oplus D_4 = \underline{0} \oplus 0 \oplus 0 \oplus 1 = \underline{1}\\
   S_3 = P_3 \oplus D_2 \oplus D_3 \oplus D_4 = 0 \oplus 1 \oplus 0 \oplus 1 = 0
$$

从 $S_1$ 至 $S_3$，由低到高，第 010 位出错（即第 2 位出错）。

<img src="../images/image-202511101434.png" style="zoom:50%;" />

设信息位 $D_1D_2D_3D_4(1010)$，共 4 位；校验位 $P_1P_2P_3$，共 3 位，对应的海明码为 $H_1H_2H_3H_4H_5H_6H_7$。（从小到大）

| $H_1$ | $H_2$ | $H_3$ | $H_4$ | $H_5$ | $H_6$ | $H_7$ |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| $P_1$ | $P_2$ | $D_1$ | $P_3$ | $D_2$ | $D_3$ | $D_4$ |
| 0     | 1     | 0     | 0     | 1     | 0     | 1     |

> [!tip]
>
> 可以结合权重来进行记忆。

#### 补充

海明码的检错、纠错能力：纠错能力——1 位；检错能力——2 位。

可见无法区分到底是 1 位错还是 2 位错。

因此添加“全校验位”，对整体进行偶校验：

| $H_8$  | $H_7$ | $H_6$ | $H_5$ | $H_4$ | $H_3$ | $H_2$ | $H_1$ |
| ------ | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| $P_全$ | $D_4$ | $D_3$ | $D_2$ | $P_3$ | $D_1$ | $P_2$ | $P_1$ |
| 1      | 1     | 0     | 1     | 0     | 0     | 1     | 0     |

$S_3S_2S_1 = 000$ 且全体偶检验成功 → 无错误。

$S_3 S_2 S_1 \neq 000$ 且全体偶校验失败 → 有 1 位错，纠正即可。

$S_3S_2S_1 \neq 000$ 且全体偶校验成功 → 有 2 位错，需重传。

---

**知识总览**：

<img src="../images/image-202511101457.png" style="zoom: 67%;" />

## 流量控制、可靠传输机制

### 滑动窗口机制

<img src="../images/image-202511110002.png" style="zoom: 67%;" />

<img src="../images/image-202511110005.png" style="zoom:80%;" />

窗口“向前滑动”：

<img src="../images/image-202511110009.png" style="zoom: 50%;" />

由接收方通过“<span style="color:#DC0E0E">确认机制</span>”控制发送方的窗口向前滑动，从而实现“<span style="color:#DC0E0E">流量控制</span>”。

### 停止-等待协议（S-W）

**知识总览**：

<img src="../images/image-202511111007.png" style="zoom:67%;" />

停止-等待协议，stop-and-wait。

因为下述条件：

$$
\left\{\begin{matrix}
W_T + W_R \le 2^n \\
W_T = 1 \\
W_R = 1
\end{matrix}\right.
$$

可以得出 n 最小为 1 bit，而后使用 1 bit 进行编号。

> [!tip]
>
> n 指的是给帧进行编号所需的比特数。

<img src="../images/image-202511111023.svg" style="zoom:80%;" />

#### 数据帧、确定帧、帧序号的概念

<img src="../images/image-202511111044.svg"  />

#### “正常”情况示例

发送方发送 0 号数据帧，接收方接收后将数据提交至网络层处理，随后返回 0 号确认帧并滑动接收窗口。此时接收方已准备就绪，可接收 1 号数据帧。

<img src="../images/image-202511111045.webp" style="zoom: 50%;" />

发送方收到 0 号确认帧后，确认接收方已正确接收对应数据，随即向后移动发送窗口。

<img src="../images/image-202511111050.webp" style="zoom: 50%;" />

以此类推，后续按相同流程依次传输后续帧。

<img src="../images/image-202511111054.webp" style="zoom:50%;" />

#### 异常情况示例：数据帧丢失

<img src="../images/image-202511111058.png" style="zoom:50%;" />

<img src="../images/image-202511111058.webp" style="zoom:50%;" />

若传输过程中出现帧丢失（如数据帧或确认帧丢失），发送方在超时计时器到期后，将触发对应帧的重传机制。

<img src="../images/image-202511111101.webp" style="zoom:50%;" />

#### 异常情况示例：确认帧丢失

<img src="../images/image-202511111103.webp" style="zoom:50%;" />

若 1 号确认帧丢失，但接收方已成功接收 1 号数据帧，接收窗口会正常向后滑动（准备接收 0 号数据帧）。

由于发送方未在超时计时器周期内收到 1 号数据帧的对应确定帧，将重传该帧并同步重置超时计时器。

<img src="../images/image-202511111106.webp" style="zoom:50%;" />

#### 探讨：为什么一定要给帧“编号”

若未对帧进行编号，以确认帧丢失的异常场景为例：

发送方因未收到确认帧，超时后会重传对应帧；而接收方<span style="color:#DC0E0E; font-weight:bold">无法判断</span>该重传帧是此前已接收过的**重复帧**，还是新的**待接收帧**。

由于接收窗口和发送窗口的距离不超过 1，因此<span style="color:#DC0E0E">用 1 bit 表示帧序号</span>足矣。

#### 异常情况示例：数据帧有“差错”

<img src="../images/image-202511111123.webp" style="zoom: 50%;" />

<img src="../images/image-202511111124.webp" style="zoom:50%;" />

<img src="../images/image-202511111125.webp" style="zoom:50%;" />

---

**知识回顾**：

<img src="../images/image-202511111126.webp" style="zoom:67%;" />

### 后退 N 帧协议（GBN）

**知识总览**：

<img src="../images/image-202511111257.webp" style="zoom:80%;" />

后退 N 帧协议，Go-Back-N。

<img src="../images/image-202511111300.webp" style="zoom:50%;" />

#### “正常”情况示例

<img src="../images/image-202511111302.webp" style="zoom: 50%;" />

发送窗口大小为 3，涵盖了 0、1、2 号帧，发送方可以通过信道连续传输这 3 个帧。

<img src="../images/image-202511111308.webp" style="zoom: 50%;" />

GBN 协议无需为每个帧单独返回 ACK，接收方会持续移动接收窗口接收数据，直至信道无连续传输的数据，之后仅需向发送方返回最后接收帧的 ACK 即可。

> [!tip]
>
> **后退 N 帧协议规定**：接收方可以“<span style="color:#EE6983; font-weight:bold">累计确认</span>”。即连续收到多个数据帧后，<span style="color:#DC0E0E">可以仅返回最后一个帧的 ACK</span>。

发送方收到接收方的 ACK 后，向后移动发送窗口。

#### 异常情况示例：数据帧丢失

<img src="../images/image-202511111325.webp" style="zoom: 50%;" />

<img src="../images/image-202511111331.png" style="zoom:50%;" />

<img src="../images/image-202511111413.webp" style="zoom:50%;" />

**为什么称为“后退 N 帧协议”？**

原本已经发送了 1 号帧，现在却“后退”回 0 号帧重新传送。这样即可实现“流量控制”。

<img src="../images/image-202511111416.webp" style="zoom:50%;" />

<img src="../images/image-202511111437.webp" style="zoom:50%;" />

#### 异常情况示例：确认帧丢失

<img src="../images/image-202511111441.webp" style="zoom:50%;" />

<img src="../images/image-202511111442.webp" style="zoom:50%;" />

<img src="../images/image-202511111444.webp" style="zoom:50%;" />

<img src="../images/image-202511111446.webp" style="zoom:50%;" />

#### 探讨：若不满足 $W_T + W_R \le 2^n$ 会有什么问题？

<img src="../images/image-202511111453.webp" style="zoom:50%;" />

发送方连续往信道上发送序号为 0、1、2、3 的帧。

<img src="../images/image-202511111500.webp" style="zoom:50%;" />

接收方成功接收序号 0、1、2、3 的帧，接收窗口同步滑动至下一帧，但所发送的确认帧发送丢失。

<img src="../images/image-202511111505.webp" style="zoom:50%;" />

可见，若 n 不满足 $W_T + W_R \le 2^n$，重传数据帧的序号可能落入接收窗口，导致接收方误接收。

---

**知识回顾**：

<img src="../images/image-202511111520.webp" style="zoom:67%;" />

### 选择重传协议（SR）

**知识总览**：

<img src="../images/image-202511111556.webp" style="zoom:50%;" />

#### 选择重传协议的窗口大小限制条件

<img src="../images/image-202511111601.webp" style="zoom:50%;" />

选择重传协议的<span style="color:#0046FF">窗口大小需满足如下两个条件</span>：

$$
\left\{\begin{matrix}
W_T + W_R \le 2^n \\
W_R \le W_T
\end{matrix}\right.
$$

若将接收窗口大小改为 4，也符合上述条件：

<img src="../images/image-202511111608.webp" style="zoom:50%;" />

> [!tip]
>
> 当接收窗口大小 $W_R$ 大于发送窗口大小 $W_T$ 时，部分帧序号资源将长期处于空闲状态，进而降低整体信道利用率。
>
> 在实际应用当中，通常取 $W_T = W_R$。

#### “正常”情况示例

<img src="../images/image-202511111622.webp" style="zoom:50%;" />

<img src="../images/image-202511111623.webp" style="zoom:50%;" />

**选择重传协议**规定：接收方可以连续接收多个帧，但<span style="color:#F87B1B">每个帧都需要返回 ACK</span>。

**后退 N 帧协议**规定：接收方可以“<span style="color:#CD2C58; font-weight:bold">累计确认</span>”。即连续收到多个帧时，<span style="color:#CD2C58">可以仅返回最后一个帧的 ACK</span>。

<img src="../images/image-202511111627.webp" style="zoom:50%;" />

#### 异常情况示例：数据帧丢失

<img src="../images/image-202511111629.webp" style="zoom:50%;" />

<img src="../images/image-202511111630.webp" style="zoom:50%;" />

<img src="../images/image-202511111631.webp" style="zoom:50%;" />

<img src="../images/image-202511111632.webp" style="zoom:50%;" />

<img src="../images/image-202511111843.webp" style="zoom:50%;" />

<img src="../images/image-202511111847.webp" style="zoom:50%;" />

<img src="../images/image-202511111849.webp" style="zoom:50%;" />

**选择重传协议如何解决数据帧丢失问题？**

<span style="color:#CD2C58; font-weight:bold">超时重传机制</span>：每个帧被发出时设置<span style="color:#CD2C58">计时器</span>，如果<span style="color:#CD2C58">超时未收到</span>对应的 ACK，就<span style="color:#CD2C58">重传</span>这个帧。

#### 异常情况示例：数据帧因差错而被丢弃

<img src="../images/image-202511111905.webp" style="zoom:50%;" />

<img src="../images/image-202511111906.webp" style="zoom:50%;" />

<img src="../images/image-202511111907.webp" style="zoom:50%;" />

<img src="../images/image-202511111913.png" style="zoom:50%;" />

<img src="../images/image-202511111913.webp" style="zoom:50%;" />

<img src="../images/image-202511111917.webp" style="zoom:50%;" />

<img src="../images/image-202511111918.webp" style="zoom:50%;" />

<img src="../images/image-202511111919.webp" style="zoom:50%;" />

<img src="../images/image-202511111925.webp" style="zoom:50%;" />

**选择重传协议如何解决数据帧因差错而被丢弃问题？**

<span style="color:#4E61D3; font-weight:bold">请求重传</span>机制：如果接收方收到一个有差错的帧，就<span style="color:#4E61D3">将此帧丢弃</span>，并返回对应的<span style="color:#4E61D3">否认帧 NAK_i</span>，主动请求发送方重传 i 号帧。

#### 异常情况示例：确认帧丢失

<img src="../images/image-202511111932.webp" style="zoom:50%;" />

<img src="../images/image-202511111934.webp" style="zoom:50%;" />

<img src="../images/image-202511111937.webp" style="zoom:50%;" />

<img src="../images/image-202511111938.webp" style="zoom:50%;" />

<img src="../images/image-202511111939.webp" style="zoom:50%;" />

<img src="../images/image-202511111940.webp" style="zoom:50%;" />

<img src="../images/image-202511111941.webp" style="zoom:50%;" />

<img src="../images/image-202511111945.webp" style="zoom:50%;" />

#### 探讨：若不满足 $W_T + W_R \le 2^n$ 会有什么问题？

<img src="../images/image-202511111951.png" style="zoom:50%;" />

<img src="../images/image-202511111952.webp" style="zoom:50%;" />

<img src="../images/image-202511111953.webp" style="zoom:50%;" />

<img src="../images/image-202511111954.webp" style="zoom:50%;" />

<img src="../images/image-202511112004.jpg" style="zoom:50%;" />

可见，此时 0 号帧位于接收窗口内，接收方会将重传的 0 号帧误认为是最新的 0 号帧。

> [!tip]
>
> 若不满足 $W_T + W_R \le 2^n$，会导致发送方和接收方无法正确判别“重复帧”。

### 三种协议的信道利用率分析

**知识总览**：

<img src="../images/image-202511112041.webp" style="zoom: 43%;" />

#### S-W 协议的信道利用率

假设信道的数据传输速率为 <span style="color:#8C00FF">1kbps</span>，数据帧长度为 <span style="color:#8C00FF">4kb</span>，确认帧长度为 <span style="color:#8C00FF">1kb</span>，信道单向传输时延为 <span style="color:#8C00FF">7s</span>。

<img src="../images/image-202511112045.webp" style="zoom: 67%;" />
$$
信道利用率 = \frac{4}{4 + 2 + 7 + 1} \approx 21 \%
$$
在 S-W 协议中，理想情况下，有：
$$
U = \frac{T_D}{T_D + RTT + T_A}
$$
理想情况指的就是没有帧丢失、比特错误等异常情况。

> [!tip]
>
> 此处的信道利用率实际指发送方的信道利用率，即发送方将数据帧传输至信道的时间占总时间的比例。

假设确认帧非常短，意味着确认帧的传播时延<u>_可以忽略不计_</u>。

<img src="../images/image-202511112057.webp" style="zoom:50%;" />

此时，有：

$$
信道利用率 = \frac{4}{4 + 2 + 7} \approx 22.2 \%
$$

上文的信道利用率公式中，由于确认帧非常短，可以认为 $T_A = 0$。

---

<img src="../images/image-202511112117.webp" style="zoom:50%;" />
$$
40 \% = \frac{\frac{数据帧长度}{3 \text{kbps}}}{\left(\frac{数据帧长度}{3 \text{kbps}}\right) + 2 \times 200 \text{ms} + 0}
$$
最后得出数据帧的长度为 800bit。

> [!tip]
>
> 上述公式中，需将 ms 换算成 s，才能与前面的 kbps 单位相匹配（实现单位相消）。

#### GBN、SR 协议的信道利用率

假设发送窗口的大小 <span style="color:#DD0303">N 为 4</span>，信道的数据传输速率为 <span style="color:#DD0303">1kbps</span>，数据帧长度为 <span style="color:#DD0303">4kb</span>，确认帧长度为 <span style="color:#DD0303">1kb</span>，信道单向传输时延为 <span style="color:#DD0303">7s</span>。

<img src="../images/image-202511112145.webp" style="zoom:50%;" />

关注灰色虚线框内的周期，有：

$$
信道利用率 = \frac{4 \times 4}{4 + 2 + 7 + 1} \approx 84 \%
$$

理想情况下，有：

$$
信道利用率 = U = \frac{N T_D}{T_D + RTT + T_A}
$$

若发送窗口的大小 <span style="color:#DD0303">N 为 5</span>，其他条件不变，则有：

<img src="../images/image-202511112212.webp" style="zoom:50%;" />

直接代入公式会得到信道利用率大于 1 的结果，而该结果不符合逻辑，因此不可生搬硬套此公式。

经分析可知，与前文示例不同，本案例中一组数据帧（即一个发送窗口的全部帧）**发送完毕的时刻，可能在首个发送帧对应的确认帧返回之后**。

可以看见发送信道上总是有数据通过，此时：

$$
信道利用率 = 1
$$

> [!tip]
>
> 信道利用率不可能超过 1。
>
> 因此对于之前的公式，若 $NT_D \ge T_D + RTT + T_A$，则最大信道利用率为 1。

---

<img src="../images/image-202511112231.webp" style="zoom: 67%;" />

一个数据帧的传播时延为 $\dfrac{1000 \text{B}}{100 \text{Mbps}} = 0.08 \text{ms}$。

<img src="../images/image-202511112237.webp" style="zoom:50%;" />

连续发送 1000 个数据帧耗时 **80ms**。

从发出第一个数据帧到收到第一个确认帧耗时 $2 \times 50 \text{ms} = 100 \text{ms}$。

最大平均数据传输速率为 $\dfrac{1000 \times 1000 \text{B}}{100 \text{ms} + 0.08 \text{ms}} \approx 80 \text{Mbps}$。

信道利用率为 $\dfrac{最大平均数据传输速率}{带宽} \approx 80 \%$。

---

<img src="../images/image-202511112248.webp" style="zoom:50%;" />

对于 GBN 协议、SR 协议，理想情况下，信道利用率为 $\dfrac{N T_D}{T_D + RTT + T_A} \ge 80 \%$。

传输一个数据帧所需时间为 $T_D = \dfrac{1000 \text{B}}{128 \text{kbps}} = 0.0625 \text{s}$。

2 倍的单向传播时延为 $RTT = 2 \times 250 \text{ms} = 0.5 \text{s}$。

而传输一个确认帧的所需时间 $T_A$ 可忽略不计。

最后可以得出 $N \ge 7.2$。

n 相同时，GBN 协议的 $W_T$ 更大，n 至少为 4，才能确保 $W_T \ge 7.2$。

最后得出 $n \ge 4$。

#### 术语补充：滑动窗口协议（Sliding Window Protocol）

<span style="color:#6F00FF; font-weight:bold">原理上</span>，为了便于理解，三者都可以视为采用“滑动窗口机制”。

<img src="../images/image-202511112255.webp" style="zoom:50%;" />

术语使用上，<span style="color:#FF9013; font-weight:bold">S-W 协议<u>不属于</u>“滑动窗口协议”</span>范畴。

<img src="../images/image-202511112257.webp" style="zoom:50%;" />

#### 术语补充：ARQ 协议、连续 ARQ 协议

<span style="color:#DD0303">ARQ 协议</span>——即 Automatic Repeat Request，通常翻译为“自动重传请求”协议，<span style="color:#DD0303">包含 S-W、GBN、SR 三种协议</span>。

<img src="../images/image-202511112304.webp" style="zoom:50%;" />

---

**知识总览**：

<img src="../images/image-202511112320.webp" style="zoom: 67%;" />
