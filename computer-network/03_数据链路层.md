# 数据链路层

## 数据链路层的功能

### 数据链路层所处的地位

<img src="../images/image-202511031035.png" style="zoom:80%;" />

<u>数据链路层</u>使用<u>物理层</u>提供的“<span style="color:#4A70A9; font-weight:bold">比特传输</span>”服务。

<u>数据链路层</u>为<u>网络层</u>提供服务，将网络层的 <span style="color:#A72703; font-weight:bold">IP 数据报（分组）</span>封装成**帧**，传输给下一个相邻节点。

**物理链路**：传输介质（0 层）+ 物理层（1 层）实现了相邻节点间的“<span style="color:#F87B1B">物理链路</span>”。

**逻辑链路**：数据链路层需要基于“物理链路”，实现相邻节点间逻辑上无差错的“<span style="color:#F87B1B">数据链路（逻辑链路）</span>”。

---

<img src="../images/image-202511031037.webp" style="zoom:80%;" />

## 组帧

**知识总览**：

<img src="../images/image-202511051147.webp" style="zoom: 50%;" />

> [!tip]
>
> - **帧定界**：Frame Delimiting
> - **透明传输**：Transparent Transmission

### 字符计数法

字符计数法，Character Count Method。

<img src="../images/image-202511051220.webp" style="zoom: 50%;" />

- **原理**：在每个帧的开头，用一个<span style="color:#0046FF">定长计数字段</span>表示帧长。
- **最大缺点**：任何一个计数字段出错，都会导致后续<u>*所有帧*</u>无法定界。

### 字节填充法

字节填充法，Byte Stuffing。

<img src="../images/image-202511051314.webp" style="zoom: 50%;" />

> [!tip]
>
> - SOH: Start of Header
> - EOT: End of Transmission

为避免将数据中的字符误识别为控制字符，引入了转义字符机制：

<img src="../images/image-202511051318.webp" style="zoom:80%;" />

若数据部分中也包含转义字符，可在其前再添加一个转义字符以进行转义：

<img src="../images/image-202511051331.webp" style="zoom:80%;" />

如果帧的数据部分包含“特殊字符”，则<span style="color:#63A361; font-weight:bold">发送方</span>需要<span style="color:#63A361; font-weight:bold">在这些“特殊字符”前填充“转义字符 ESC”</span>（<span style="color:#63A361; font-weight:bold">接收方</span>要做<span style="color:#63A361; font-weight:bold">逆处理</span>）。

### 零比特填充法

零比特填充法，Bit Stuffing。

<img src="../images/image-202511071624.webp" style="zoom:80%;" />

- **发送方**需要对帧的数据部分进行处理，<span style="color:#DC0E0E">每当遇到连续 5 个 1，就填充一个 0</span>。
- **接收方**需要对帧的数据部分进行逆处理，<span style="color:#DC0E0E">每当遇到连续 5 个 1，就删掉后面的 0</span>。

> [!tip]
>
> 数据链路层的 HDLC、PPP 协议均使用零比特填充法进行组帧。

### 违规编码法

违规编码法，Violation Coding。

<img src="../images/image-202511071709.svg" style="zoom:80%;" />

---

**知识回顾**：

<img src="../images/image-202511071726.webp" style="zoom:80%;" />

## 差错控制

**知识总览**：

<img src="../images/image-202511092356.png" style="zoom: 50%;" />

### 奇偶校验码

**知识总览**：

<img src="../images/image-202511092359.png" style="zoom:50%;" />

奇偶校验码，Parity Check Code。

- **奇校验码**：整个校验码（有效信息位和校验位）中“1”的个数为奇数。
- **偶校验码**：这个校验码（有效信息位和校验位）中“1”的个数为偶数。

<img src="../images/image-202511100002.png" style="zoom:50%;" />

举例，给出两个编码 1001101 和 1010111 的奇校验码和偶校验码。

设最高位为校验位，余 7 位是信息位，则对应的奇偶校验码为：

- **奇校验**：<u>1</u>1001101；<u>0</u>1010111。
- **偶校验**：<u>0</u>1001101；<u>1</u>1010111。

偶校验的硬件实现：各信息位经异或（即模 2 加）运算后，所得结果即为偶校验位。

> [!tip]
>
> 模 2 加本质上就是不进位的二进制加法。

$\oplus $：异或（模 2 加）。

- $0 \oplus 0 = 0$

- $0 \oplus 1 = 1$

- $1 \oplus 0 = 1$

- $1 \oplus 1 = 0$

两比特相“异”时，结果为 1。

求偶校验位可以：
$$
1 \oplus 0 \oplus 0 \oplus 1 \oplus 1 \oplus 0 \oplus 1 = 1 \\
1 \oplus 0 \oplus 1 \oplus 0 \oplus 1 \oplus 1 \oplus 1 = 1
$$
进行偶校验（所有位进行异或，若结果为 1 说明出错）：
$$
0 \oplus 1 \oplus 0 \oplus 0 \oplus 1 \oplus 1 \oplus 0 \oplus 1 = 0\\
1 \oplus 1 \oplus 0 \oplus 1 \oplus 0 \oplus 1 \oplus 1 \oplus \underline{0} = 1\\
1 \oplus 1 \oplus 0 \oplus 1 \oplus 0 \oplus 1 \oplus \underline{0} \oplus \underline{0} = 1
$$
可以发现第二个最后一位发生了跳变，结果为 1，说明出错；但是最后一个有两个比特发生了跳变，结果却仍未 0。

因此，数据的接收方无法检测出<u>*偶数位错误*</u>。

> [!tip]
>
> 偶校验比奇校验更为常用，且在硬件上仅需异或门即可生成并验证偶校验位。

---

**知识回顾**：

<img src="../images/image-202511100029.png" style="zoom:80%;" />

### 循环冗余校验

**知识总览**：

<img src="../images/image-202511100857.png" style="zoom: 50%;" />

循环冗余校验（Cyclic Redundancy Check, <span style="color:#DC0E0E">CRC</span>）。

#### 基本思想

约定一个除数，接收方用检测数据除以该除数，检查余数是否发生了改变从而判断数据传输过程中是否出现了错误。

<img src="../images/image-202511100900.png" style="zoom:67%;" />

循环冗余检验码的思想：数据发送方、接收方约定一个“<span style="color:#0046FF">除数</span>”，数据出错导致余数改变——检测到错误。

<img src="../images/image-202511100907.png" style="zoom:50%;" />

<span style="color:#F87B1B">K 个信息位 + R 个检验位</span>作为“<span style="color:#F87B1B">被除数</span>”，添加检验位后需保证除法的余数为 0。

收到数据后，进行<span style="color:#F87B1B">除法</span>检查余数是否为 0。

若余数非 0 则说明出错，则进行重传或纠错。

#### 求解步骤

例题，设生成多项式为 $G(x) = x^3 + x^2 + 1$，信息码为 101001，求对应的 CRC 码。

1. 确定 K、R 以及生成多项式对应的二进制码。

   K = 信息码的长度 = 6，R = 生成多项式最高次幂 = 3。
   $$
   \begin{align*}
   G(x)
   &= x^3 + x^2 + 1 \\
   &= \underline{1} \cdot x^3 + \underline{1} \cdot x^2 + \underline{0} \cdot x^1 + \underline{1} \cdot x^0
   \end{align*}
   $$
   对应二进制码为 <span style="color:#FF3F7F">1101</span>。

2. 移位：

   信息码左移 R 位，低位补 0。

3. 相除：

   对移位后的信息码，用生成多项式进行<span style="color:#FF3F7F">模 2 除法</span>，产生余数。

   <img src="../images/image-202511100921.png" style="zoom:50%;" />

   对应的 CRC 码为 101001<u>001</u>。

4. 检错和纠错：

   发送：101001001，记为：$C_9C_8C_7C_6C_5C_4C_3C_2C_1$。

   接受：101001001，使用约定好的除数 1101 进行模 2 除，余数为 000，代表没有出错。

   接受（出错情况）：1010010<u>1</u>1，使用 1101 进行模 2 除，余数为 010，代表 $C_2$ 出错。（<u>*此处余数和校验码不可直接对应*</u>）

|                     接受                      | 余数 | 出错位 |
| :-------------------------------------------: | :--: | :----: |
| 101001 00<span style="color:#DD0303">0</span> | 001  |   1    |
| 101001 0<span style="color:#DD0303">1</span>1 | 010  |   2    |
| 101001 <span style="color:#DD0303">1</span>01 | 100  |   3    |
| 10100<span style="color:#DD0303">0</span> 001 | 101  |   4    |
| 1010<span style="color:#DD0303">1</span>1 001 | 111  |   5    |
| 101<span style="color:#DD0303">1</span>01 001 | 011  |   6    |
| 10<span style="color:#DD0303">0</span>001 001 | 110  |   7    |
| 1<span style="color:#DD0303">1</span>1001 001 | 001  |   8    |
| <span style="color:#DD0303">0</span>01001 001 | 010  |   9    |

举另外一个例子：

<img src="../images/image-202511101020.png" style="zoom: 50%;" />

对于 K 个信息位与 R 个校验位，若生成多项式选择得当且满足 $2^R \ge K + R + 1$，则 CRC 码可纠正 1 位错。（$K + R$ 代表单比特错误的所有情况，1 表示 1 中正确状态）

> [!tip]
>
> 实际应用中，信息位通常达数千位，检验位仅数个，因此 CRC 码一般仅用于检错。

理论上可以证明循环冗余检验码的检错能力有以下特点：

1. 可检测出所有奇数个错误
2. 可检测出所有双比特错误
3. 可检测出所以小于等于检验位长度的连续错误

---

**知识回顾**：

<img src="../images/image-202511101028.png" style="zoom:67%;" />

### 海明校验码

海明校验码，Hamming Code。

**知识总览**：

<img src="../images/image-202511101313.png" style="zoom: 50%;" />

#### 基本思想

由前文奇偶校验的原理可知，其 1 位检验位仅能判断数据是否出错，无法提供其他额外信息。

**海明码设计思路**：将信息位分组进行偶校验 → 多个校验位 → 多个检验位标注出错位置。

> [!tip]
>
> 多个校验位可承载多种状态信息，包括正误及错误位置。

<img src="../images/image-202511101330.png" style="zoom: 50%;" />

| n    | 1    | 2~4  | 5~11 | 12~26 | 27~57 | 58~120 |
| ---- | ---- | ---- | ---- | ----- | ----- | ------ |
| k    | 2    | 3    | 4    | 5     | 6     | 7      |

#### 求解步骤

<img src="../images/image-202511101335.png" style="zoom: 50%;" />

1. 确认海明码的位数：$2^k \ge n + k + 1$。

   因此有 n = 4 → k = 3，设信息位 $D_4D_3D_2D_1(1010)$，共 4 位；检验位 $P_3P_2P_1$，共 3 位。对应的海明码为 $H_7H_6H_5H_4H_3H_2H_1$。

2. 确认校验位的分布：

   | $H_7$ | $H_6$ | $H_5$ | $H_4$ | $H_3$ | $H_2$ | $H_1$ |
   | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
   | $D_4$ | $D_3$ | $D_2$ | $P_3$ | $D_1$ | $P_2$ | $P_1$ |
   | 1     | 0     | 1     | 0     | 0     | 1     | 0     |

   将校验位 $P_i$ 放到海明位号为 $2^{i - 1}$ 的位置上，信息位按顺序放到其余位置。

3. 求检验位的值：

   $H_3$：3 → 011

   $H_5$：5 → 101

   $H_6$：6 → 110

   $H_7$：7 → 111

   从低到高，第一位为 1 的归为 $P_1$，第二位为 1 的归为 $P_2$，第三位为 1 的归为 $P_3$，以此类推。
   $$
   P_1 = H_3 \oplus H_5 \oplus H_7 = D_1 \oplus D_2 \oplus D_4 = 0 \oplus 1 \oplus 1 = 0 \\
   P_2 = H_3 \oplus H_6 \oplus H_7 = D_1 \oplus D_3 \oplus D_4 = 0 \oplus 0 \oplus 1 = 1\\
   P_3 = H_5 \oplus H_6 \oplus H_7 = D_2 \oplus D_3 \oplus D_4 = 1 \oplus 0 \oplus 1 = 0
   $$
   三个分组，分别求出其偶校验位（即模 2 加）。  

4. 纠错：

   校验方程：
   $$
   S_1 = P_1 \oplus D_1 \oplus D_2 \oplus D_4 \\
   S_2 = P_2 \oplus D_1 \oplus D_3 \oplus D_4 \\
   S_3 = P_3 \oplus D_2 \oplus D_3 \oplus D_4
   $$
   接收到 1010010（无错误）：
   $$
   S_1 = P_1 \oplus D_1 \oplus D_2 \oplus D_4 = 0 \oplus 0 \oplus 1 \oplus 1 = 0\\
   S_2 = P_2 \oplus D_1 \oplus D_3 \oplus D_4 = 1 \oplus 0 \oplus 0 \oplus 1 = 0\\
   S_3 = P_3 \oplus D_2 \oplus D_3 \oplus D_4 = 0 \oplus 1 \oplus 0 \oplus 1 = 0
   $$
   接收到 10100<u>0</u>0（有错误）：
   $$
   S_1 = P_1 \oplus D_1 \oplus D_2 \oplus D_4 = 0 \oplus 0 \oplus 1 \oplus 1 = 0\\
   S_2 = P_2 \oplus D_1 \oplus D_3 \oplus D_4 = \underline{0} \oplus 0 \oplus 0 \oplus 1 = \underline{1}\\
   S_3 = P_3 \oplus D_2 \oplus D_3 \oplus D_4 = 0 \oplus 1 \oplus 0 \oplus 1 = 0
   $$
   从 $S_1$ 至 $S_3$，由低到高，第 010 位出错（即第 2 位出错）。

   <img src="../images/image-202511101434.png" style="zoom:50%;" />

设信息位 $D_1D_2D_3D_4(1010)$，共 4 位；校验位 $P_1P_2P_3$，共 3 位，对应的海明码为 $H_1H_2H_3H_4H_5H_6H_7$。（从小到大）

| $H_1$ | $H_2$ | $H_3$ | $H_4$ | $H_5$ | $H_6$ | $H_7$ |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| $P_1$ | $P_2$ | $D_1$ | $P_3$ | $D_2$ | $D_3$ | $D_4$ |
| 0     | 1     | 0     | 0     | 1     | 0     | 1     |

> [!tip]
>
> 可以结合权重来进行记忆。

#### 补充

海明码的检错、纠错能力：纠错能力——1 位；检错能力——2 位。

可见无法区分到底是 1 位错还是 2 位错。

因此添加“全校验位”，对整体进行偶校验：

| $H_8$  | $H_7$ | $H_6$ | $H_5$ | $H_4$ | $H_3$ | $H_2$ | $H_1$ |
| ------ | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| $P_全$ | $D_4$ | $D_3$ | $D_2$ | $P_3$ | $D_1$ | $P_2$ | $P_1$ |
| 1      | 1     | 0     | 1     | 0     | 0     | 1     | 0     |

$S_3S_2S_1 = 000$ 且全体偶检验成功 → 无错误。

$S_3 S_2 S_1 \neq 000$ 且全体偶校验失败 → 有 1 位错，纠正即可。

$S_3S_2S_1 \neq 000$ 且全体偶校验成功 → 有 2 位错，需重传。

---

**知识总览**：

<img src="../images/image-202511101457.png" style="zoom: 67%;" />

## 流量控制、可靠传输机制

### 滑动窗口机制

<img src="../images/image-202511110002.png" style="zoom: 67%;" />

<img src="../images/image-202511110005.png" style="zoom:80%;" />

窗口“向前滑动”：

<img src="../images/image-202511110009.png" style="zoom: 50%;" />

由接收方通过“<span style="color:#DC0E0E">确认机制</span>”控制发送方的窗口向前滑动，从而实现“<span style="color:#DC0E0E">流量控制</span>”。

### 停止-等待协议（S-W）

**知识总览**：

<img src="../images/image-202511111007.png" style="zoom:67%;" />

停止-等待协议，stop-and-wait。

因为下述条件：
$$
\left\{
\begin{matrix}
W_T + W_R \le 2^n\\
W_T = 1 \\
W_R = 1
\end{matrix}
\right.
$$
可以得出 n 最小为 1 bit，而后使用 1 bit 进行编号。

> [!tip]
>
> n 指的是给帧进行编号所需的比特数。

<img src="../images/image-202511111023.svg" style="zoom:80%;" />

#### 数据帧、确定帧、帧序号的概念

<img src="../images/image-202511111044.svg"  />

#### “正常”情况示例

发送方发送 0 号数据帧，接收方接收后将数据提交至网络层处理，随后返回 0 号确认帧并滑动接收窗口。此时接收方已准备就绪，可接收 1 号数据帧。

<img src="../images/image-202511111045.webp" style="zoom: 50%;" />

发送方收到 0 号确认帧后，确认接收方已正确接收对应数据，随即向后移动发送窗口。

<img src="../images/image-202511111050.webp" style="zoom: 50%;" />

以此类推，后续按相同流程依次传输后续帧。

<img src="../images/image-202511111054.webp" style="zoom:50%;" />

#### 异常情况示例：数据帧丢失

<img src="../images/image-202511111058.png" style="zoom:50%;" />

<img src="../images/image-202511111058.webp" style="zoom:50%;" />

若传输过程中出现帧丢失（如数据帧或确认帧丢失），发送方在超时计时器到期后，将触发对应帧的重传机制。

<img src="../images/image-202511111101.webp" style="zoom:50%;" />

#### 异常情况示例：确认帧丢失

<img src="../images/image-202511111103.webp" style="zoom:50%;" />

若 1 号确认帧丢失，但接收方已成功接收 1 号数据帧，接收窗口会正常向后滑动（准备接收 0 号数据帧）。

由于发送方未在超时计时器周期内收到 1 号数据帧的对应确定帧，将重传该帧并同步重置超时计时器。

<img src="../images/image-202511111106.webp" style="zoom:50%;" />

#### 探讨：为什么一定要给帧“编号”

若未对帧进行编号，以确认帧丢失的异常场景为例：

发送方因未收到确认帧，超时后会重传对应帧；而接收方<span style="color:#DC0E0E; font-weight:bold">无法判断</span>该重传帧是此前已接收过的**重复帧**，还是新的**待接收帧**。

由于接收窗口和发送窗口的距离不超过 1，因此<span style="color:#DC0E0E">用 1 bit 表示帧序号</span>足矣。

#### 异常情况示例：数据帧有“差错”

<img src="../images/image-202511111123.webp" style="zoom: 50%;" />

<img src="../images/image-202511111124.webp" style="zoom:50%;" />

<img src="../images/image-202511111125.webp" style="zoom:50%;" />

---

**知识回顾**：

<img src="../images/image-202511111126.webp" style="zoom:67%;" />

### 后退 N 帧协议（GBN）

**知识总览**：

<img src="../images/image-202511111257.webp" style="zoom:80%;" />

后退 N 帧协议，Go-Back-N。

<img src="../images/image-202511111300.webp" style="zoom:50%;" />

#### “正常”情况示例

<img src="../images/image-202511111302.webp" style="zoom: 50%;" />

发送窗口大小为 3，涵盖了 0、1、2 号帧，发送方可以通过信道连续传输这 3 个帧。

<img src="../images/image-202511111308.webp" style="zoom: 50%;" />

GBN 协议无需为每个帧单独返回 ACK，接收方会持续移动接收窗口接收数据，直至信道无连续传输的数据，之后仅需向发送方返回最后接收帧的 ACK 即可。

> [!tip]
>
> **后退 N 帧协议规定**：接收方可以“<span style="color:#EE6983; font-weight:bold">累计确认</span>”。即连续收到多个数据帧后，<span style="color:#DC0E0E">可以仅返回最后一个帧的 ACK</span>。

发送方收到接收方的 ACK 后，向后移动发送窗口。

#### 异常情况示例：数据帧丢失

<img src="../images/image-202511111325.webp" style="zoom: 50%;" />

<img src="../images/image-202511111331.png" style="zoom:50%;" />

<img src="../images/image-202511111413.webp" style="zoom:50%;" />

**为什么称为“后退 N 帧协议”？**

原本已经发送了 1 号帧，现在却“后退”回 0 号帧重新传送。这样即可实现“流量控制”。

<img src="../images/image-202511111416.webp" style="zoom:50%;" />

<img src="../images/image-202511111437.webp" style="zoom:50%;" />

#### 异常情况示例：确认帧丢失

<img src="../images/image-202511111441.webp" style="zoom:50%;" />

<img src="../images/image-202511111442.webp" style="zoom:50%;" />

<img src="../images/image-202511111444.webp" style="zoom:50%;" />

<img src="../images/image-202511111446.webp" style="zoom:50%;" />

#### 探讨：若不满足 $W_T + W_R \le 2^n$ 会有什么问题？

<img src="../images/image-202511111453.webp" style="zoom:50%;" />
