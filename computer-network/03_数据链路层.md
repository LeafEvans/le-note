# 数据链路层

## 数据链路层的功能

### 数据链路层所处的地位

<img src="../images/image-202511031035.png" style="zoom:80%;" />

<u>数据链路层</u>使用<u>物理层</u>提供的“<span style="color:#4A70A9; font-weight:bold">比特传输</span>”服务。

<u>数据链路层</u>为<u>网络层</u>提供服务，将网络层的 <span style="color:#A72703; font-weight:bold">IP 数据报（分组）</span>封装成**帧**，传输给下一个相邻节点。

**物理链路**：传输介质（0 层）+ 物理层（1 层）实现了相邻节点间的“<span style="color:#F87B1B">物理链路</span>”。

**逻辑链路**：数据链路层需要基于“物理链路”，实现相邻节点间逻辑上无差错的“<span style="color:#F87B1B">数据链路（逻辑链路）</span>”。

---

<img src="../images/image-202511031037.webp" style="zoom:80%;" />

## 组帧

**知识总览**：

<img src="../images/image-202511051147.webp" style="zoom: 50%;" />

> [!tip]
>
> - **帧定界**：Frame Delimiting
> - **透明传输**：Transparent Transmission

### 字符计数法

字符计数法，Character Count Method。

<img src="../images/image-202511051220.webp" style="zoom: 50%;" />

- **原理**：在每个帧的开头，用一个<span style="color:#0046FF">定长计数字段</span>表示帧长。
- **最大缺点**：任何一个计数字段出错，都会导致后续<u>*所有帧*</u>无法定界。

### 字节填充法

字节填充法，Byte Stuffing。

<img src="../images/image-202511051314.webp" style="zoom: 50%;" />

> [!tip]
>
> - SOH: Start of Header
> - EOT: End of Transmission

为避免将数据中的字符误识别为控制字符，引入了转义字符机制：

<img src="../images/image-202511051318.webp" style="zoom:80%;" />

若数据部分中也包含转义字符，可在其前再添加一个转义字符以进行转义：

<img src="../images/image-202511051331.webp" style="zoom:80%;" />

如果帧的数据部分包含“特殊字符”，则<span style="color:#63A361; font-weight:bold">发送方</span>需要<span style="color:#63A361; font-weight:bold">在这些“特殊字符”前填充“转义字符 ESC”</span>（<span style="color:#63A361; font-weight:bold">接收方</span>要做<span style="color:#63A361; font-weight:bold">逆处理</span>）。

### 零比特填充法

零比特填充法，Bit Stuffing。

<img src="../images/image-202511071624.webp" style="zoom:80%;" />

- **发送方**需要对帧的数据部分进行处理，<span style="color:#DC0E0E">每当遇到连续 5 个 1，就填充一个 0</span>。
- **接收方**需要对帧的数据部分进行逆处理，<span style="color:#DC0E0E">每当遇到连续 5 个 1，就删掉后面的 0</span>。

> [!tip]
>
> 数据链路层的 HDLC、PPP 协议均使用零比特填充法进行组帧。

### 违规编码法

违规编码法，Violation Coding。

<img src="../images/image-202511071709.svg" style="zoom:80%;" />

---

**知识回顾**：

<img src="../images/image-202511071726.webp" style="zoom:80%;" />

## 差错控制

**知识总览**：

<img src="../images/image-202511092356.png" style="zoom: 50%;" />

### 奇偶校验码

**知识总览**：

<img src="../images/image-202511092359.png" style="zoom:50%;" />

奇偶校验码，Parity Check Code。

- **奇校验码**：整个校验码（有效信息位和校验位）中“1”的个数为奇数。
- **偶校验码**：这个校验码（有效信息位和校验位）中“1”的个数为偶数。

<img src="../images/image-202511100002.png" style="zoom:50%;" />

举例，给出两个编码 1001101 和 1010111 的奇校验码和偶校验码。

设最高位为校验位，余 7 位是信息位，则对应的奇偶校验码为：

- **奇校验**：<u>1</u>1001101；<u>0</u>1010111。
- **偶校验**：<u>0</u>1001101；<u>1</u>1010111。

偶校验的硬件实现：各信息位经异或（即模 2 加）运算后，所得结果即为偶校验位。

> [!tip]
>
> 模 2 加本质上就是不进位的二进制加法。

$\oplus $：异或（模 2 加）。

- $0 \oplus 0 = 0$

- $0 \oplus 1 = 1$

- $1 \oplus 0 = 1$

- $1 \oplus 1 = 0$

两比特相“异”时，结果为 1。

求偶校验位可以：
$$
1 \oplus 0 \oplus 0 \oplus 1 \oplus 1 \oplus 0 \oplus 1 = 1 \\
1 \oplus 0 \oplus 1 \oplus 0 \oplus 1 \oplus 1 \oplus 1 = 1
$$
进行偶校验（所有位进行异或，若结果为 1 说明出错）：
$$
0 \oplus 1 \oplus 0 \oplus 0 \oplus 1 \oplus 1 \oplus 0 \oplus 1 = 0\\
1 \oplus 1 \oplus 0 \oplus 1 \oplus 0 \oplus 1 \oplus 1 \oplus \underline{0} = 1\\
1 \oplus 1 \oplus 0 \oplus 1 \oplus 0 \oplus 1 \oplus \underline{0} \oplus \underline{0} = 1
$$
可以发现第二个最后一位发生了跳变，结果为 1，说明出错；但是最后一个有两个比特发生了跳变，结果却仍未 0。

因此，数据的接收方无法检测出<u>*偶数位错误*</u>。

> [!tip]
>
> 偶校验比奇校验更为常用，且在硬件上仅需异或门即可生成并验证偶校验位。

---

**知识回顾**：

<img src="../images/image-202511100029.png" style="zoom:80%;" />

### 循环冗余校验

**知识总览**：

<img src="../images/image-202511100857.png" style="zoom: 50%;" />

循环冗余校验（Cyclic Redundancy Check, <span style="color:#DC0E0E">CRC</span>）。

#### 基本思想

约定一个除数，接收方用检测数据除以该除数，检查余数是否发生了改变从而判断数据传输过程中是否出现了错误。

<img src="../images/image-202511100900.png" style="zoom:67%;" />

循环冗余检验码的思想：数据发送方、接收方约定一个“<span style="color:#0046FF">除数</span>”，数据出错导致余数改变——检测到错误。

<img src="../images/image-202511100907.png" style="zoom:50%;" />

<span style="color:#F87B1B">K 个信息位 + R 个检验位</span>作为“<span style="color:#F87B1B">被除数</span>”，添加检验位后需保证除法的余数为 0。

收到数据后，进行<span style="color:#F87B1B">除法</span>检查余数是否为 0。

若余数非 0 则说明出错，则进行重传或纠错。

---

例题，设生成多项式为 $G(x) = x^3 + x^2 + 1$，信息码为 101001，求对应的 CRC 码。

1. 确定 K、R 以及生成多项式对应的二进制码。

   K = 信息码的长度 = 6，R = 生成多项式最高次幂 = 3。
   $$
   \begin{align*}
   G(x)
   &= x^3 + x^2 + 1 \\
   &= \underline{1} \cdot x^3 + \underline{1} \cdot x^2 + \underline{0} \cdot x^1 + \underline{1} \cdot x^0
   \end{align*}
   $$
   对应二进制码为 <span style="color:#FF3F7F">1101</span>。

2. 移位：

   信息码左移 R 位，低位补 0。

3. 相除：

   对移位后的信息码，用生成多项式进行<span style="color:#FF3F7F">模 2 除法</span>，产生余数。

   <img src="../images/image-202511100921.png" style="zoom:50%;" />

   对应的 CRC 码为 101001<u>001</u>。

4. 检错和纠错：

   发送：101001001，记为：$C_9C_8C_7C_6C_5C_4C_3C_2C_1$。

   接受：101001001，使用约定好的除数 1101 进行模 2 除，余数为 000，代表没有出错。

   接受（出错情况）：1010010<u>1</u>1，使用 1101 进行模 2 除，余数为 010，代表 $C_2$ 出错。（<u>*此处余数和校验码不可直接对应*</u>）

|                     接受                      | 余数 | 出错位 |
| :-------------------------------------------: | :--: | :----: |
| 101001 00<span style="color:#DD0303">0</span> | 001  |   1    |
| 101001 0<span style="color:#DD0303">1</span>1 | 010  |   2    |
| 101001 <span style="color:#DD0303">1</span>01 | 100  |   3    |
| 10100<span style="color:#DD0303">0</span> 001 | 101  |   4    |
| 1010<span style="color:#DD0303">1</span>1 001 | 111  |   5    |
| 101<span style="color:#DD0303">1</span>01 001 | 011  |   6    |
| 10<span style="color:#DD0303">0</span>001 001 | 110  |   7    |
| 1<span style="color:#DD0303">1</span>1001 001 | 001  |   8    |
| <span style="color:#DD0303">0</span>01001 001 | 010  |   9    |

举另外一个例子：

<img src="../images/image-202511101020.png" style="zoom: 50%;" />

对于 K 个信息位与 R 个校验位，若生成多项式选择得当且满足 $2^R \ge K + R + 1$，则 CRC 码可纠正 1 位错。（$K + R$ 代表单比特错误的所有情况，1 表示 1 中正确状态）

> [!tip]
>
> 实际应用中，信息位通常达数千位，检验位仅数个，因此 CRC 码一般仅用于检错。

理论上可以证明循环冗余检验码的检错能力有以下特点：

1. 可检测出所有奇数个错误
2. 可检测出所有双比特错误
3. 可检测出所以小于等于检验位长度的连续错误

---

**知识回顾**：

<img src="../images/image-202511101028.png" style="zoom:67%;" />

### 海明校验码

**知识总览**：

<img src="../images/image-202511101313.png" style="zoom: 50%;" />

#### 基本思想

由前文奇偶校验的原理可知，其 1 位检验位仅能判断数据是否出错，无法提供其他额外信息。

**海明码设计思路**：将信息位分组进行偶校验 → 多个校验位 → 多个检验位标注出错位置。

> [!tip]
>
> 多个校验位可承载多种状态信息，包括正误及错误位置。
