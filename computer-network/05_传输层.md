# 传输层

## 传输层提供的服务

**知识总览**：

<img src="../images/image-202601071855.webp" style="zoom:50%;" />

### 传输层在协议栈中的位置

<img src="../images/image-202601071858.webp" style="zoom:50%;" />

### 传输层“端口号”的概念

<img src="../images/image-202601071904.webp" style="zoom:50%;" />

<span style="color:#FF9A00; font-weight:bold">IP 地址 + 端口号 → 指向网络中一台主机上的一个特定的进程</span>

<span style="color:#5D688A">网络层</span>实现了“<u>主机到主机</u>”的通信。网络层在 IP 数据报的首部，指明<span style="color:#5D688A">源 IP 地址、目的 IP 地址</span>。

<span style="color:#C71E64">传输层</span>实现了“<u>端到端</u>”（<u>进程到进程</u>）的通信。传输层在 TCP（或 UDP）报文段的首部，指明<span style="color:#C71E64">源端口、目的端口</span>。

### 进程、端口号、传输层协议之间的关系

<span style="color:#B9375D"><span style="font-weight:bold">假设</span>：进程 1、5 正在用 TCP 通信；2、6 正在用 TCP 通信；3、7 正在用 UDP 通信；4、8 正在用 UDP 通信。</span>

<img src="../images/image-202601071949.webp" style="zoom:50%;" />

**注意**：

- <span style="color:#932F67">两台主机的端口号是相互独立的。</span>
- <span style="color:#34699A; font-weight:bold">TCP、UDP 的端口号也是相互独立的。</span>
- 当两个进程之间想要通信时，需要指明：
  1. 使用哪种传输层协议。
  2. 本进程绑定的端口号。
  3. 对方的 IP 地址和端口号。

<span style="color:#FF894F">套接字（Socket）= `(IP 地址 : 端口号)`。</span>（分为 TCP 套接字、UDP 套接字）

### 熟知端口号

|    应用程序    | FTP  | TELNET | SMTP | DNS  | TFTP | HTTP | SNMP |
| :------------: | :--: | :----: | :--: | :--: | :--: | :--: | :--: |
| **熟知端口号** |  21  |   23   |  25  |  53  |  69  |  80  | 161  |

0~1023 为熟知端口号，开发的时候一般不使用。

其他端口号在实际开发时并没有特别严格的限制，只要在本机没有被使用的端口号都可以使用。

<span style="color:#FF2DD1">端口号分类只是一种“建议标准”，而非“强制标准”。</span>

### 有连接的传输 vs. 无连接的传输

<img src="../images/image-202601072102.webp" style="zoom:50%;" />

- <span style="color:#ED3500; font-weight:bold">有连接</span>：传输前先打招呼，先<span style="color:#568F87">确认对方已经准备好接收数据</span>。传输结束时，也要<span style="color:#568F87">告知对方已结束</span>。
- <span style="color:#001BB7; font-weight:bold">无连接</span>：不打招呼，直接把数据传给对方。

### 可靠的传输 vs. 不可靠的传输

<img src="../images/image-202601072108.webp" style="zoom:50%;" />

- <span style="color:#B33791; font-weight:bold">可靠的</span>：接收方使用“确认机制”让发送方知道哪些数据已被正确接收。
- <span style="color:#FF9898; font-weight:bold">不可靠的</span>：接收方无论收没收到数据、数据是否正确，都不给发送方反馈。

## UDP 数据报

### UPD 协议、UDP 数据报、UDP 首部

<img src="../images/image-202601082202.webp" style="zoom:50%;" />

- UDP 首部很小，只占 8B。
- UDP 每次传输一个完整的报文，不支持报文自动拆分、重装。
- UDP 是无连接的、不可靠的（可靠性可交给应用层处理），也不支持拥塞控制。
- UDP 支持一对一（封装成单播 IP 数据报）、一对多传输（封装成广播/多播 IP 数据报）。

### TCP 协议、TCP 报文段、TCP 首部

<img src="../images/image-202601082208.webp" style="zoom:50%;" />

- TCP 首部更大，占 20~60B。
- TCP 支持报文自动拆分、重装，因此可以传输长报文。
- TCP 是有连接的、可靠的、支持拥塞控制。
- TCP 仅支持一对一传输（因为通信双方的传输层必须先建立连接）。

### UDP 数据报格式

<img src="../images/image-202601082239.webp" style="zoom:50%;" />

> [!tip]
>
> IP 数据报首部固定占用 20 字节，其数据部分最大长度为 **65535 - 20 = 65515 字节**，因此封转在 IP 数据报数据段内的 UDP 数据报，实际最大长度即为 65515 字节。

### UDP 数据报示例

<img src="../images/image-202601082257.webp" style="zoom:50%;" />

---

**知识回顾**：

<img src="../images/image-202601082304.webp" style="zoom:50%;" />

## UDP 检验

### 一种新的差错检验方法

<img src="../images/image-202601082307.webp" style="zoom:50%;" />

<img src="../images/image-202601082312.webp" style="zoom:50%;" />

### UDP 检验（发送方的传输层）

<img src="../images/image-202601082324.webp" style="zoom:50%;" />

1. 传输层的 UDP 协议在计算检验和之前，先添加伪首部。
2. 把伪首部、首部、数据部分以 16bit 为一组，进行二进制加法（最高位产生的仅为需要<u>回卷</u>）。
3. 将最终的加法结果逐位取反，就得到 16bit 检验和，将其填入 UDP 首部。
4. 去掉伪首部，并将 UDP 数据报交给网络层，封装成 IP 数据报。

### UDP 检验（接收方的传输层）

<img src="../images/image-202601090009.webp" style="zoom:50%;" />

1. 网络层向传输层递交 UDP 数据报。
2. 传输层在 UDP 数据报前，添加伪首部。
3. 把伪首部、UDP 首部、数据部分以 16bit 为一组，进行二进制加法（最高位产生的进位需要<u>回卷</u>）。
4. 若加法结果为全 1，说明无比特错误，于是接收该 UDP 数据报，并根据目的端口号，向应用层递交报文；若加法结果不为全 1，说明有差错，于是丢弃该 UDP 数据报。

---

<img src="../images/image-202601090016.webp" style="zoom:50%;" />

---

**知识回顾**：

<img src="../images/image-202601090020.webp" style="zoom:50%;" />

### IP 数据报（IP 分组）的格式

<img src="../images/image-202512240103.webp" style="zoom:50%;" />

IP 数据报在传输过程中仅校验首部完整性（不校验数据部分），其校验逻辑与 UDP 检验和一致：

将 IP 数据报首部按 16 位分组，执行二进制求和（需处理进位回卷，即溢出位循环加到和的最低位），对求和结果逐位取反后，即 IP 数据报的首部检验和。需注意的是，该过程**不涉及伪首部**，仅针对 IP 首部本身进行校验。

## TCP 报文段（TCP 段）

TCP Segment（TCP 报文段，另译“TCP 段”）。

<img src="../images/image-202601090050.webp" style="zoom:50%;" />

### TCP 协议的三大阶段

<img src="../images/image-202601090132.svg" style="zoom:67%;" />

TCP 协议的三大阶段：

- 建立连接（三次握手）
- 数据传输
- 释放连接（四次挥手）

### 建立一次 TCP 连接可以传输多个报文

**假设**：建立 TCP 连接时，双方协商 <span style="color:#9929EA; font-weight:bold">MSS 为 1000B</span>（Maximum Segment Size，最大段长）。

<img src="../images/image-202601090149.webp" style="zoom:50%;" />

- 每次建立 TCP 连接，可以传输多个报文（双向）。
- <span style="color:#9929EA; font-weight:bold">TCP 是面向字节流的（而 UDP 是面向报文的）。</span>无论传输多少个报文，在 TCP 协议看来都是一连串字节流。

> [!tip]
>
> TCP 并不会强制要求每个 TCP 段都满载数据，只要别超过 MSS 就行。

### TCP 段格式

<img src="../images/image-202601090206.webp" style="zoom: 50%;" />

<img src="../images/image-202601091202.webp" style="zoom: 50%;" />

<img src="../images/image-202601091205.webp" style="zoom:50%;" />

<img src="../images/image-202601091240.webp" style="zoom:50%;" />

> [!tip]
>
> - “数据偏移”（Data Offset）这个翻译具有迷惑性，容易误解。
> - 在 TCP 首部中，并不会专门记录 TCP 数据部分长度（会根据 IP 首部、TCP 首部计算出来）。

<img src="../images/image-202601091255.png" style="zoom:50%;" />

- **URG**：紧急位（Urgent）
- **PSH**：推送位（Push）
- **RST**：复位位（Reset）

<img src="../images/image-202601091306.png" style="zoom: 50%;" />

- **SYN**：同步位
- **FIN**：终止位（Finish）

> [!tip]
>
> - <span style="color:#6E026F; font-weight:bold">只要<u>握手 ①</u>、<u>握手 ②</u> 的 SYN = 1，其他所有 TCP 报文段都是 SYN = 0。</span>
> - <span style="color:#94A378; font-weight:bold">只有<u>挥手 ①</u>、<u>挥手 ③</u> 的 FIN = 1，其他所有 TCP 报文段都是 FIN = 0。</span>

<img src="../images/image-202601091322.png" style="zoom:50%;" />

> [!tip]
>
> - 这个字段是实现“<u>流量控制</u>”的关键。
> - “<u>窗口</u>”一般记为 <span style="color:#9E3B3B; font-weight:bold">rwnd</span> 或 <span style="color:#9E3B3B; font-weight:bold">rcvwnd</span>。

<img src="../images/image-202601091338.webp" style="zoom:50%;" />

<img src="../images/image-202601091339.webp" style="zoom:50%;" />

<img src="../images/image-202601091341.webp" style="zoom:50%;" />

- 建立 TCP 连接时，在<u>握手 ①</u>、<u>握手 ②</u><span style="color:#1D546D">选项</span>中协商 <span style="color:#F16D34"><span style="font-weight:bold">MSS</span>（Maximum Segment Size，最大段长）</span>。
- <span style="color:#980404; font-weight:bold">MSS 的值标售在接下来的数据传输中，一个 TCP 报文段最多携带多少数据（首部不算在内）。</span>
- 通常 MSS 不会设置太大，以免在 IP 层被分片。

## TCP 连接管理

**知识总览**：

<img src="../images/image-202601091539.svg"  />

### 建立连接（三次握手）

**SYN、ACK、seq、ack**：

<img src="../images/image-202601091545.webp" style="zoom:50%;" />

- 在 TCP 全过程中，只有握手 ①、握手 ② 的 SYN = 1。
- 在 TCP 全过程中，只有握手 ① 的 ACK = 0。
- 握手 ①、握手 ② 不能携带数据（只有 TCP 首部），但是要消耗一个序号。

<img src="../images/image-202601091631.webp" style="zoom:50%;" />

- 握手 ① 和握手 ② 不携带数据，握手 ③ 可以携带数据。
- 握手 ① 和握手 ② 固定消耗 1 个序号。
- 握手 ③ 若不携带数据，就不消耗序号。

---

<img src="../images/image-202601091643.webp" style="zoom:50%;" />

---

**客户端、服务器进程 TCP 状态变化**：

<img src="../images/image-202601091555.webp" style="zoom:50%;" />

发出/收到某个握手报文段前后，TCP 状态如何变化？

### 建立连接阶段耗时分析

从发出握手 ①，到客户端进程可以发送数据，至少需要多久？——1 RTT。

从发出握手 ①，到服务器进程可以发送数据，至少需要多久？——1.5 RTT。

### 释放连接（四次挥手）

**FIN、ACK、seq、ack**：

<img src="../images/image-202601091716.webp" style="zoom:50%;" />

- 在 TCP 全过程中，只有挥手 ①、挥手 ③ 的 FIN = 1。
- 挥手 ①、挥手 ③ 即使不懈怠数据，也要消耗一个序号。
- 挥手 ② <u>可以</u>携带数据。
- 挥手 ④ <u>不可以</u>携带数据。

**客户端、服务器进程 TCP 状态变化**：

<img src="../images/image-202601091744.webp" style="zoom:50%;" />

发出/收到某个挥手报文段前后，TCP 状态如何变化？

> [!tip]
>
> 也可以是服务器先发出挥手。

---

<img src="../images/image-202601091849.webp" style="zoom:50%;" />

### 释放连接阶段耗时分析

<img src="../images/image-202601091744.webp" style="zoom:50%;" />

> [!tip]
>
> - 客户进程收到挥手 ③ 后，立即进入 TIME-WAIT 状态，并启动“TIME-WAIT 计时器”，<span style="color:#DE802B; font-weight:bold">倒计时 2 MSL 后才能进入 CLOSE 状态</span>。（若等待期间重复挥手 ③，就重置计时器）
> - <span style="color:#0D4715; font-weight:bold">MSL</span>（Maximum Segment Lifetime，最长报文段寿命），是由 TCP 协议规定的一个固定时间长度。

<img src="../images/image-202601091850.webp" style="zoom:50%;" />

- 从客户发出挥手 ①，到客户进程进入 CLOSE 状态，至少需要多久？—— 1 RTT + 2 MSL。
- 从客户发出握手 ①，到服务器进程进入 CLOSE 状态，至少需要多久？—— 1.5 RTT。

> [!tip]
>
> 若服务器进程收到挥手 ① 时，已经没有待传送数据，那么可以连续发出挥手 ②、挥手 ③。

---

<img src="../images/image-202601091931.webp" style="zoom:50%;" />

---

**知识总览**：

<img src="../images/image-202601091935.webp" style="zoom:50%;" />

## TCP 可靠传输 & 流量控制

**知识总览**：

<img src="../images/image-202601092016.webp" style="zoom:50%;" />

### 回顾：TCP 首部的相关字段

<img src="../images/image-202601092108.webp" style="zoom:50%;" />

> [!tip]
>
> <span style="color:#360185; font-weight:bold">只有<u>握手 ①</u> 的 ACK = 0，其他所有 TCP 报文段都是 ACK = 1。</span>

### 重点：确认号、接收窗口大小

<img src="../images/image-202601092111.webp" style="zoom:50%;" />

### TCP 传输的底层原理

<img src="../images/image-202601092316.webp" style="zoom:50%;" />

### 一个端口可以建立多个 TCP 连接

<img src="../images/image-202601092317.webp" style="zoom:50%;" />

### 重点：累积确认

<img src="../images/image-202601092114.webp" style="zoom:50%;" />

### 重点：捎带确认

<img src="../images/image-202601101322.webp" style="zoom:50%;" />

### 重点：超时重传

<img src="../images/image-202601101342.webp" style="zoom:50%;" />

<img src="../images/image-202601101420.webp" style="zoom:50%;" />

### 重点：快重传机制、立即确认机制

<img src="../images/image-202601101720.svg" alt="0"  />

> [!tip]
>
> <span style="color:#5A9CB5; font-weight:bold">第一个 ACK 不属于冗余 ACK，后三个 ACK 才是冗余 ACK。</span>

---

<img src="../images/image-202601101613.png" style="zoom:50%;" />

---

**知识回顾**：

<img src="../images/image-202601101424.webp" style="zoom:50%;" />

> [!tip]
>
> 应该理解为连续收到 1 + 3 个确认号相同的 ACK（后三个属于冗余 ACK）。

<img src="../images/image-202601101434.webp" style="zoom:50%;" />

## TCP 拥塞控制

**知识总览**：

<img src="../images/image-202601101732.webp" style="zoom:50%;" />

### TCP 拥塞控制、TCP 流量控制的区别与联系

<img src="../images/image-202601101733.png" style="zoom:50%;" />

- **流量控制**：控制<u>端到端</u>的数据发送量，是“<u>局部的</u>”。
- <span style="color:#CC561E; font-weight:bold">拥塞控制</span>：控制<u>整个网络</u>中每台主机的数据发送量，降低路由器负载，是“<u>全局的</u>”。

**如何判断网络拥塞？**

- 发出的每个报文段，都能顺利地收到 ACK 确认——<span style="color:#8A8635; font-weight:bold">不拥塞</span>。
- 发出的报文段未能按时收到 ACK，引发<span style="color:#CF0F0F">超时重传</span>——<span style="color:#CF0F0F; font-weight:bold">严重拥塞</span>。
- 收到冗余 ACK，引发<span style="color:#3291B6">快重传</span>——<span style="color:#3291B6; font-weight:bold">有点拥塞</span>。

**若检测到网络拥塞怎么办？**

- <span style="color:#E2852E; font-weight:bold">迅速减少发送的数据量。</span>
- <span style="color:#CF0F0F; font-weight:bold">严重拥塞</span>就<span style="color:#CF0F0F">迅速缩小</span><u>拥塞窗口</u>。
- <span style="color:#3291B6; font-weight:bold">有点拥塞</span>就<span style="color:#3291B6">适当缩小</span><u>拥塞窗口</u>。

### 慢开始、拥塞避免

<img src="../images/image-202601101922.webp" style="zoom:50%;" />

- <span style="color:#4A70A9; font-weight:bold">慢开始算法</span>：cwnd 值从 1 开始，<span style="color:#BF124D">每收到一个 ACK，就让 cwnd + 1</span>。<span style="color:#4A70A9; font-weight:bold">（当 cwnd < ssthresh 时适用）</span>
- <span style="color:#63A361; font-weight:bold">拥塞避免算法</span>：在一个 RTT 内，<span style="color:#BF124D">即使收到多个 ACK，也只能让 cwnd + 1</span>。<span style="color:#63A361; font-weight:bold">（当 cwnd ≥ ssthresh 时适用）</span>

> [!tip]
>
> 一般地：
>
> 1. 常与“流量控制”综合考察，此时仅需考虑接收窗口大小。
> 2. 通常仅涉及单向传输（TCP 连接双方只有一方发送数据）。
> 3. <span style="color:#DC2F2F">通常默认每个 TCP 报文段都以最大段长 MSS 满载数据。</span>
> 4. <span style="color:#DC2F2F">拥塞窗口的大小常以“MSS 的倍数”作为单位。</span>
> 5. 接收方收到一个报文段，会<span style="color:#0D63A5">“立即确认”</span>（会导致冗余 ACK，快重传），而非“推迟确认”。
>
> 为聚焦拥塞控制，<u>接下来的讨论中，假设接收方的接收窗口足够大</u>，这样发送窗口大小就只受拥塞窗口限制。

<img src="../images/image-202601102049.png" style="zoom: 50%;" />

---

<img src="../images/image-202601102053.png" style="zoom:50%;" />

<img src="../images/image-202601102108.png" style="zoom:50%;" />

---

### 快重传、快恢复

<img src="../images/image-202601102244.png" style="zoom:50%;" />

- <span style="color:#FF894C; font-weight:bold">快重传</span>：当发送方收到三个确认号相同的冗余 ACK 时，立即重传对应报文段。
- <span style="color:#0D63A5; font-weight:bold">快恢复算法</span>：一旦<span style="color:#C75643">发送快重传</span>，就将<span style="color:#C75643">阈值、cwnd 都设置为当前 cwnd 的一般</span>，然后<span style="color:#B088F9; font-weight:bold">切换到“拥塞避免算法”</span>。

