# 文件管理

## 初识文件管理

**知识总览**：

文件就是一组有意义的信息、数据集合。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202508030212.svg" style="zoom:80%;" />

计算机中存放了各种各样的文件，一个文件有哪些属性？

<span style="color:#F7374F">**文件内部**</span>的数据应该怎样组织起来？<span style="color:#F7374F">**文件之间**</span>又应该又应该怎么组织起来？

从下往上看，OS 应提供哪些功能，才能方便用户、应用程序使用文件？

从上往下看，文件数据应该怎么存放在外存（磁盘）上？

### 文件的属性

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250622010222843.png" alt="image-20250622010222843" style="zoom:40%;" />



<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250622010326986.png" alt="image-20250622010326986" style="zoom:33%;" />

- <span style="color:#27548A">**文件名**</span>：由创建文件的用户决定文件名，主要是为了方便用户找到文件，<span style="color:#27548A">同一目录下不允许有**重名文件**</span>

- **<span style="color:#27548A">标识符</span>**：一个系统内的**各文件标识符唯一**，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种**内部名称**

- <span style="color:#27548A">**类型**</span>：指明文件的类型

- <span style="color:#27548A">**位置**</span>：文件存放的路径（让**用户**使用）、在外存中的地址（**操作系统**使用，对用户不可见）

- **<span style="color:#27548A">大小</span>**：指明文件大小

- <span style="color:#27548A;font-weight:bold">创建时间、上次修改时间、文件所有者信息</span>

- <span style="color:#27548A;font-weight:bold">保护信息</span>：对文件进行保护的**访问控制信息**

### 文件内部的组织

- <span style="color:#3674B5">**无结构文件（如文本文件）**</span>：由一些二进制或字符流组成，又称<span style="color:#3674B5">流式文件</span>
- <span style="color:#3674B5">**有结构文件（如数据库表）**</span>：由一组相似的记录组成，又称<span style="color:#3674B5">记录式文件</span>；其中<span style="color:#FF6F3C">记录</span>是一组<span style="color:#FF6F3C">**相关数据项**的集合</span>，而<span style="color:#FF6F3C">数据项</span>是<span style="color:#FF6F3C">文件系统中**最基本**的数据单位</span>

<img src="/home/leafevans/.config/Typora/typora-user-images/image-20250622010853360.png" alt="image-20250622010853360" style="zoom:33%;" />



<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506220113.png" style="zoom:45%;" />

### 文件外部的组织

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250622011502891.png" style="zoom:33%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506220118.png" style="zoom: 50%;" />

所谓的**<span style="color:#B22222">目录</span>**其实就是**<span style="color:#B22222">文件夹</span>**。

用户可以自己创建一层一层的目录，各层目录中存放相应的文件；系统中的各个文件就通过一层一层的目录合理有序地组织起来了。

> **注意**：<span style="color:#725CAD">**目录**其实也是**一种特殊的<u>有结构文件</u>**，由记录组成。</span>

### 操作系统向上提供功能

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250622012422197.png" alt="image-20250622012422197" style="zoom:33%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250622012457286.png" alt="image-20250622012457286" style="zoom:33%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250622070235139.png" alt="image-20250622070235139" style="zoom:33%;" />

- 可以<span style="color:#FF9B17">**创建文件**</span>（点击新建后，图形化交互进程在背后调用了 **`create` 系统调用**）
- 可以<span style="color:#F7374F;font-weight:bold">读文件</span>，将文件数据读入内存，才能让 CPU 处理（双击后，**记事本**应用程序通过操作系统提供的<span style="color:#F7374F">**读文件**</span>功能，即 **`read` 系统调用**，将文件数据从外存读入内存，并显示在屏幕上）
- 可以<span style="color:#27548A;font-weight:bold">写文件</span>，将更改过的文件数据写回外存（我们在**记事本**应用程序中编辑文件内容，点击**保存**后，**记事本**应用程序通过操作系统提供的<span style="color:#27548A;font-weight:bold">写文件</span>功能，即 <span style="color:#27548A">**`write` 系统调用**</span>，将文件数据从内存写回外存）
- 可以<span style="color:#693382; font-weight:bold">删除文件</span>（点了**删除**之后，图形化交互进程通过操作系统提供的<span style="color:#693382;font-weight:bold">删除文件</span>功能，即 <span style="color:#693382;font-weight:bold">`delete` 系统调用</span>，将文件数据从外存中删除）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507080022.png" style="zoom: 50%;" />

读/写文件之前，需要使用上述**打开文件**；读/写文件之后，需要使用上述**关闭文件**。

可用<span style="color:#B33791">几个**基本操作**完成**更复杂**的操作</span>（就像数学中的四则运算一样），比如**复制文件**是先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中。

### 文件在外存的存放方式

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250622071120380.png" alt="image-20250622071120380" style="zoom:33%;" />

与内存一样，外存也是<span style="color:#4DA8DA">由一个个**存储单元组成**的</span>，每个存储单元可以存储一定量的数据（如 1B）；<span style="color:#0065F8">每个存储单元对应一个物理地址。</span>

类似于<span style="color:#D5451B">**内存**分为一个个**内存块**</span>，<span style="color:#D5451B">**外存**会分为一个个**块/磁盘块/物理块**</span>。每个磁盘块的大小是相等的，每块一般包含 2 的整数幂个地址（如本例中，一块包含 $2^{10}$ 个地址，即 1KB）。同样类似的是，文件的逻辑地址也可以分为 `(逻辑块号, 块内地址)`，操作系统同样需要将逻辑地址转换为外存的物理地址 `(物理块号, 块内地址)` 的形式。块内地址的位数<span style="color:#D50B8B">**取决于磁盘块的大小**</span>。

操作系统<span style="color:#A53860">**以*块*为单位为文件分配**</span>存储空间（类似于内存<span style="color:#A53860">**以*页*为单位分配空间**</span>），因此即使一个文件大小只有 10B，但它依然需要占用 1KB 的磁盘块；<span style="color:#483AA0">**外存中的数据**读入内存时同样**以块为单位**。</span>

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507021412.svg" style="zoom: 67%;" />

### 操作系统实现的其他文件管理功能

- **文件共享**：使多个用户可以<span style="color:#C5172E">**共享使用**一个文件</span>
- **文件保护**：如何保证不同的用户对文件有<span style="color:#C5172E">**不同的**操作权限</span>

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506220824.png" style="zoom:40%;" />

## 文件的逻辑结构

**知识总览**：

![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506220743.svg)

所谓的<span style="color:#007074;font-weight:bold">逻辑结构</span>，就是指在用户看来，文件内部的数据应该是**如何组织**起来的；而<span style="color:#007074;font-weight:bold">物理结构</span>指的是在操作系统看来，文件的数据是**如何存放**在外存中的。

类似于数据结构的**逻辑结构**和**物理结构**，如<span style="color:#EB5B00">**线性表**</span>就是一种逻辑结构；在用户角度看来，线性表就是一组有先后关系的元素序列，如 `a, b, c, d, e`。

<span style="color:#B03052;font-weight:bold">线性表</span>这种逻辑结构可以用**不同的物理结构**实现，如：<u>顺序表/链表</u>。顺序表的各个元素<span style="color:#F7AD45">**在逻辑上相邻，在物理上也相邻**</span>；而链表的各个元素在物理上可以是不相邻的。因此，**顺序表**可以实现<span style="color:#255F38">**随机访问**</span>，而**链表**无法实现<span style="color:#255F38">**随机访问**</span>。

可见，算法的具体实现与**逻辑结构、物理结构**都有关。（文件也一样，文件操作的具体实现与文件的**逻辑结构、物理结构**都有关）

### 无结构文件

按文件是否有结构分类，可以分为无结构文件、有结构文件两种。

<span style="color:#4D55CC; font-weight:bold">无结构文件</span>：文件内部的数据就是一系列二进制流或字符流组成，又称**流式文件**例如，Windows 操作系统中的 `.txt` 文件。

文件内部的数据其实就是一系列字符流，没有明显的结构特性；因此也不用探讨无结构文件的**逻辑结构**问题。

### 有结构文件

<span style="color:#E53888;font-weight:bold">有结构文件</span>：由一组相似的记录组成，又称**记录式文件**，每条记录又若千个数据项组成，例如，数据库表文件。一般来说，每条记录有一个数据项可作为<span style="color:#AA60C8">**关键字**</span>（作为识别不同记录的 ID）。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250622080614903.png" alt="image-20250622080614903" style="zoom:40%;" />

根据各条记录的长度（占用的存储空间）是否相等，有可分为<span style="color:#1B4D3E; font-weight:bold">定长记录</span>和<span style="color:#1B4D3E; font-weight:bold">可变长记录</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250622080903494.png" alt="image-20250622080903494" style="zoom:50%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250622081023354.png" style="zoom:50%;" />

根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类：

![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506220756.svg)

### 顺序文件

<span style="color:#3D8D7A; font-weight:bold">顺序文件</span>：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是<span style="color:#3A7D44">**定长**</span>的或<span style="color:#3A7D44">**可变长**</span>的，各个记录在物理上可以<span style="color:#3A7D44">**顺序存储**</span>或<span style="color:#3A7D44">**链式存储**</span>。

1. <span style="color:#E14434">**顺序存储**</span>：逻辑上相邻的记录，物理上也相邻（类似于顺序表）

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506301613.svg" style="zoom: 80%;" />

2. <span style="color:#E14434">**链式存储**</span>：逻辑上相邻的记录，物理上不一定相邻（类似于链表）

   ![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506301624.svg)

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506301651.svg" style="zoom:130%;" />

**串结构**通常按照<span style="color:#E14434">**记录的存入时间**</span>决定<span style="color:#E14434">**记录的顺序**</span>。

假设已经知道了文件的起始地址（也就是第一个记录存放的位置），则：

- 能否快速找到<span style="color:#BA487F">**第 $i$ 个记录**</span>对应的地址？（即能否实现**随机存取**）
- 能否快速找到<span style="color:#BA487F">**某个关键字**</span>对应的记录存放位置？

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506220828.png" style="zoom: 100%;" />

可变长记录需要显式地给出<span style="color:#555879">**记录长度**</span>，假设用 1 字节表示记录长度，有：

![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506301722.svg)

<span style="color:#FF2DF1;font-weight:bold">结论</span>：<span style="color:#B33791;font-weight:bold">定长记录</span>的顺序文件，若物理上采用**<span style="color:#0D5EA6">顺序存储</span>**，则可实现**<span style="color:#0D5EA6">随机存取</span>**；若能再保证**<span style="color:#0D5EA6">记录的顺序结构</span>**，则可实现**<span style="color:#0D5EA6">快速检索</span>**。（即根据关键字快速找到对应记录）

> **注意**：
>
> 一般来说，**顺序文件**指的是<span style="color:#1F7D53">**<u>物理上</u>顺序存储**的顺序文件</span>。

可见，顺序文件的<span style="color:#FFA725">**缺点**</span>是<span style="color:#FFA725">**增加/删除**一个记录比较困难</span>。（如果是串结构则相对简单）

### 索引文件

对于**<span style="color:#ED3500">可变长记录</span>**文件，要找到第 $i$ 个记录，**<span style="color:#ED3500">必须先顺序查找</span>**前 $i-1$ 个记录但是很多应用场景中又必须使用<span style="color:#ED3500; font-weight:bold">可变长记录</span>。（可变长记录的顺序文件是<span style="color:#ED3500">**累加记录长度以及记录长度数据项的大小**</span>得到的最终地址）

如何解决这个问题？

1. 建立一张<span style="color:#E67514">**索引表**</span>以加快文件检索速度；<span style="color:#E67514; font-weight:bold">每条记录对应一个索引项</span>
2. 文件中的这些记录可以<span style="color:#E67514; font-weight:bold">离散地存放</span>

![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506301830.svg)

<span style="color:#4D55CC">**索引表**</span>本身是<span style="color:#4D55CC">**定长记录**的顺序文件</span>，因此可以快速找到第 $i$ 个记录对应的索引项。可<span style="color:#00CAFF">将**关键字**作为**索引号内容**</span>，若按关键字顺序排列，则还可以支持按照关键字折半查找。

每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此<span style="color:#2DAA9E; font-weight:bold">主要用于对信息处理的及时性要求比较高的场合</span>。

另外，<span style="color:#AC1754">可以用**不同的数据项**建立**多个索引表**</span>。如学生信息表中，可用关键字**学号**建立一张索引表；也可用**姓名**建立一张索引表，这样就可以根据**姓名**快速地检索文件了。（例如，SQL 就支持根据某个数据项建立索引的功能）

### 索引顺序文件

**索引文件的缺点**：每个记录对应一个索引表项，因此索引表可能会很大。比如文件的每个记录平均只占 8B，而每个索引表项占 32 个字节，那么索引表都要比文件内容本身大 4 倍，这样对存储空间的利用率就太低了。

索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是<span style="color:#EB5B00">**一组记录**对应**一个索引表项**</span>。（此处的所有表都是**顺序结构**的，包括索引表，只是按照特征进行分组了）

![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506301857.svg)

在上述例子中，学生记录按照学生姓名的开头字母进行分组；每个分组就是一个顺序文件，分组内的记录不需要按关键字排序（<span style="color:#E55050">串结构</span>）。

> **注意**：
>
> 索引顺序文件的索引项也<span style="color:#E55050">不需要按**关键字顺序排序**</span>，这样可以极大地方便新表项的插入。（也就是顺序结构中的<span style="color:#E55050">串结构</span>）

用这种策略确实可以让索引表<span style="color:#F4631E">**瘦身**</span>，但是是否会出现不定长记录的顺序文件<span style="color:#F4631E">**检索速度慢**</span>的问题呢？

若一个<span style="color:#C14600">**顺序文件**</span>有 10000 个记录，则根据关键字检索文件，只能从头开始顺序查找，<span style="color:#C14600">平均须查找 5000 个</span>记录。

若采用<span style="color:#C14600">**索引顺序文件**</span>结构，可把 10000 个记录分为 $\sqrt{10000} = 100$ 组，每组 100 个记录。则需要先顺序查找索引表找到分组（共 100 个分组，因此索引表长度为 100，平均需要查 50 次），找到分组后，再在分组中顺序查找记录（每个分组 100 个记录，因此平均需要查 50次）。可见，采用索引顺序文件结构后，<span style="color:#C14600">平均查找次数减少为 $50+50=100$ 次</span>。

同理，若文件共有 $10^6$ 个记录，则可分为 1000 个分组，每个分组 1000 个记录，根据关键字检索一个记录，平均需要查找 $500+500=1000$ 次。这个<span style="color:#3F7D58">**查找次数依然很多**</span>，如何解决呢？

### 多级索引顺序文件

为了进一步提高检索效率，可以为顺序文件<span style="color:#E50046">建立**多级索引表**</span>。例如，对于一个含 $10^6$ 个记录的文件，可先为该文件建立一张低级索引表，每 100 个记录为一组，故低级索引表中共有 10000 个表项（即 10000 个定长记录），再把这 10000 个定长记录分组，每组 100 个，为其建立顶级索引表，故顶级索引表中共有 100 个表项。

![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506301925.svg)

此时，检索一个记录平均需要查找 $50 + 50 + 50 = 150$ 次。

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506221102.png" style="zoom:50%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506221105.png" style="zoom:50%;" />

## 文件目录

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250630194242752.png" alt="image-20250630194242752" style="zoom: 33%;" />

这种目录结构对于用户来说有什么好处？

文件之间的组织结构清晰，易于查找。编程时也可以很方便的用文件路径找到一个文件。如：

```c
FILE *fp;
fp = fopen("F:\data\myfile.dat");
```

用户可以轻松实现**按名存取**。

从操作系统的角度来看，这些目录结构应该是如何实现的？

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506221240.png" style="zoom:50%;" />

### 文件控制块

**根目录（D 盘）的目录文件**：

| 文件名      | 类型 | 存取权限 | $\dots$ | 物理位置      |
| ----------- | ---- | -------- | ------- | ------------- |
| qianlong    | 目录 | 只读     | $\dots$ | 外存 7 号块   |
| QMDownLoad  | 目录 | 读/写    | $\dots$ | 外存 18 号块  |
| $\dots$     |      |          | $\dots$ |               |
| 照片        | 目录 | 读/写    | $\dots$ | 外存 643 号块 |
| $\dots$     |      |          | $\dots$ |               |
| 对账单4.txt | txt  | 只读     | $\dots$ | 外存 324 号块 |

**目录**本身就是一种<span style="color:#E50046">**有结构文件**</span>，由一条条记录组成；每条记录对应一个在该放在该目录下的**文件**。

当我们双击<span style="color:#C84C05;font-weight:bold">照片</span>后，操作系统会在这个<span style="color:#FA812F">**目录表**</span>中找到关键字<span style="color:#C84C05;font-weight:bold">照片</span>对应的目录项（也就是记录），然后从外存中将<span style="color:#C84C05;font-weight:bold">照片</span>目录的信息<span style="color:#FF9149; font-weight:bold">读入内存</span>。于是，<span style="color:#C84C05;font-weight:bold">照片</span>目录中的内容就可以显示出来了，以下是**照片目录对应的目录文件**：

| 文件名                  | 类型 | 存储权限 | $\dots$ | 物理位置      |
| ----------------------- | ---- | -------- | ------- | ------------- |
| 2015-08                 | 目录 | 只读     | $\dots$ | 外存 25 号块  |
| 2015-09                 | 目录 | 读/写    | $\dots$ | 外存 278 号块 |
| $\dots$                 |      |          | $\dots$ |               |
| 2016-02                 | 目录 | 读/写    | $\dots$ | 外存 152 号块 |
| 微信截图_20180826102629 | PNG  | 只读     | $\dots$ | 外存 995 号块 |

目录文件中的**一条记录**就是一个<span style="color:#F72C5B;font-weight:bold">文件控制块（FCB）</span>；FCB 的<span style="color:#547792;font-weight:bold">有序集合</span>称为<span style="color:#E07B39;font-weight:bold">文件目录</span>，一个 FCB 就是一个<span style="color:#E07B39;font-weight:bold">文件目录项</span>。

FCB 中包含了文件的<span style="color:#CA7373">**基本信息**</span>（<span style="color:#CA7373;font-weight:bold">文件名</span>、<span style="color:#CA7373;font-weight:bold">物理地址</span>、逻辑结构、物理结构等）、存取控制信息（是否可读/可写、禁止访问的用户名单等）、使用信息（如文件的建立时间、修改时间等）。

<span style="color:#31511E;font-weight:bold">最重要、最基本</span>的还是<span style="color:#31511E">**文件名、文件存放的物理地址**</span>。

FCB 实现了<span style="color:#D50B8B">**文件名和文件之间的映射**</span>，使用户（用户程序）可以实现**按名存取**。

---

需要对<span style="color:#FE4F2D">**目录**</span>进行哪些操作呢？

- <span style="color:#CD5C08;font-weight:bold">搜索</span>：当用户要使用一个文件时，系统要根据<span style="color:#48A6A7; font-weight:bold">文件名</span>搜索目录，找到该文件对应的目录项

- <span style="color:#CD5C08;font-weight:bold">创建文件</span>：创建一个新文件时，需要在其所属的目录中增加一个目录项
- <span style="color:#CD5C08;font-weight:bold">删除文件</span>：当删除一个文件时，需要在目录中删除相应的目录项
- <span style="color:#CD5C08;font-weight:bold">显示文件</span>：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性
- <span style="color:#CD5C08;font-weight:bold">修改文件</span>：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如文件重命名）

### 目录结构——单级目录结构

早期操作系统并不支持多级目录，<span style="color:#48A6A7">整个系统中**只建立<u>一张目录表</u>**</span>，每个文件占一个目录项。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507010010.svg" style="zoom:80%;" />

单级目录实现了<span style="color:#FF7777;font-weight:bold">按名存取</span>，但是**不允许文件重名**。

在创建一个文件时，需要先检查目录表中有没有重名文件，<span style="color:#FF9149">**确定不重名后才能允许建立文件**</span>，并将新文件对应的目录项插入目录表中。

显然，单级目录结构不适用于<span style="color:#FF7777">**多用户操作系统**</span>。

### 目录结构——两级目录结构

早期的多用户操作系统采用两级目录结构，分为<span style="color:#06D001">**主文件目录**</span>（MFD, Master File Directory）和<span style="color:#06D001">**用户文件目录**</span>（UFD, User File Directory）。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507011118.svg" style="zoom:80%;" />

<span style="color:#F7374F; font-weight:bold">主文件目录</span>记录<span style="color:#8F87F1">**用户名**及相应用户文件目录的**存放位置**</span>，用户文件目录由该用户的文件 FCB 组成。

两级目录结构允许不同用户的文件重名，也可以在目录上实现<span style="color:#EB5B00">**访问限制**</span>（检查**此时登录的用户名<u>是否匹配</u>**）；但是两级目录结构依然<span style="color:#FE4F2D;font-weight:bold">缺乏灵活性</span>，用户<span style="color:#FF9A00;font-weight:bold">不能对自己的文件<u>进行分类</u></span>。

### 目录结构——多级目录结构（树形目录结构）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507011311.svg" style="zoom:80%;" />

用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间用 `/` 隔开。<span style="color:#EE4E4E">从根目录出发</span>的路径称为<span style="color:#EE4E4E">绝对路径</span>。

例如，`自拍.jpg` 的绝对路径是 `/照片/2015-08/自拍.jpg`。

系统根据绝对路径一层一层地找到下一级目录。刚开始<span style="color:#E8751A">从外存读入根目录的目录表</span>；找到 `照片` 目录的存放位置后，<span style="color:#E8751A">从外存读入对应的目录表</span>；再找到 `2015-08` 目录的存放位置，再<span style="color:#E8751A">从外存读入对应目录表</span>；最后才找到文件 `自拍.jpg` 的存放位置。整个过程<span style="color:#E8751A">需要 3 次读磁盘 I/O 操作</span>。

很多时候，用户会连续访问<span style="color:#2C7865">**同一目录**</span>内的多个文件（例如，接连查看 `2015-08` 目录内的多个照片文件），显然，**每次**都从根目录开始查找，是很低效的。因此可以设置一个<span style="color:#2C7865">**当前目录**</span>。

例如，此时已经打开了 `照片` 的目录文件，也就是说，<span style="color:#65B741">这张目录表**已调入内存**</span>，那么可以把它设置为 `当前目录`。当用户想要访问某个文件时，可以使用<span style="color:#76453B">从当前目录出发</span>的**<span style="color:#76453B">相对路径</span>**。

在 Linux 中，`.` 表示当前目录，因此如果 `照片` 是当前目录，则 `自拍.jpg` 的**相对路径**为：`./2015-08/自拍.jpg`。从当前路径出发，只需要查询内存中的 `照片` 目录表，即可知道 `2015-08` 目录表的存放位置，从外存调入该目录，即可知道 `自拍.jpg` 存放的位置了。

可见，引入<span style="color:#FA7070;font-weight:bold">当前目录</span>和**<span style="color:#FA7070">相对路径</span>**后，磁盘 I/O 的次数减少了，这就提升了访问文件的效率。

<span style="color:#61A3BA">**树形目录结构**</span>可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行<span style="color:#129990">文件的管理和保护</span>。但是，树形结构<span style="color:#FF9B9B">**不便于实现文件的共享**</span>。为此，提出了<span style="color:#213363;font-weight:bold">无环图目录结构</span>。

### 无环图目录结构

在树形目录结构的基础上，增加一些指向**同一节点**的有向边，使整个目录成为一个<span style="color:#D864A9">**有向无环图**</span>，可以更方便地实现**多个用户间的文件共享**。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507011424.svg" style="zoom:80%;" />

<span style="color:#898121">可以用**不同**的文件名**指向同一个文件**</span>，甚至可以指向**同一个目录**。（共享同一目录下的所有内容）

需要为<span style="color:#1F8A70">每个共享结点设置一个**共享计数器**</span>，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的 FCB，并使<span style="color:#1F8A70">共享计数器**减 1**</span>，并不会<span style='color:#CB0404'>**直接删除**</span>共享结点。

> **注意**：
>
> 共享文件不同于复制文件。在<span style="color:#FF7B54">**共享文件**中，由于各用户指向的是同一个文件，因此只要其中**一个用户修改了文件数据**，那么所有用户都**可以看到文件数据的变化**</span>。

### 索引结点（FCB 的改进）

其实在查找各级目录的过程中，只需要用到<span style="color:#D50B8B;font-weight:bold">文件名</span>这个信息，只有文件名匹配时，才需要独处文件的其他信息。因此考虑让目录表<span style="color:#E55050; font-weight:bold">瘦身</span>来提升效率。

除了文件名之外的文件描述信息都可以放到<span style="color:#547792;font-weight:bold">索引结点</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507020115.svg" style="zoom: 80%;" />



假设一个 FCB 是 64B，磁盘块的大小为 1KB，则每个盘块中**只能存放 16 个 FCB**。若一个文件目录中共有 640 个目录项，则共需要占用 $\frac{640}{16} = 40$ 个盘块。因此按照某文件名检索该目录，平均需要查询 320 个目录项，<span style="color:#68B984">**平均需要启动磁盘 20 次（每次磁盘 I/O 读入一块）**</span>。

若<span style="color:#A27B5C">**使用索引结点机制**</span>，文件名占 14B，索引结点指针占 2B，则每个盘块可存放 64 个目录项，那么按文件名检索目录<span style="color:#A27B5C;font-weight:bold">平均只需要读入 $\frac{320}{64} = 5$ 个磁盘块</span>。显然，这<span style="color:#A27B5C">将大大提升文件**检索速度**</span>。

当找到文件名对应的目录项时，才需要**将索引结点调入内存**，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据<span style="color:#4CACBC">**存放位置**</span>即可找到文件。

<span style="color:#B33030">**存放在外存**</span>中的索引结点称为**<span style="color:#B33030">磁盘索引结点</span>**，当索引结点<span style="color:#B33030;font-weight:bold">放入内存</span>后称为**<span style="color:#B33030">内存索引结点</span>**。相比之下，<span style="color:#B33030;font-weight:bold">内存索引结点中需要增加一些信息</span>，比如：文件是否被修改、此时有几个进程正在访问该文件等。

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506221422.png"  />

## 文件的物理结构（文件分配方式）

**知识总览**：

![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506220820.svg)


![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506220821.svg)

### 文件块、磁盘块

与内存分页类似，磁盘中的存储单元也会被分为一个个<span style="color:#FF0B55; font-weight:bold">块/磁盘块/物理块</span>。很多操作系统中，<span style="color:#3A59D1">磁盘块的大小与**内存块、页面**的大小相同</span>。

内存与磁盘之间的<span style="color:#8F87F1">**数据交换**</span>（即读/写操作、磁盘 I/O）都是以**块**为单位进行的，即每次读入一块、或每次读出一块。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507021003.svg" style="zoom:67%;" />

在内存管理中，进程的逻辑地址空间被分为一个一个页面。

同样的，在外存管理中，为了方便对文件数据的管理，文件的<span style="color:#4D55CC">**逻辑地址空间**</span>也被分为了一个一个的<span style="color:#4D55CC">**文件块**</span>。

于是文件的逻辑地址也可以表示为 `(逻辑块号, 块内地址)` 的形式。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507021012.svg" style="zoom:67%;" />

若块的大小是 1KB，则 1MB 大小的文件可以被分为 1K 个块。

操作系统为文件<span style="color:#D91656">**分配存储空间**</span>都是<span style="color:#D91656">**以块为单位**</span>的，用户通过逻辑地址来操作自己的文件，操作系统要负责实现<span style="color:#D91656">从逻辑地址到物理地址</span>的映射。

### 文件分配方式——连续分配

<span style="color:#FF7777">**连续分配**</span>方式要求每个文件在磁盘上占有一组<span style="color:#578FCA">**连续的块**</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507021028.svg" style="zoom:67%;" />

用户通过逻辑地址来操作自己的文件，操作系统如何实现从逻辑地址到物理地址的映射？

`(逻辑块号, 块内地址)` → `(物理块号, 块内地址)`，只需转换块号就行，块内地址保持不变。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507031139.svg" style="zoom:80%;" />

> **注意**：文件目录中记录文件存放的**起始块号**和**长度**。（总共占用几个块）

用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（FCB）：
$$
物理块号=起始块号+逻辑块号
$$
当然，还需要检查用户提供的**块内地址是否合法**。（块内地址**<span style="color:#BC5A94">大于等于</span>**长度就不合法）

可以直接算出逻辑块号对应的物理块号，因此连续分配支持<span style="color:#FF0000">**顺序访问**</span>和<span style="color:#FF0000">**直接访问**</span>（即**随机访问**）。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507021101.svg" style="zoom: 67%;" />

读取某个磁盘块时，需要移动磁头。访问的两个磁盘块**相隔越远**，移动磁头所需**时间就越长**。

**结论**：<span style="color:#DF826C">**连续分配**</span>的文件在<span style="color:#DF826C">**顺序**</span>读/写时<span style="color:#DF826C">**速度最快**</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507021118.svg" style="zoom: 67%;" />

若此时**文件 A 要拓展**，需要再增加一个磁盘块（总共需要连续的 4 个磁盘块）。

由于采用连续结构，因此文件 A 占用的磁盘块**必须是连续的**。

由于文件 A 后面已经没有相邻的空闲块，因此将文件 A 全部迁移到绿色区域。

**结论**：物理上采用连续分配的文件<span style="color:#FF70AB">**不方便扩展**</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507021128.svg" style="zoom:67%;" />

物理上采用连续分配，存储空间<span style="color:#41B06E">**利用率低**</span>，会产生<span style="color:#41B06E">**难以利用的磁盘碎片**</span>。可以用<span style="color:#41B06E">**紧凑**</span>来处理碎片，但是需要耗费很大的时间代价。

---

- **优点**：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快
- **缺点**：不方便文件拓展；存储空间利用率低，会产生磁盘碎片

### 文件分配方式——链接分配方式

<span style="color:#B03052">**链接分配**</span>采取离散分配的方式，可以为文件分配离散的磁盘块。分为<span style="color:#B03052">**隐式链接**</span>和<span style="color:#B03052">**显式链接**</span>两种。

#### 链接分配——隐式链接

目录中记录了文件存放的起始块号和结束块号。当然，也可以增加一个字段来表示文件的长度。

除了文件最后一个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，这些指针对于用户是**透明的**。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507021431.svg" style="zoom:67%;" />

用户给出要访问的逻辑块号 $i$，操作系统找到该文件对应的目录项（FCB）。

**如何实现文件的逻辑块号到物理块号的转变？**

从目录项中找到起始块号（即 0 号块），将 0 号逻辑块读入内存，由此知道 1 号逻辑块存放的物理块号，于是读入 1 号逻辑块，再找到 2 号逻辑块的存放位置……以此类推。

因此，读入第 $i$ 号逻辑块，总共需要 $i + 1$ 次磁盘 I/O。

采用<span style="color:#4D55CC; font-weight:bold">链式分配（隐式链接）</span>方式的文件，<span style="color:#4D55CC">**只支持顺序访问，不支持随机访问**</span>，查找效率低。另外，指向下一个盘块的指针需要<span style="color:#4D55CC">**耗费少量的存储空间**</span>。

**是否方便拓展文件？**

若此时要拓展文件，则可以随便找一个空闲磁盘块，挂到文件的磁盘块链尾，并修改文件的 FCB。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507021446.svg" style="zoom:67%;" />

采用隐式链接的链接分配方式，<span style="color:#E53888">很方便文件拓展</span>。另外，所有的空闲磁盘块都可以被利用，<span style="color:#E53888">不会有碎片问题，外存利用率高</span>。

---

- **优点**：很方便文件拓展，不会有碎片问题，外存利用率高
- **缺点**：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间

#### 链接分配——显式链接

把用于链接文件**各物理块**的指针显式存放在一块表中，即<span style="color:#C5172E">**文件分配表**</span>（FAT, File Allocation Table）。

目录中只需要记录文件的起始块号。

假设某个新创建的**文件 aaa** 依次存放在磁盘块 `2 -> 5 -> 0 -> 1`，还有一个**文件 bbb** 依次存放在磁盘块 `4 -> 23 -> 3`。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507021502.svg" style="zoom: 67%;" />

> **注意**：
>
> 一个磁盘<span style="color:#AA60C8">**仅设置一张 FAT**</span>；开机时，将 FAT 读入内存，并<span style="color:#AA60C8">**常驻内存**</span>；FAT 的各个表项在物理上连续存储，且每一个表项长度相同，因此<span style="color:#AA60C8">**物理块号**</span>字段可以是隐含的。

**如何实现文件的逻辑块号到物理块号的转变？**

从目录项中找到起始块号，若 $i > 0$，则查询内存中的文件分配表 FAT，往后找到 $i$ 号逻辑块对应的物理块号。**逻辑块号**转换为**物理块号**的过程<span style="color:#D91656">**不需要读磁盘操作**</span>。

**结论**：采用<span style="color:#3674B5">**链接分配（显式链接）**</span>方式的文件，支持顺序访问，也支持<span style="color:#3674B5">支持随机访问</span>（想访问 $i$ 号逻辑块时，并不需要一次访问之前的 $0 \sim i - 1$ 号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。

显然，显式链接也<span style="color:#B82132">不会产生外部碎片，也可以很方便地对文件进行拓展</span>。

---

- **优点**：很方便对文件拓展，不会有碎片问题，外存利用率高，并且<span style="color:#BE3144">支持随机访问</span>；相比于隐式链接来说，<span style="color:#344CB7">地址转换不需要访问磁盘，因此文件的访问效率更高</span>
- **缺点**：文件分配表的需要占用一定的存储空间

### 索引分配

<span style="color:#F93827">索引分配</span>允许文件离散地分配在各个磁盘块中，系统会为<span style="color:#F93827">**每个文件**</span>建立<span style="color:#F93827">**一张索引表**</span>，索引表中<span style="color:#F93827">记录了文件的各个逻辑块对应的物理块</span>（索引表的功能类似于内存管理中的页表——<span style="color:#074799">建立逻辑页面到物理页之间的映射关系</span>）。索引表存放的磁盘块称为<span style="color:#E16A54">**索引块**</span>，文件数据存放的磁盘块称为<span style="color:#E16A54">**数据块**</span>。

假设某个新创建的文件 **aaa** 的数据依次存放在 `2 -> 5 -> 13 -> 9`，7 号磁盘块作为 **aaa** 的索引块，索引块中保存了索引表的内容；类似的，文件 **bbb** 的索引表是 23 号磁盘块，其中存放了文件 **bbb** 的索引表。

目录中需要记录文件的索引块是几号磁盘块。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507021803.svg" style="zoom:67%;" />

> **注意**：
>
> 在显示链接的链式分配文件，文件分配表 FAT 是**一个磁盘**对应一张（以物理块号作为关键字）。而索引分配方式中，索引表是**一个文件**对应一张（以逻辑块号作为关键字）。

可以用固定的长度表示物理块号（例如，假设磁盘总容量为 $1 \text{TB} = 2^{40} \text{B}$，磁盘块大小为 1KB，则共有 $2^{30}$ 个磁盘块，则可用 4B 表示磁盘块号），因此，索引表中的**逻辑块号**可以是**隐含的**。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507021744.svg" style="zoom:67%;" />

**如何实现文件逻辑块号到物理块号的转换？**

用户给出要访问的逻辑块号 $i$，操作系统找到该文件对应的目录项（FCB）。

从<span style="color:#077A7D; font-weight:bold">目录项</span>中可知<span style="color:#077A7D">**索引表存放位置**</span>，将索引表从外存读入内存，并查找索引表即可知晓 $i$ 号逻辑块在外存中的存放位置。

可见，索引分配方式可以支持<span style="color:#E73879">**随机访问**</span>，文件拓展也很容易实现。（只需要给文件分配一个空闲块，并增加一个索引表项即可）

但是索引表需要占用**一定的存储空间**。

---

若每个磁盘块 1KB，一个索引表项 4B，则一个磁盘块只能存放 256 个索引项。**如果一个文件的大小超过了 256 块，那么一个磁盘块是装不下文件的整张*索引表*的，如何解决这个问题？**

1. <span style="color:#1F509A; font-weight:bold">链接方案</span>：如果索引表太大，一个索引块装不下，那么可以将**多个索引块**链接起来存放。

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507021813.svg" style="zoom:67%;" />

   若一个文件大小为 $256 \times 256 \text{KB} = 65536 \text{KB} = 64 \text{MB}$，该文件共有 $256 \times 256$ 个块，也就对应 $256 \times 256$ 个索引项，也就需要 256 个索引块存储，这些索引块用链接方式连起来。

   若想要访问文件的最后一个逻辑块，就必须找到最后一个索引块（第 256 个索引块），而各个索引块之间使用指针链接起来的，因此必须先顺序地读入前 255 个索引块，极为低效。

2. <span style="color:#1F509A; font-weight:bold">多层索引</span>：建立多层索引（<span style="color:#FF7F3E">**原理类似于多级页表**</span>）；使第一层索引块指向第二层的索引块；还可根据文件大小的要求再建立第三层、第四层索引块。
   
   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507021929.svg" style="zoom:67%;" />
   
   若某文件采用<span style="color:#3D3BF3">两层索引</span>，则该<span style="color:#3D3BF3">文件的最大长度</span>可以到 $256 \times 256 \times 1 \text{KB} = 65536 \text{KB} = 64 \text{MB}$。（因为若采用多层索引，则各层索引表大小不能<span style="color:#AA5486">超过一个磁盘块</span>）
   
   可根据逻辑块号算出应该查找索引表中的哪个表项。
   
   例如，要访问 1026 号逻辑块，则：
   $$
   \begin{matrix}
   \dfrac{1026}{256} &= 4 \\
   1026 \% 256 &= 2
   \end{matrix}
   $$
   因此可以先将一级索引表调入内存，查询 4 号表项，将其对应的二级索引表调入内存，再查询二级索引表的 2 号表项即可知道 1026 号逻辑块存放的磁盘块号了。访问目标数据块，<span style="color:#AE445A">需要 3 次磁盘 I/O</span>。
   
   若采用<span style="color:#FA4032">三层索引</span>，则<span style="color:#FA4032">文件的最大长度</span>为 $256 \times 256 \times 256 \times 1 \text{KB} = 16 \text{GB}$；类似的，访问目标数据块，<span style="color:#219B9D">需要 4 次磁盘 I/O</span>。
   
   因此有采用 K 层索引结构，且<span style="color:#133E87">顶级索引表未调入内存</span>，则访问一个数据块只需要 K + 1 次读磁盘操作。
   
   > **注意**：
   >
   > 若文件大小仅为磁盘块大小（即 1KB），此时面对小文件却依然需要 3 次磁盘 I/O，开销大。
   
3. <span style="color:#1F509A; font-weight:bold">混合索引</span>：多种索引方式的结合。例如，一个文件的顶级索引表中，既包含<span style="color:#0D92F4">直接地址索引</span>（直接指向<span style="color:#0D92F4">数据块</span>），又包含<span style="color:#0D92F4">一级间接索引</span>（指向单层索引表），还包含<span style="color:#0D92F4">两级间接索引</span>（指向两层索引表）。
   
   ![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507030148.svg)
   
   这种结构的索引支持的最大文件长度为 65800KB。
   
   若顶级索引表<span style="color:#F95454">还没读入内存</span>，有：
   
   - **访问 $0 \sim 7$ 号逻辑块**：两次读磁盘操作
   - **访问 $8 \sim 263$ 号逻辑块**：三次读磁盘操作
   - **访问 $264 \sim 65799$ 号逻辑块**：四次读磁盘操作

---

<span style="color:#006BFF">**索引分配**</span>允许文件离散地分配在各个磁盘块中，系统会为<span style="color:#006BFF">**每个文件**</span>建立<span style="color:#006BFF">**一张索引表**</span>，索引表中记录了文件的各个<span style="color:#006BFF">**逻辑块**</span>对应的<span style="color:#006BFF">**物理块**</span>（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为<span style="color:#006BFF">**索引块**</span>。文件数据存放的磁盘块称为<span style="color:#006BFF">**数据块**</span>。

若文件太大，索引表项太多，可以采取以下三种方法解决：

1. <span style="color:#FD8B51">**链接方案**</span>：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。

   <span style="color:#87A2FF">**缺点**</span>：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到 $i$ 号索引块，必须先依次读入 $0 \sim i - 1$ 号索引块，这就导致磁盘 I/O 次数过多，查找效率低下。

2. <span style="color:#FD8B51">**多层索引**</span>：建立多层索引（<span style="color:#D91656">原理类似于多级页表</span>），使第一层索引块指向第二层的索引块，还可根据文件大小的要求再建立第三层、第四层索引块。采用 K 层索引结构，且<span style="color:#D91656">顶级索引表未调入内存</span>，则访问个数据块只需要 $K + 1$ 次读磁盘操作。

   <span style="color:#87A2FF">**缺点**</span>：即使是小文件，访问一个数据块依然需要 $K + 1$ 次读磁盘。

3. <span style="color:#FD8B51">**混合索引**</span>：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含<span style="color:#D91656">直接地址索引</span>（直接指向数据块），又包含<span style="color:#D91656">一级间接索引</span>（指向单层索引表）、还包含<span style="color:#D91656">两级间接索引</span>（指向两层索引表）。

   <span style="color:#87A2FF">**优点**</span>：对于小文件来说，访问一个数据块所需的读磁盘次数更少。

---

<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>文件分配方式比较</title>
</head>
<body>
<table>
    <thead>
        <tr>
            <th colspan="2"></th>
            <th>How?</th>
            <th>目录项内容</th>
            <th>优点</th>
            <th>缺点</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" class="row-header">顺序分配</td>
            <td>为文件分配的必须是连续的磁盘块</td>
            <td>起始块号、文件长度</td>
            <td>顺序存取速度快, 支持随机访问</td>
            <td>会产生碎片，不利于文件拓展</td>
        </tr>
        <tr>
            <td rowspan="2" class="row-header">链接分配</td>
            <td class="row-header">隐式链接</td>
            <td>除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针</td>
            <td>起始块号、结束块号</td>
            <td>可解决碎片问题，外存利用率高，文件拓展实现方便</td>
            <td>只能顺序访问，不能随机访问</td>
        </tr>
        <tr>
            <td class="row-header">显式链接</td>
            <td>建立一张文件分配表（FAT），显式记录盘块的先后关系（开机后 FAT 常驻内存）</td>
            <td>起始块号</td>
            <td>除了拥有隐式链接的优点之外，还可以通过查询内存中的 FAT 实现随机访问</td>
            <td>FAT 需要占用一定的存储空间</td>
        </tr>
        <tr>
            <td colspan="2" class="row-header">索引分配</td>
            <td>为文件数据块建立索引表；若文件太大，可采用链接方案、多层索引、混合索引</td>
            <td>链接方案记录的是第一个索引块的块号，多层/混合索引记录的是顶级索引块的块号</td>
            <td>支持随机访问，易于实现文件的拓展</td>
            <td>索引表需占用一定的存储空间；访问数据块前需要先读入索引块；若采用链接方案，查找索引块时可能需要很多次读磁盘操作</td>
        </tr>
    </tbody>
</table>
</body>
</html>

## 逻辑结构 vs. 物理结构

**知识总览**：

![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507040134.svg)

![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507040135.svg)

### C 语言创建无结构文件

```c
FILE* fp = fopen("test.txt", "w");  // 打开文件
if (fp == NULL) {
    printf("打开文件失败！");
    exit(0);
}
// 写入 10000 个 Hello World!
for (int i = 0; i < 10000; ++i) {
    fputs("Hello World!", fp);      // 关闭文件
}
fclose(fp);
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250704024912300.png" alt="image-20250704024912300" style="zoom: 80%;" />

#### 逻辑结构（从用户视角看）

每个字符 1B，在用户看来，整个文件占用一片连续的逻辑地址空间。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507040254.svg" style="zoom:80%;" />

若想在文件中找到第 16 个字符（编号从 0 开始），可以：

```c
FILE* fp = fopen("test.txt", "r");  // 以“读”方式打开文件
if (fp == NULL) {
    puts("Fail to open file!");
    exit(0);
}
fseek(fp, 16, SEEK_SET);            // 读写指针指向 16
char c = fgetc(fp);                 // 从读写指针所指位置读出 1 个字符
printf("字符：%c", c);              // 打印从文件读出的字符
fclose(fp);                         // 关闭文件
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250704030530431.png" alt="image-20250704030530431" style="zoom: 50%;" />

用户使用**逻辑地址**访问文件。

#### 物理结构（从操作系统视角看）

从操作系统的视角来看，无结构文件是一堆二进制数据，每个磁盘块可以存储 1KB。该文件被操作系统拆分为若干块，逻辑块号相邻。操作系统会根据其文件管理的策略来将文件存入磁盘中。

若采用连续分配的方式，逻辑上相邻的块物理上也相邻。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507040323.svg" alt="image-202507040323" style="zoom:80%;" />

若采用链接分配的方式，逻辑上相邻的块在物理上用链接指针表示先后关系。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507040333.svg" style="zoom:80%;" />

若使用索引分配的方式，操作系统为每个文件维护一张索引表，其中记录了逻辑块号 → 物理块号的映射关系。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507040338.svg" style="zoom:80%;" />

对于用户而言，有：

- 使用 C 语言库函数 `fseek`，将文件读写指针指向位置 n（指明逻辑地址）
- 使用 C 语言库函数 `fgetc`，从读写指针所指位置读出 1B 内容（`fgetc` 底层使用了 `read` 系统调用，操作系统将 `(逻辑块号, 块内偏移)` 转换为 `(物理块号, 块内偏移)`）

### 用 C 语言创建顺序文件

```c
#include <stdio.h>
#include <stdlib.h>
#define N 10000

typedef struct {
    int number;     // 学号
    char name[30];  // 姓名
    char major[30]; // 专业
} StudentInfo;

int main(void) {
    FILE* fp = fopen("students.info", "w"); // 以“写”方式打开文件
    if (fp == NULL) {
        printf("打开文件失败！");
        exit(0);
    }
    StudentInfo student[N];       // 用数组保存 N 个学生的信息
    for (int i = 0; i < N; ++i) { // 生存 N 个学生的信息
        student[i].name[0] = '?';
        student[i].number = i;
        student[i].major[0] = '?';
    }

    // 将 N 个学生的信息写入文件
    fwrite(student, sizeof(StudentInfo), N, fp);
    fclose(fp);

    return 0;
}
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507041418.svg" style="zoom: 80%;" />

```c
// 以“读”方式打开文件
FILE* fp = fopen("student.info", "r");
if (fp == NULL) {
    printf("打开文件失败！");
    exit(0);
}

// 文件读写指针指向编号为 5 的学生记录
fseek(fp, 5 * sizeof(StudentInfo), SEEK_SET);
StudentInfo stu;
// 从文件中读出 1 条记录，记录大小为 sizeof(StudentInfo)
fread(&stu, sizeof(StudentInfo), 1, fp);
printf("学生编号：%d\n", stu.number);
fclose(fp);
```

类似的，存储这个文件也可以采用顺序分配、链式分配、索引分配等文件管理方式。

### 顺序文件采用顺序存储/链式存储

<span style="color:#00809D; font-weight:bold">顺序文件</span>：各个记录可以<span style="color:#F97A00">顺序存储</span>或<span style="color:#F97A00">链式存储</span>。

顺序存储时，各条记录相邻存放；支持随机访问，可以直接确定第 $i$ 条记录的逻辑地址。

```c
typedef struct {
    int number;     // 学号
    char name[30];  // 姓名
    char major[30]; // 专业
} StudentInfo;
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507041448.svg" style="zoom:80%;" />

链式存储，各条记录离散着存放，用指针表示先后关系。

```c
typedef struct {
    int number;      // 学号
    char name[30];   // 姓名
    char major[30];  // 专业
    int next;        // 下一个学生记录的存放位置
} StudentInfo;
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507041457.svg" style="zoom:80%;" />

> **注意**：上面的是<span style="color:#4300FF">从用户视角而言的逻辑结构</span>。

### 链式存储的顺序文件采用连续分配/链接分配

对于操作系统而言，其并不在意文件内部的<span style="color:#5459AC">**具体逻辑结构**</span>，直接将每个文件拆分为<span style="color:#BB3E00">各个逻辑块</span>。因此链式存储的文件也可以<span style="color:#D50B8B">顺序分配</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507061549.svg" style="zoom:80%;" />

类似的，也可以采用<span style="color:#E55050">链接分配</span>的方式。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507061553.svg" style="zoom:80%;" />

文件内部各条记录链式存储是由创建文件的用户自己设计的；文件整体用链接分配是由操作系统决定的。

### 逻辑结构——索引文件

```c
typedef struct {
    int number;  // 学号
    int addr;    // 学生记录的逻辑地址
} IndexTable;

typedef struct {
    char name[30];   // 姓名
    char major[30];  // 专业
    // 还可以添加其他各种各样的学生信息
} StudentInf存储空间的划分与初始化o;
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507041553.svg" style="zoom:80%;" />

<span style="color:#03A791; font-weight:bold">索引文件</span>：从<span style="color:#FF6363">**用户视角**</span>来看，整个文件依然是连续存放的；例如，前 1MB 存放索引项，后续部分存放记录。

- **索引文件**的索引表是用户自己建立的，映射关系是**关键字 → 记录存放的逻辑地址**
- **索引分配**的索引表是操作系统建立的，映射关系是**逻辑块号 → 物理块号**

---

![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507041615.png)

## 文件存储空间管理

**知识总览**：

![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507061523.svg)

文件的物理结构，也就是对<span style="color:#954C2E">**非空闲磁盘块**</span>的管理。

![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507061535.png)

对文件存储空间的管理，也就是对文件<span style="color:#7965C1">**空闲磁盘块**</span>的管理。

> **注意**：
>
> 1. 用什么方式记录、组织空闲块？
> 2. 如何分配磁盘块？
> 3. 如何回收磁盘块？

### 存储空间的划分与初始化

在安装 Windows 系统时，必经步骤是为磁盘分区（C 盘、D 盘、E 盘等）。

- <span style="color:#D50B8B; font-weight:bold">存储空间的划分</span>：将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）
- <span style="color:#D50B8B; font-weight:bold">存储空间的初始化</span>：将各个文件卷划分为目录区、文件区

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507061603.svg" style="zoom:80%;" />

**目录区**主要存放<span style="color:#309898">**文件目录信息（FCB）**</span>、<span style="color:#CB0404; font-weight:bold">用于磁盘存储空间管理的信息</span>；**文件区**用于存放<span style="color:#F4631E; font-weight:bold">文件数据</span>。

在部分支持超大型文件的系统中，可支持由多个物理磁盘组成一个文件卷。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507061609.svg" style="zoom:80%;" />

### 存储空间管理——空闲表法

在文件卷的目录区中管理着一个空闲块列表，根据算法的不同进行排序，其适用于文件的物理结构为**连续分配方式**。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507072127.svg" style="zoom:80%;" />

**如何分配磁盘块？**与内存管理中的动态分区分配很类似，为一个文件<span style="color:#27548A; font-weight:bold">分配连续的存储空间</span>。同样可采用<span style="color:#A53860; font-weight:bold">首次适应</span>、<span style="color:#A53860; font-weight:bold">最佳适应</span>、<span style="color:#A53860; font-weight:bold">最坏适应</span>等算法来决定为文件分配哪个区间。

假设新创建了一个文件请求 3 个块，采用首次适应算法，则有：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507072125.svg" style="zoom:80%;" />

**如何回收磁盘块？**与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况：

1. 回收区的前后都没有相邻空闲区
2. 回收区的前后都是空闲区
3. 回收区前面是空闲区
4. 回收区后面是空闲区

<span style="color:#BB3E00">**总之，回收时需要注意表项的合并问题。**</span>

以情况 2 举例，假设此时删除了某文件，系统回收了它占用的 15、16、17 号块。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507072118.svg" style="zoom:80%;" />

### 存储空间管理——空闲链表法

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507061722.svg" style="zoom:80%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507061750.svg" style="zoom:80%;" />

#### 空闲盘块链

操作系统保存着<span style="color:#D50B8B">链头、链尾指针</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507061751.svg" style="zoom:80%;" />

**如何分配？**若某文件申请 K 个磁盘块，则从链头开始依次摘下 K 个盘块分配，并修改空闲链的链头指针。

**如何回收？**回收的盘块依次挂到链尾，并修改空闲链的链尾指针。

该种方式适用于离散分配的物理结构，为文件分配多个盘块时可能要重复多次操作。

#### 空闲盘区链

操作系统保存着<span style="color:#D50B8B">链头、链尾指针</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507061807.svg" style="zoom:80%;" />

**如何分配？**若某文件申请 K 个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。

**如何回收？**若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为一个单独的一个空闲盘区挂到链尾。

该种方法对离散分配、连续分配都适用。相对于空闲盘块链，为一个文件分配多个盘块时，效率更高。

### 存储空间管理——位示图法

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507062326.svg" style="zoom:80%;" />

<span style="color:#8A2D3B; font-weight:bold">位示图</span>：每个二进制位对应一个盘块。在上述例子中，`0` 代表盘块空闲，`1` 代表盘块已分配。位示图一般用连续的**字**来表示，如上述例子中，一个字的字长是 16 位，字中的每一位对应一个盘块。因此可以用 `(字号, 位号)` <span style="color:#3A59D1; font-weight:bold">对应一个盘块号</span>，也可描述为 `(行号, 列号)`。

> **注意**：
>
> 要能推断出盘块号与 `(字号, 位号)` 相互转换的公式；要注意<span style="color:#8E7DBE">**盘块号**</span>、<span style="color:#8E7DBE; font-weight:bold">字位</span>、<span style="color:#8E7DBE; font-weight:bold">位号</span>是从 0 开始还是从 1 开始。

在上述例子中，<span style="color:#8E7DBE">**盘块号**</span>、<span style="color:#8E7DBE; font-weight:bold">字位</span>、<span style="color:#8E7DBE; font-weight:bold">位号</span>从 **0** 开始，若使用 n 来表示字长，则 `(字号, 位号) = (i, j)`  的二进制位对应的盘块号为：
$$
b = ni + j
$$
b 号盘块对应的<span style="color:#E83F25; font-weight:bold">字号 $i = \dfrac{b}{n}$，位号 $j = b \mod n$</span>。

**如何分配？**若文件需要 K 个块，则：

1. 顺序扫描位示图，找到 K 个相邻或不相邻的 `0` 
2. 根据字号、位号算出对应的盘块号，将对应盘块分配给文件
3. 将对应位设置为 `1`

**如何回收？**

1. 根据回收的盘块号计算出对应的字号、位号
2. 将相应二进制位设为 `0`

连续分配、离散分配都适用。

### 存储空间管理——成组链接法

空闲表法、空闲链接法不适用于大型文件系统，因为空闲表或空闲链表可能过大，前者占用大量内存空间，后者访问速度极慢；UNIX 系统中采用了<span style="color:#F7374F; font-weight:bold">成组链接法</span>对磁盘空闲块进行管理。

<span style="color:#27548A">**文件卷的目录区**</span>专门用一个磁盘块作为<span style="color:#007074; font-weight:bold">超级块</span>，当系统启动时需要将<span style="color:#007074; font-weight:bold">超级块读入内存</span>；并且要保证内存与外存中的<span style="color:#FE5D26; font-weight:bold">超级块</span>数据一致。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507062352.svg" style="zoom:80%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507071747.svg" style="zoom:80%;" />

**如何分配？**

举例，需要 1 个空闲块：

1. 检查第一个分组的块数是否足够；$1 < 100$，显然是足够的
2. 分配第一个分组中的 1 个空闲块，并修改相应的数据

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507071748.svg" style="zoom:80%;" />

若需要分配 100 个空闲块：

1. 检查第一个分组的块数是否足够；$100 = 100$ ，显然足够

2. 分配第一个分组中的 100 个空闲块；但是由于 300 号块内存放了再下一组的信息，因此 300 号块的数据需要复制到超级块中

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507071756.svg" style="zoom:80%;" />

**如何回收？**

假设每个分组最多为 100 个空闲块，此时第一个分组已有 99 个块，还要回收一块：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507071922.svg" style="zoom:80%;" />

假如回收的是 201 号块，有：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507071938.svg" style="zoom:80%;" />

若第一个分组已有 100 个块，还要再回收一块：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507071941.svg" style="zoom:80%;" />

需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507071951.svg" style="zoom:80%;" />

它就拥有了指向下一个分组的链接的指针：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507071953.svg" style="zoom:80%;" />

对超级块的数据进行修改，使其指向第一个分组：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507071959.svg" style="zoom:80%;" />



---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507072009.png" style="zoom:80%;" />

## 文件的基本操作

**知识总览**：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507080022.png" style="zoom: 45%;" />

### 创建文件

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250708002941361.png" alt="image-20250708002941361" style="zoom:80%;" />

进行上述操作后，可以<span style="color:#FF4F0F; font-weight:bold">创建文件</span>。（点击新建后，图形化交互进程在背后调用了 <span style="color:#B22222; font-weight:bold">`create` 系统调用</span>）

进行 `create` 系统调用时，需要提供的几个主要参数：

1. 所需的外存空闲大小（例如一个盘块，即 1KB）

2. 文件存放路径（`/home/leafevans/Demo`）

3. 文件名（此处默认为 `文本文件.txt`）

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250708003141238.png" alt="image-20250708003141238" style="zoom: 33%;" />

操作系统在处理 `create` 系统调用时，主要做了两件事：

1. 在<span style="color:#0D5EA6; font-weight:bold">外存</span>中找到文件<span style="color:#0D5EA6; font-weight:bold">所需的空间</span>
2. 根据文件存放路径的信息找到该目录对应的目录文件（此处为 `/home/leafevans/Demo` 目录），在目录中<span style="color:#AF3E3E; font-weight:bold">创建该文件对应的目录项</span>；目录项中包含了文件名、文件在外存中的存放位置等信息

### 删除文件

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250708003847219.png" alt="image-20250708003847219" style="zoom:80%;" />

进行上述操作后，可以<span style="color:#5F8B4C; font-weight:bold">删除文件</span>。（点了**删除**之后，图形化交互界面通过操作系统提供的<span style="color:#FE4F2D; font-weight:bold">删除文件</span>功能，即 <span style="color:#FE4F2D; font-weight:bold">`delete` 系统调用</span>，将文件数据从外存中删除）

进行 `delete` 系统调用时，需要提供的几个主要参数：

1. 文件存放路径（`/home/leafevans/Demo`）
2. 文件名（`文本文件.txt`）

操作系统在处理 `delete` 调用时，主要做了几件事：

1. 根据文件存放路径找到相应的目录文件，从目录中<span style="color:#B03052; font-weight:bold">找到文件名对应的目录项</span>
2. 根据该目录项记录的文件在外存的存放位置、文件大小等信息，<span style="color:#EFB036; font-weight:bold">回收文件占用的磁盘块</span>（回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）
3. 从目录表中<span style="color:#578E7E; font-weight:bold">删除文件对应的目录项</span>

### 打开文件

在很多操作系统中，对文件进行操作之前，要求用户先使用 `open` 系统调用**打开文件**，需要提供几个主要参数：

1. 文件存放路径（`/home/leafevans/Demo`）
2. 文件名（`文本文件.txt`）
3. 要对文件的操作类型（例如，`r` 只读、`rw` 读写等）

操作系统在处理 `open` 系统调用时，主要做了几件事：

1. 根据文件存放路径找到相应的目录文件，从目录中<span style="color:#AA5486; font-weight:bold">找到文件名对应的目录项</span>，并检查该用户是否有指定的操作权限
2. 将<span style="color:#859F3D; font-weight:bold">目录项</span>复制到<span style="color:#859F3D; font-weight:bold">内存</span>中的**打开文件表**中，并将对应表目的编号返回给用户；之后用户使用<span style="color:#800000; font-weight:bold">打开文件表的编号</span>来指明<span style="color:#257180; font-weight:bold">要操作的文件</span>（之后用户进程再操作文件就<span style="color:#667BC6; font-weight:bold">不需要每次都重新检查目录了</span>，这样可以加快文件的访问速度）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507080112.svg" style="zoom:80%;" />

有两种打开文件表：一种是系统打开文件表，整个系统只有一张，记录各个进程正在使用的文件的一些信息；另外，每个进程也有自己的打开文件表，该表同样也记录了一些信息，例如系统表索引号。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507080128.svg" style="zoom:80%;" />

> **注意**：
>
> 1. <span style="color:#CD5656">打开计数器</span>中记录了此时有多少个进程打开了此文件
> 2. <span style="color:#CD5656">读/写指针</span>记录了该进程对文件的读/写操作进行到的位置
> 3. 如果打开文件时声明的是<span style="color:#CD5656">只读</span>，则该进程不能对文件进行写操作

<span style="color:#E88D67">**系统打开文件表**</span>可以方便实现某些文件管理功能。例如，在 Windows 系统中，当我们尝试删除某个文本文件时，如果此时该文件已被某个**记事本**进程打开，系统会提示我们**暂时无法删除该文件**。其实系统在背后做的事就是先检查了系统打开文件表，确认此时是否有进程正在使用该文件。

### 关闭文件

进程使用完文件后，要<span style="color:#295F98">关闭文件</span>。

操作系统在处理 `close` 系统调用时，主要做了几件事：

1. 将进程的打开文件表相应表项删除
2. 回收分配给该文件的空闲内存等资源
3. 系统打开文件表的打开计数器 `count` 减 1，若 `count = 0`，则删除对应表项

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507081252.svg" style="zoom:80%;" />

### 读文件

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250708130608230.png" alt="image-20250708130608230" style="zoom:33%;" />

进行上述操作后，可以<span style="color:#C96868; font-weight:bold">读文件</span>，将文件数据读入内存，才能让 CPU 处理。（双击后，**记事本**应用程序通过操作系统提供的<span style="color:#295F98; font-weight:bold">读文件</span>功能，即 <span style="color:#295F98; font-weight:bold">`read` 系统调用</span>，将文件数据从外存读入内存，并显示在屏幕上）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507081305.svg" style="zoom:80%;" />

进程使用 `read` 系统调用完成写操作，需要指明是哪个文件（在支持<span style="color:#982B1C; font-weight:bold">打开文件</span>操作的系统中，只需要提供文件在打开文件表的索引号即可），还需要指明要读入多少数据（例如，读入 1KB）、指明读入的数据要放在内存中的什么位置。

操作系统在处理 `read` 系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户的内存区域中。

### 写文件

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250708130608230.png" alt="image-20250708130608230" style="zoom:33%;" />

在进行上述操作后，可以<span style="color:#536493; font-weight:bold">写文件</span>，将更改过的文件数据写回外存。（在**记事本**应用程序中编辑文件内容，点击<span style="color:#EF5A6F; font-weight:bold">保存</span>后，**记事本**应用程序通过操作系统提供的<span style="color:#667BC6">**写文件**</span>功能，即 <span style="color:#667BC6; font-weight:bold">`write` 系统调用</span>，将文件数据从内存写回外存）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507081305.svg" style="zoom:80%;" />

进程使用 `write` 系统调用完成写操作时，需要指明是哪个文件（在支持<span style="color:#3AA6B9; font-weight:bold">打开文件</span>操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要写出多少数据（例如，写出 1KB）、写回外存的数据放在内存中的什么位置。

操作系统在处理 `write` 系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507081328.png" style="zoom:80%;" />

> **注意**：
>
> - 打开文件时并不会将文件数据直接读入内存，**索引号**也称为<span style="color:#E50046; font-weight:bold">文件描述符</span>
> - **读/写文件**用**文件描述符**即可指明文件，不再需要用到**文件名**

## 文件共享

**知识总览**：

![](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507260646.svg)

操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一文件。

> **注意**：
>
> 多个用户共享同一个文件，意味着系统中只有<span style="color:#D92C54; font-weight:bold">一份</span>文件数据；并且只有某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。
>
> 如果是多个用户都<span style="color:#F97A00; font-weight:bold">复制</span>了同一个文件，那么系统中会有<span style="color:#799EFF; font-weight:bold">好几份</span>文件数据；其中一个用户修改了自己的那份数据，对其他用户的文件数据并没有影响。

### 基于索引节点的共享方式（硬链接）

<span style="color:#640D5F; font-weight:bold">索引结点</span>，是一种文件目录瘦身策略。由于检索文件只需要用到文件名，因此可将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507260720.svg" style="zoom:80%;" />

索引结点中设置一个链接计数变量 `count`，用于表示链接到本索引结点上的用户目录项数。

若 `count = 2`，则说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507260723.svg" style="zoom:80%;" />

若某个用户决定<span style="color:#34699A; font-weight:bold">删除</span>该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的 `count` 值减 1。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507260728.svg" style="zoom:80%;" />

若 `count > 0`，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。

当 `count = 0` 时，系统负责删除文件。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507260734.gif" style="zoom:80%;" />

### 基于符号链的共享方式（软链接）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507260740.svg" style="zoom:80%;" />

上图中，文件 2 是 Link 类型的文件，记录了文件 1 的存放地址（`C:/User1/aaa`，也可以是 `C:/User2/bbb`），类似于 Windows 操作系统中的<span style="color:#3D74B6; font-weight:bold">快捷方式</span>。

当 User3 访问 `ccc` 时，操作系统判断文件 `ccc` 属于 Link 类型文件，于是会根据其中记录的路径层层查找目录，最终找到 User1 的目录表中的 `aaa` 表项，于是找到了文件 1 的索引结点。

> **注意**：Link 类型的文件名可以不同。

双击打开后（例如桌面的快捷方式时），操作系统判断这个文件是 Link 类型的<span style="color:#9929EA">**快捷方式**</span>文件，于是会根据其中记录的<span style="color:#DC3C22">**路径信息**</span>检索目录，最终找到对应的文件。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507270215.svg" style="zoom:80%;" />

文件 1 已删除，但是文件 2 依然存在，只是通过 `C:/User1/aaa` 这个路径已经找不到文件 1 了。

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507272235.svg" alt="image-202507272235" style="zoom:80%;" />

## 文件保护

**知识总览**：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507280009.png" style="zoom: 50%;" />

保护文件数据的安全。

### 口令保护

为文件设置一个<span style="color:#B12C00; font-weight:bold">口令</span>（例如，`abc112233`），用户请求访问该文件时必须提供<span style="color:#B12C00; font-weight:bold">口令</span>。

> **注意**：
>
> 口令一般存放在文件对应的 FCB 或索引结点中；用户访问文件前需要先输入<span style="color:#B12C00">**口令**</span>，操作系统会将对用户提供的口令与 FCB 中存储的口令进行对比，若正确，则允许该用户访问文件。

- **优点**：保存口令的空间开销不多，验证口令的时间开销也很小
- **缺点**：正确的<span style="color:#EA5B6F">**口令**</span>存放在系统内部，不够安全

### 加密保护

使用某个<span style="color:#065084; font-weight:bold">密码</span>对文件进行加密，在访问文件时需要提供正确的<span style="color:#4A9782">**密码**</span>才能对文件进行正确的解密。

例如，一个最简单的加密算法——异或加密。

假设用于加密/解密的<span style="color:#9929EA; font-weight:bold">密码</span>为<span style="color:#9929EA; font-weight:bold"> 01001</span>，文件的原始数据为：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507280115.svg" style="zoom:80%;" />

加密密码为：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507280131.svg" style="zoom:80%;" />

加密结果为：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507280155.svg" style="zoom:80%;" />

解密密码同样为：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507280156.svg" style="zoom:80%;" />

解密结果为：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507280115.svg" style="zoom:80%;" />

> **注意**：加密密码和解密密码相同时，原始数据和解密结果是一样的。

- **优点**：保密性强，不需要在系统中存储<span style="color:#3D74B6">**密码**</span>
- **缺点**：编码/译码，或者说加密/解密要花费一定时间

### 访问控制

在每个文件的 FCB（或索引结点）中增加一个<span style="color:#9B177E;font-weight:bold">访问控制列表</span>（Access-Control List, ACL），该表中记录了各个用户可以对该文件执行哪些操作。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507280212.png" style="zoom: 67%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image0-202507280218.svg" style="zoom:80%;" />

> **注意**：
>
> 有的计算机可能会有很多个用户，因此访问控制列表可能会很大，可以用精简的访问控制列表解决这个问题。

精简的访问控制列表，以<span style="color:#8A0000; font-weight:bold">组</span>为单位，标记各<span style="color:#8A0000; font-weight:bold">组</span>用户可以对文件执行哪些操作；例如，分为系统管理员、文件主、文件主的伙伴、其他用户几个分组。

当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。

> **注意**：系统需要管理分组的信息。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507280229.svg" style="zoom:80%;" />

若想让某个用户能够读取文件，只需要把该用户放入<span style="color:#FF7D29; font-weight:bold">文件主的伙伴</span>这个分组即可。

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507280253.svg"  />

> **注意**：
>
> 如果对某个目录进行了访问权限的控制，那也要对目录下的所有文件进行相同的访问控制权限控制。

## 文件系统的层次结构

**知识总览**：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507280624.svg" style="zoom: 50%;" />

- **<span style="color:#E51400">用户接口</span>**：文件系统需要向上层的用户提供一些简单易用的功能接口；这层就是用于处理用户发出的系统调用请求（`read`、`write`、`open`、`close` 等系统调用）
- <span style="color:#FA6800; font-weight:bold">文件目录系统</span>：用户是通过文件路径来访问文件的，因此这一层需要根据用户给出的文件路径找到相应的 FCB 或索引结点；所有和目录、目录项相关的管理工作都在本层完成，如管理活跃的文件目录表、管理打开文件表等
- <span style="color:#F0A30A; font-weight:bold">存取控制模块</span>：为了保证文件数据的安全，还需要验证用户是否有访问权限；这一层主要完成了文件保护相关功能
- <span style="color:#60A917; font-weight:bold">逻辑文件系统与文件信息缓冲区</span>：用户指明想要访问文件记录号，这一层需要将记录号转换为对应的逻辑地址
- <span style="color:#1BA1E2; font-weight:bold">物理文件系统</span>：这一层需要把上一层提供的文件逻辑地址转换为实际的物理地址
- <span style="color:#0050EF; font-weight:bold">辅助分配模块</span>：负责文件存储空间的管理，即负责分配和回收存储空间
- <span style="color:#0050EF; font-weight:bold">设备管理模块</span>：直接与硬件交互，负责和硬件直接相关的一些管理工作；例如，分配设备、分配设备缓冲区、磁盘调度、启动设备、释放设备等

举例，假设某用户请求删除 `D:/工作目录/学生信息.xlsx` 的最后 100 条信息。

1. 用户需要通过操作系统提供的接口发出上述请求——**用户接口**
2. 由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项——**文件目录系统**
3. 不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——**存取控制模块（存取控制验证层）**
4. 验证了用户的访问权限之后，需要把用户提供的**记录号**转变成对应的逻辑地址——**逻辑文件系统与文件信息缓冲区**
5. 知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址——**物理文件系统**
6. 要删除这条记录，必定要对磁盘设备发出请求——**设备管理模块**
7. 删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收——**辅助分配模块**

## 文件系统的全局结构（布局）

### 文件系统在外存中的结构

#### 原始磁盘

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507290522.svg" style="zoom:80%;" />

#### 物理格式化

物理格式化（即低级格式化），划分扇区、检测坏扇区，并用备用扇区替换坏扇区。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507290521.svg" style="zoom:80%;" />

> **注意**：坏扇区对于操作系统来说是透明的，其意识不到坏扇区的存在。例如，操作系统访问编号为 n 的坏扇区时，磁盘驱动器会使用备用扇区来替代这个坏扇区。

#### 逻辑格式化

逻辑格式化后，磁盘分区（分卷 Volume），完成各分区的文件系统初始化。（逻辑格式化后，灰色部分就有实际数据了，白色部分还没有数据）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202507290546.svg" style="zoom: 80%;" />

> **注意**：
>
> - 超级块的作用更多的是找到空闲磁盘块
> - 位示图的作用则是判断一个磁盘块是否空闲
> - i 结点就是索引结点，所有的索引结点都连续存放在 i 结点区，可以类比为数组，便于迅速地确认指定的索引结点
> - 任何一个文件系统都要从根目录出发，来建立新的下一层的目录或存储新的文件

### 文件系统在内存中的结构

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202508010917.svg" style="zoom:80%;" />

> **注意**：近期访问过的目录文件会缓存在内存中，不用每次都从磁盘读入，这样可以加快目录检索速度。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202508010901.svg" style="zoom:80%;" />

## 虚拟文件系统 & 文件系统挂载（安装）

### 普通文件系统

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202508010935.svg" style="zoom:80%;" />

各个不同的文件系统提供给上层不同的调用格式，对于上层的用户不适，用户需要根据文件存储位置来确定调用格式。

### 虚拟文件系统

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202508020300.svg" style="zoom:80%;" />

虚拟文件系统的特点：

1. 向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异
2. VFS 要求下层的文件系统必须实现某些规定的函数功能，如 `open`、`read`、`write`；一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统 VFS 的要求

现在存在一个问题，不同的文件系统，表示文件数据结构各不相同。打开文件后，其在内存中的表示就不同。因此有：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202508020318.svg" style="zoom:80%;" />

3. 每打开一个文件，VFS 就在主存中新建一个 vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统

> **注意**：vnode 只存在于主存中，而 inode 既会被调入主存，也会在外存中存储。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202508020334.svg" style="zoom:50%;" />

打开文件后，创建 vnode，并将文件信息复制到 vnode 中，vnode 的功能指针指向具体文件系统的函数功能。

### 文件系统挂载（mounting）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202508020300.svg" style="zoom:80%;" />

文件系统挂载（mounting），即文件系统安装/装载——如何将一个文件系统挂载到操作系统中？

文件系统挂载要做的事：

1. 在 VFS 中注册新挂载的文件系统；<span style="color:#239BA7">内存中的挂载表</span>（mount table）包含每个文件系统的相关信息，包含文件系统类型、容量大小等
2. 新挂载的文件系统，要向 VFS 提供一个<span style="color:#239BA7">函数地址列表</span>
3. 将新文件系统加到<span style="color:#239BA7">挂载点</span>（mount point），也就是将新文件系统挂载到某个父目录下

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250802035132209.png" alt="image-20250802035132209" style="zoom:50%;" />

