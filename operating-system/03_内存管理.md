# 内存管理

## 内存的基础知识

**知识总览**：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506161345.png" style="zoom:50%;" />

### 内存的定义与作用

内存可存放数据。程序执行前<span style="color:#03A6A1;font-weight:bold">需要先放到内存中才能被 CPU 处理</span>——缓和 CPU 与硬盘之间的速度矛盾。

在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250616_135704.png" style="zoom: 33%;" />

解决方法就是给内存的存储单元编码地址。与酒店类似，内存中也有一个个的**小房间**，每个小房间就是一个<span style="color:#FF4F0F">**存储单元**</span>。

内存地址从 0 开始，<span style="color:#4300FF">**每个地址对应一个存储单元**</span>；如果计算机<span style="color:#4300FF">**按字节编址**</span>，则<span style="color:#4300FF">每个存储单元大小</span>为<span style="color:#4300FF"> 1 字节</span>，即 1B，即 8 个二进制位。

如果<span style="color:#D70654">字长为 16 位</span>的计算机<span style="color:#D70654;font-weight:bold">按字编址</span>，则<span style="color:#D70654">每个存储单元大小</span>为<span style="color:#D70654"> 1 个字</span>；每个字的大小为 16 个二进制位。

> **注意**：
> $$
> 2^{10} = 1 \text{K} \\
> 2^{20} = 1 \text{M} \\
> 2^{30} = 1 \text{G}
> $$
> 例如 4GB 指的是该内存可以存放 $4 \times 2^{30}$ 个字节。如果是按字节编址的话，也就是有 $4 \times 2^{30} = 2^{32}$ 个**小房间**。
>
> 如此多**小房间**，需要 $2^{32}$ 个地址才能一一标识，所以地址需要用 32 个二进制位来表示（$0 \sim 2^{32} - 1$）。

### 指令的工作原理

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616144304391.png" alt="image-20250616144304391" style="zoom: 33%;" />

某个寄存器，其地址为 00000011(3)。（有的系统中，寄存器和内存可能统一编址）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616144433501.png" alt="image-20250616144433501" style="zoom:50%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616144743482.png" alt="image-20250616144743482" style="zoom: 33%;" />

上述数据传送指令就是将地址为 01001111(79) 的数据传送到 00000011(3) 对应地址的内存单元，执行完后，00000011(3) 中就会有 10 这个数据。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616144940573.png" alt="image-20250616144940573" style="zoom:33%;" />

上述加法指令代表将地址为 00000011(3) 的数据加上 00000001(1)。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616150151174.png" alt="image-20250616150151174" style="zoom: 33%;" />

拥有和第一个指令同样的操作码，说明也是数据传送指令。将地址为 00000011(3) 的数据传送回 01001111(79) 地址的内存单元处。

---

指令的工作基于**地址**，每个地址对应一个数据的存储单元。

可见，我们写的代码要翻译成 CPU 能识别的指令。这些指令会告诉 CPU 应该去内存的哪个地址读/写数据，这个数据应该做什么样的处理。在这个例子中，我们默认<span style="color:#FF0000">让这个进程的相关内容从地址 0 开始连续存放</span>，指令中的地址参数直接给出了变量 `x` 的实际存放地址（<span style="color:#FF0000">物理地址</span>）。

**如果这个进程不是从地址 0 开始存放的，会影响指令的正常执行吗？**

下面是物理地址从 0 开始的情况：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250616_151827.png" style="zoom:50%;" />

下面是物理地址不是从 0 开始的情况，可以看到程序中是逻辑地址，而装入时的物理地址是要重新计算的：
<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250616_152231.png" style="zoom:50%;" />

### 装入的三种方式——绝对装入

<span style="color:#CA7842;font-weight:bold">绝对装入</span>：在编译时，如果知道程序将放到内存中的哪个位置，编译程序<u>*将产生**绝对地址**的目标代码*</u>，装入程序按照装入模块中的地址，将程序和数据装入内存。

例如知晓装入模块要从地址 100 的地方开始存放：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250616_153415.png" style="zoom:50%;" />

绝对装入方式灵活性较差，**仅适用于单道程序环境**。需要注意的是，一个可执行程序在某台电脑上能够正常运行，并不意味着它在其他电脑上也能顺利执行。

### 装入的三种方式——可重定位装入

<span style="color:#FF6500">**静态重定位**</span>：又称<span style="color:#3674B5">可重定位装入</span>。编译、链接后的装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。*装入时对地址进行<span style="color:#3674B5">**重定位**</span>*，<u>将逻辑地址变换为物理地址</u>。（地址变换是在**装入时一次完成的**）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250616_160036.png" style="zoom:50%;" />

静态重定位的特点是在一个作业装入内存时，<span style="color:#2D4F2B">**必须分配其要求的<u>*全部内存空间*</u>**</span>，如果没有足够的内存，就不能装入该作业。

作业一旦进入内存后，<span style="color:#2D4F2B;font-weight:bold">在运行期间就不能再移动</span>，也不能*<u>**再申请内存空间**</u>*。

### 装入的三种方式——动态运行时装入

<span style="color:#725CAD">**动态重定位**</span>：又称<span style="color:#AE445A">动态运行时装入</span>。编译、链接后的装入模块的地址都是从 0 开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是<span style="color:#AE445A">把地址转换**推迟**到程序真正要执行时才进行</span>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<span style="color:#AE445A">**重定位寄存器**</span>的支持。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250616_161426.png" style="zoom: 33%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616162747160.png" alt="image-20250616162747160" style="zoom: 33%;" />

采用动态重定位时，<span style="color:#F564A9">允许程序在内存中**发生移动**</span>。

并且可将程序分配到不连续的存储区中；在程序运行前只需<u>*装入它的部分代码即可投入运行*</u>，然后在程序运行期间，根据需要动态申请分配内存：便于<u>程序段的共享</u>，可以向用户提供更灵活的存储空间，提供一个比实际存储空间大得多的**虚拟地址空间**。

### 从写程序到程序运行

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616163511094.png" alt="image-20250616163511094" style="zoom:33%;" />

- **编译**：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言<span style="color:#CB0404">翻译为机器语言</span>）
- **链接**：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块
- **装入（装载）**：由装入程序将装入模块装入内存运行

### 链接的三种方式

1. **静态链接**：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个*<u>完整的可执行文件</u>*（装入模块），之后不再拆开

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616163802856.png" alt="image-20250616163802856" style="zoom: 33%;" />

2. **装入时动态链接**：将各目标模块装入内存时，<u>边装入边链接</u>的链接方式

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616163957605.png" alt="image-20250616163957605" style="zoom:33%;" />
   
3. **运行时动态链接**：在程序执行中<u>*需要该目标模块时，才对它进行链接*</u>；其优点是便于修改和更新，便于<u>*实现对目标模块的共享*</u>

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616164359748.png" alt="image-20250616164359748" style="zoom:33%;" />

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506162256.png" style="zoom:33%;" />

## 内存管理的概念

**知识总览**：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506162258.png" style="zoom:33%;" />

操作系统作为系统资源的管理者，当然也需要对内存进行管理。

### 内存的分配与回收

操作系统负责***内存空间的分配与回收***。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250616_230324.png" style="zoom:33%;" />

### 内存空间的扩充

操作系统需要提供某种技术（虚拟技术，操作系统的虚拟性）从逻辑上***对内存空间进行补充***。

例如游戏《侠盗猎车手》的大小超过 60GB，按理来说这个游戏程序运行之前需要把 60GB 数据全部放入内存。然而，实际我的电脑内存才 4GB，但为什么这个游戏可以顺利运行呢？

<img src="https://media-rockstargames-com.akamaized.net/mfe6/prod/__common/images/c58634497a6a6169b767.jpg" alt="img" style="zoom:33%;" />

### 地址转换

操作系统需要提供***地址转换功能***，负责程序的<span style="color:#4D3C77">**逻辑地址**</span>与<span style="color:#4D3C77">**物理地址**</span>的转换。（使用前面提到的三种方式，即<u>绝对装入、可重定向装入以及动态运行时装入</u>）

为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<span style="color:#994D1C">逻辑地址到物理地址的转换</span>（这个过程称为<span style="color:#994D1C">**地址重定位**</span>）应该*由操作系统负责*，这样就保证了程序员写程序时不需要关注物理内存的实际情况。

### 内存保护

操作系统需要提供***内存保护***功能。保证各进程在各自存储空间内运行，互不干扰。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616231654197.png" alt="image-20250616231654197" style="zoom:50%;" />

1. 在 CPU 中<span style="color:#D14D72">设置一对上、下限寄存器</span>，存放进程的上、下限地址；进程的指令要访问某个地址时，CPU 检查是否越界

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616231853191.png" alt="image-20250616231853191" style="zoom: 33%;" />

2. 采用<span style="color:#DC2525">重定位寄存器</span>（又称<span style="color:#DC2525">基址寄存器</span>）和<span style="color:#DC2525">界地址寄存器</span>（又称<span style="color:#DC2525">限长寄存器</span>）进行越界检查；重定位寄存器中存放的是进程的<span style="color:#DC2525">起始物理地址</span>；界地址寄存器中存放的是进程的<span style="color:#DC2525">最大逻辑地址</span>

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250616_233125.png" style="zoom:33%;" />

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506162337.png" style="zoom:33%;" />

## 进程的内存映像

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250617_011352.png" style="zoom:50%;" />

> **注意**：宏定义的常量不专门分配存储空间，在预编译阶段，会将代码中的 `X` 替换为 1024。

## 覆盖与交换

**知识总览**：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506170301.png" style="zoom: 46%;" />

### 覆盖技术

早期的计算机内存很小，比如 IBM 推出的第一台 PC 机最大只支持 1MB 大小的内存。因此经常会出现内存大小不够的情况。

后来人们引进了<span style="color:#F14A00">覆盖技术</span>，用来<span style="color:#F14A00">解决**程序大小超过物理内存总和**的问题</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617030713156.png" alt="image-20250617030713156" style="zoom:33%;" />

**覆盖技术的思想**：将<span style="color:#5409DA">**程序**分为多个段</span>（多个模块），常用的段常驻内存，不常用的段在需要时调入内存。

内存中分为<span style="color:#5409DA">一个**固定区**</span>和<span style="color:#5409DA">若干个**覆盖区**</span>。

需要常驻内存的段放在<span style="color:#5409DA">**固定区**</span>中，<span style="color:#5409DA">调入后就<u>不再调出</u></span>（除非运行结束）；不常用的段放在<span style="color:#5409DA">**覆盖区**</span>，<span style="color:#5409DA">需要用到时调入内存，用不到时调出内存</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617031303677.png" alt="image-20250617031303677" style="zoom:40%;" />

按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一覆盖区。

<span style="color:#3D90D7">必须由程序员**声明覆盖结构**</span>，操作系统完成自动覆盖。<span style="color:#3D90D7;font-weight:bold">但是对用户不透明</span>，增加了用户编程负担。

### 交换技术

**交换（对换）技术的设计思想**：内存空间紧张时，系统将内存中某些进程时<span style="color:#3D8D7A">**换出**</span>外存，把外存中某些<u>已具备运行条件</u>的进程<span style="color:#3D8D7A">**换入**</span>内存。（进程在<u>内存与磁盘间***动态调度***</u>）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617032112189.png" alt="image-20250617032112189" style="zoom:40%;" />

<span style="color:#DD88CF">**中级调度（内存调度）**</span>，就是要决定将哪个处于挂起状态的进程重新调入内存。

暂时换出外存等待的进程状态为<span style="color:#6A9C89">挂起状态（挂起态，suspend）</span>，挂起态又可以细分为<span style="color:#36C2CE">就绪挂起、阻塞挂起</span>两种状态。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617112256271.png" alt="image-20250617112256271" style="zoom:40%;" />

应该在外存（磁盘）的什么位置保存被换出的进程？

具有对换功能的操作系统中，通常把磁盘空间分为<span style="color:#03A791">**文件区**</span>和<span style="color:#03A791">**对换区**</span>两部分。

<span style="color:#03A791">**文件区**</span>主要用于存放文件，<span style="color:#03A791">主要追求存储空间的**利用率**</span>，因此对文件区空间的管理<span style="color:#03A791">采用**离散分配方式**</span>。

<span style="color:#03A791">**对换区**</span>空间只占磁盘空间的小部分，<span style="color:#03A791">被换出的进程数据就存放在对换区</span>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理<span style="color:#03A791">主要追求**换入换出速度**</span>，因此通常对换区<span style="color:#03A791">采用**连续分配方式**</span>。

总之，<span style="color:#03A791">对换区的 **I/O 速度**比文件区的更快</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617123431432.png" alt="image-20250617123431432" style="zoom:33%;" />

何时进行交换？

交换通常在**许多进程运行且内存吃紧**时进行，而**系统负荷降低**就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。

应该换出什么进程呢？

可优先换出**阻塞进程**；可换出**优先级低的进程**；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在**内存的驻留时间**。

> **注意**：<span style="color:#FF6363">PCB 会常驻内存</span>，不会被换出外存。

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506171317.png" style="zoom:50%;" />



## 连续分配管理方式

**知识总览**：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506171352.png" style="zoom:45%;" />

<span style="color:#60B5FF">**连续分配**</span>：指为用户进程分配的必须是一个<span style="color:#60B5FF">连续的内存空间</span>。

### 单一连续分配

在单一连续分配方式中，内存被分为<span style="color:#3F7D58">**系统区**</span>和<span style="color:#3F7D58">**用户区**</span>。

- 系统区通常位于内存的低地址部分，用于存放操作系统相关数据
- 用户区用于存放用户进程相关数据。

使用该种分配方式，内存中<span style="color:#3F7D58">**只能有一道用户程序**</span>，用户程序<u>独占</u>整个用户区空间。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617140052000.png" alt="image-20250617140052000" style="zoom:33%;" />

- <span style="color:#37AFE1">**优点**</span>：实现简单；<span style="color:#F09319">无外部碎片</span>；可以采用覆盖技术扩充内存；不一定需要采取内存保护（例如早期的 PC 操作系统 MS-DOS，不过有些系统也会采用越界检查的机制）
- <span style="color:#37AFE1">**缺点**</span>：只能用于单用户、单任务的操作系统中，<span style="color:#F95454">有**内部碎片**</span>（分配给某进程的内存区域中，如果有些部分没有用上，就是**内部碎片**），存储器利用率极低

### 固定分区分配

20 世纪 60 年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个<span style="color:#FFAF00">用户空间</span>划分为<span style="color:#FFAF00">若干个**固定大小**的分区</span>，在<span style="color:#FFAF00">每个分区中只装入一道作业</span>，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506171412.png" style="zoom:45%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617141729400.png" alt="image-20250617141729400" style="zoom:33%;" />

- <span style="color:#36BA98">**分区大小相等**</span>：缺乏灵活性，但是很<span style="color:#E76F51">适合用于用一台计算机控制**多个相同对象**的场合</span>（比如，钢铁厂有 n 个相同的炼钢炉，就可把内存分为 n 个大小相等的区域存放 n 个炼钢炉控制程序）
- <span style="color:#36BA98">**分区大小不等**</span>：增加了灵活性，可以满足不同大小的进程需求；根据常在系统中运行的作业大小情况进行划分（比如，划分多个小分区、适量中等分区、少量大分区）

操作系统需要建立一个数据结构——<span style="color:#219C90">**分区说明表**</span>，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的<span style="color:#219C90">大小、起始地址、状态</span>（是否已分配）。

| 分区号 | 大小（MB） | 起始地址（M） |  状态  |
| :----: | :--------: | :-----------: | :----: |
|   1    |     2      |       8       | 未分配 |
|   2    |     2      |      10       | 未分配 |
|   3    |     4      |      12       | 已分配 |
|   ……   |     ……     |      ……       |   ……   |

可以使用数据结构中的数组（或链表）来表示这个表。

当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为**已分配**。

- **优点**：实现简单，<span style="color:#06D001">无外部碎片</span>
- **缺点**：
  1. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能
  2. <span style="color:#06D001">会产生内部碎片</span>，内存利用率低

### 动态分区分配

<span style="color:#FF6500">动态分区分配</span>又称为<span style="color:#FF6500">可变分区分配</span>。这种分配方式<span style="color:#FF6500">不会**预先**划分内存分区</span>，而是在进程装入内存时，<span style="color:#FF6500">根据进程的大小**动态地建立分区**</span>，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（例如，假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56MB）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617144013648.png" alt="image-20250617144013648" style="zoom:33%;" />

系统要用什么样的数据结构来记录内存的使用情况呢？

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506171503.png" style="zoom:33%;" />

- **空闲分区表**：每个空闲分区对应个表项；表项中包含分区号、分区大小、分区起始地址等信息

  | 分区号 | 分区大小（MB） | 起始地址（M） | 状态 |
  | :----: | :------------: | :-----------: | :--: |
  |   1    |       20       |       8       | 空闲 |
  |   2    |       10       |      32       | 空闲 |
  |   3    |       4        |      60       | 空闲 |

- **空闲分区链**：每个分区的起始部分和末尾部分分别设置前向指针和后向指针，起始部分处还可记录分区大小等信息

  <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617150640991.png" alt="image-20250617150640991" style="zoom:50%;" />

当有很多空闲分区都可以满足需求时，应该选择哪个分区进行分配？

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617150810840.png" alt="image-20250617150810840" style="zoom: 33%;" />

把一个新作业装入内存时，须按照一定的<span style="color:#E72929">动态分区分配算法</span>，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。

如何进行分区的分配与回收操作？假设系统采用的数据结构是**空闲分区表**，*如何回收*？

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617172026082.png" alt="image-20250617172026082" style="zoom:33%;" />

| 分区号 | 分区大小（MB） | 起始地址（M） | 状态 |
| :----: | :------------: | :-----------: | :--: |
|   1    |       20       |       8       | 空闲 |
|   2    |       10       |      32       | 空闲 |
|   3    |       4        |      60       | 空闲 |

进行如下分配：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617151248659.png" alt="image-20250617151248659" style="zoom:33%;" />

分配后，空闲分区表为：

| 分区号 |          分区大小（MB）           |           起始地址（M）           | 状态 |
| :----: | :-------------------------------: | :-------------------------------: | :--: |
|   1    | <span style="color:red">16</span> | <span style="color:red">12</span> | 空闲 |
|   2    |                10                 |                32                 | 空闲 |
|   3    |                 4                 |                60                 | 空闲 |

类似的，若进行下面的分配：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617151458694.png" alt="image-20250617151458694" style="zoom:33%;" />

分配后，申请的内存大小与空闲分区大小恰好相等，将表项删除（空闲分区链就是将对应的节点删除）：

| 分区号 | 分区大小（MB） | 起始地址（M） | 状态 |
| :----: | :------------: | :-----------: | :--: |
|   1    |       20       |       8       | 空闲 |
|   2    |       10       |      32       | 空闲 |

---

回收时，有以下几种情况：

1. 回收区的后面有一个相邻的空闲分区：

   | 分区号 | 分区大小（MB） | 起始地址（M） | 状态 |
   | :----: | :------------: | :-----------: | :--: |
   |   1    |       10       |      32       | 空闲 |
   |   2    |       4        |      60       | 空闲 |

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617152011079.png" alt="image-20250617152011079" style="zoom:33%;" />

   对进程 4 进行回收后，有：

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617152128467.png" alt="image-20250617152128467" style="zoom:33%;" />

   | 分区号 |          分区大小（MB）           |           起始地址（M）           | 状态 |
   | :----: | :-------------------------------: | :-------------------------------: | :--: |
   |   1    | <span style="color:red">14</span> | <span style="color:red">28</span> | 空闲 |
   |   2    |                 4                 |                60                 | 空闲 |

   两个相邻的空闲分区合并为一个。

2. 回收区的前面有一个相邻的空闲分区：

   | 分区号 | 分区大小（MB） | 起始地址（M） | 状态 |
   | :----: | :------------: | :-----------: | :--: |
   |   1    |       20       |       8       | 空闲 |
   |   2    |       10       |      32       | 空闲 |

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617152455853.png" alt="image-20250617152455853" style="zoom:33%;" />

   对进程 3 进行回收后，有：

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617152841748.png" alt="image-20250617152841748" style="zoom:33%;" />

   | 分区号 |          分区大小（MB）           | 起始地址（M） | 状态 |
   | :----: | :-------------------------------: | :-----------: | :--: |
   |   1    |                20                 |       8       | 空闲 |
   |   2    | <span style="color:red">28</span> |      32       | 空闲 |

   两个相邻的空闲分区合并为一个。

3. 回收区的前、后各有一个相邻的空闲分区：

   | 分区号 | 分区大小（MB） | 起始地址（M） | 状态 |
   | :----: | :------------: | :-----------: | :--: |
   |   1    |       20       |       8       | 空闲 |
   |   2    |       10       |      32       | 空闲 |
   |   3    |       4        |      60       | 空闲 |

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617153308598.png" alt="image-20250617153308598" style="zoom:33%;" />

   将进程 4 的空间进行回收后，有：

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617153425845.png" alt="image-20250617153425845" style="zoom:33%;" />

   | 分区号 |          分区大小（MB）           |          起始地址（M）           | 状态 |
   | :----: | :-------------------------------: | :------------------------------: | :--: |
   |   1    | <span style="color:red">34</span> | <span style="color:red">8</span> | 空闲 |
   |   2    |                 4                 |                60                | 空闲 |

   三个相邻的空闲分区合并为一个。

4. 回收区的前、后都没有相邻的空闲分区：

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617153646010.png" alt="image-20250617153646010" style="zoom:33%;" />

   | 分区号 | 分区大小（MB） | 起始地址（M） | 状态 |
   | :----: | :------------: | :-----------: | :--: |
   |   1    |       4        |      60       | 空闲 |

   当进程 2 的内存空间被回收以后，有：

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617153824932.png" alt="image-20250617153824932" style="zoom:33%;" />

   |              分区号              |          分区大小（MB）           |           起始地址（M）           |                状态                 |
   | :------------------------------: | :-------------------------------: | :-------------------------------: | :---------------------------------: |
   | <span style="color:red">1</span> | <span style="color:red">14</span> | <span style="color:red">28</span> | <span style="color:red">空闲</span> |
   |                2                 |                 4                 |                60                 |                空闲                 |

   新增一个表项。

   > **注意**：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。

总结，相邻的空闲区间是要合并的。

---

动态分区分配<span style="color:#E178C5">没有内部碎片</span>，但是<span style="color:#E178C5">有外部碎片</span>。

- <span style="color:#E178C5">**内部碎片**</span>：分配给某进程的内存区域中，如果有些部分没有用上
- <span style="color:#E178C5">**外部碎片**</span>：内存中的某些空闲分区<u>由于太小</u>而难以利用

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617155047706.png" alt="image-20250617155047706" style="zoom:33%;" />

如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些**碎片**不能满足进程的需求。

可以采用<span style="color:#89B9AD">**紧凑（拼凑，Compaction）**</span>技术来解决外部碎片。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250617155632393.png" alt="image-20250617155632393" style="zoom:33%;" />

动态分区分配应该使用*<u>**动态重定位**</u>*的技术，便于实现以上操作。紧凑之后，要将各个进程的起始地址进行修改，进程的起始地址这个信息一般存在进程对应的 PCB 中。当进程上 CPU 运行之前，要将进程的起始地址放在重定位寄存器（基址寄存器）中。

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506171607.png" style="zoom: 50%;" />

## 动态分区分配算法

**知识总览**：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506171756.png" style="zoom: 48%;" />

### 首次适应算法

- <span style="color:#DA498D">**算法思想**</span>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区
- <span style="color:#DA498D">**如何实现**</span>：<span style="color:#E16A54">空闲分区以***地址递增***的次序排列</span>，每次分配内存时顺序查找<span style="color:#E16A54">空闲分区链</span>（或<span style="color:#E16A54">空闲分区表</span>），找到大小能满足要求的第一个空闲分区

### 最佳适应算法

- <span style="color:#E4003A">**算法思想**</span>：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当**大进程**到来时能有*<u>连续的大片空间</u>*，可以尽可能多地留下大片的空闲区，即，优先使用<u>*更小的空闲区*</u>
- <span style="color:#E4003A">**如何实现**</span>：<span style="color:#E16A54">空闲分区以***容量递增***的次序排列</span>，每次分配内存时顺序查找<span style="color:#E16A54">空闲分区链</span>（或<span style="color:#E16A54">空闲分区表</span>），找到大小能满足要求的第一个空闲分区
- <span style="color:#E4003A">**缺点**</span>：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块，因此该方法会产生很多的外部碎片

> **注意**：在分配完后，要对空闲分区表或空闲分区链的<u>排序</u>和信息进行更新。

### 最坏适应算法

又称为<span style="color:#2A629A">**最大适应算法**</span>（Largest Fit）。

- <span style="color:#2A629A">**算法思想**</span>：为了解决最佳适应算法的问题——即留下太多难以利用的*<u>**小碎片**</u>*，可以在每次分配时优先使用***<u>最大的连续空闲区</u>***，这样分配后剩余的空闲区就不会太小，更方便使用
- <span style="color:#2A629A">**如何实现**</span>：<span style="color:#E16A54">空闲分区以***容量递减***的次序排列</span>，每次分配内存时顺序查找<span style="color:#E16A54">空闲分区链</span>（或<span style="color:#E16A54">空闲分区表</span>），找到大小能满足要求的第一个空闲分区
- <span style="color:#2A629A">**缺点**</span>：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大、更可用，但是这种方式会导致较大的连续空闲区被迅速用完；如果之后有**大进程**到达，就没有内存分区可用了

### 邻近适应算法

- <span style="color:#756AB6">**算法思想**</span>：首次适应算法每次都从链头开始查找的；这可能会导致*<u>**低地址部分**</u>*出现很多***<u>小的空闲分区</u>***，而每次分配查找时，都要经过这些分区，因此也增加了**查找的开销**；如果每次都从上次查找结束的位置开始检索，就能解决上述问题
- <span style="color:#756AB6">**如何实现**</span>：空闲分区以地址递增的顺序排列（可排成一个循环链表）；每次分配内存时<span style="color:#F6635C">从上次查找结束的位置开始</span>查找<span style="color:#F6635C">空闲分区链</span>（或<span style="color:#F6635C">空闲分区表</span>），找到大小能满足要求的第一个空闲分区
- <span style="color:#756AB6">**缺点**</span>：
  1. 首次适应算法每次都要从头查找，每次都需要检索低地址的小分区但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有**<u>可能用到低地址部分的小分区</u>**，也会更有可能把**<u>高地址部分的大分区</u>**保留下来（最佳适应算法的优点）
  2. 邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区<u>*都有相同的概率被使用*</u>，也就导致了高地址部分的<u>*大分区更可能被使用，划分为小分区*</u>，最后导致**无大分区可用**（最大适应算法的缺点）

> **注意**：邻近适应算法和首次适应算法相较于最佳适应算法和最坏适应算法的优点在于它们是按照地址顺序进行排序，无需对空闲分区链和空闲分区表进行位置上的改动。

综合来看，<span style="color:#C23373">四种算法中，首次适应算法的效果反而更好</span>。

---

| 算法     | 算法思想                                           | 分区排列顺序                                   | 优点                                                         | 缺点                                                         |
| -------- | -------------------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 首次适应 | 从头到尾找适合的分区                               | 空闲分区以地址递增次序排列                     | 综合看性能最好。***算法开销小***，回收分区后一般不需要对空闲分区队列重新排序 |                                                              |
| 最佳适应 | 优先使用更小的分区，以保留更多大分区               | 空闲分区以容量递增次序排列                     | 会有更多的大分区被保留下来，更能满足大进程需求               | 会产生很多太小的、难以利用的碎片；***算法开销大***，回收分区后可能需要对空闲分区队列重新排序 |
| 最坏适应 | 优先使用更大的分区，以防止产生太小的不可用的碎片   | 空闲分区以容量递减次序排列                     | 可以减少难以利用的小碎片                                     | 大分区容易被用完，不利于大进程；***算法开销大***，回收分区后可能需要对空闲分区队列重新排序 |
| 邻近适应 | 由首次适应演变而来，每次从上次查找结束位置开始查找 | 空闲分区以地址递增次序排列（可排列成循环链表） | 不用每次都从低地址的小分区开始检索。***算法开销小***，回收分区后一般不需要对空闲分区队列重新排序 | 会使高地址的大分区也被用完                                   |

## 基本分页存储管理的基本概念

**知识总览**：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506180044.png" style="zoom:50%;" />

**非连续分配**：为用户进程分配的可以是一些<span style="color:#4DA8DA">**分散的内存空间**</span>。

### 分页存储的定义

将内存空间分为一个个<span style="color:#F564A9">大小相等的**分区**</span>（比如：每个分区 4KB），每个分区就是一个<span style="color:#F564A9">**页框**</span>（<span style="color:#B33791">页框</span> = <span style="color:#B33791">页帧</span> = <span style="color:#B33791">内存块</span> = <span style="color:#B33791">物理块</span> = <span style="color:#B33791">物理页面</span>）。每个页框有一个编号，即<span style="color:#B33791">**页框号**</span>（<span style="color:#B33791">页框号</span> = <span style="color:#B33791">页帧号</span> = <span style="color:#B33791">内存块号</span> = <span style="color:#B33791">物理块号</span> = <span style="color:#B33791">物理页号</span>），页框号<span style="color:#B33791">___从 0 开始___</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250618011011525.png" alt="image-20250618011011525" style="zoom:33%;" />

将<span style="color:#52357B">进程的逻辑地址空间</span>也分为<span style="color:#FE5D26">与页框大小相等</span>的一个个部分，每个部分称为一个<span style="color:#FE5D26">**页**</span>或<span style="color:#FE5D26">**页面**</span>。每个页面也有一个编号即<span style="color:#FE5D26">**页号**</span>，页号也是<span style="color:#FE5D26">___从 0 开始___</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250618011332976.png" alt="image-20250618011332976" style="zoom:33%;" />

操作系统<span style="color:#F564A9">以页框为单位为各个进程分配</span>内存空间，进程的每个页面分别放入一个页框中。也就是说，进程的<span style="color:#F564A9">页面</span>与内存的<span style="color:#F564A9">页框</span>有<span style="color:#F564A9">**一一对应**</span>的关系。

各个页面不必连续存放，可以放到不相邻的各个页框中。

### 重要的数据结构——页表

为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张<span style="color:#CA7842">**页表**</span>，页表通常存在 <u>*PCB（进程控制块）*</u>中。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250618013907969.png" alt="image-20250618013907969" style="zoom:33%;" />

1. 一个进程对应一张页表
2. 进程的每个页面对应一个页表项
3. 每个<span style="color:#687FE5">页表项</span>由**页号**和**块号**组成
4. 页表记录进程<span style="color:#687FE5">页面</span>和实际存放的<span style="color:#687FE5">内存块</span>之间的<span style="color:#687FE5">映射关系</span>

### 页表项大小

假设某系统物理内存为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节？

因为内存块大小 = 页面大小 = 4KB = $2^{12} \text{B}$，所以 4GB 的内存总共会被分成 $\dfrac{2^{32}}{2^{12}} = 2^{20}$ 个内存块，内存块编号的范围应该是 $0 \sim 2^{20} - 1$，因此至少需要 20bit 才可以表示内存块号；而计算机以字节为单位来分配，因此至少需要 <span style="color:#DC2525">3B</span> 来表示<span style="color:#DC2525">块号</span>。（$3 \times 8 = 24$）

> **注意**：通过计算机内存块的数量来判断页表项中块号至少占多少字节。

因为页表项<u>连续存放</u>，因此<span style="color:#D5451B">页号</span>是<span style="color:#D5451B">隐藏</span>的，<span style="color:#FF3F33">**不占存储空间**（类比数组）</span>。

假设页表中的各页表项从内存地址为 `X` 的地方开始连续存放，如何找到页号为 `i` 的页表项？

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250618044327794.png" alt="image-20250618044327794" style="zoom:33%;" />

`i` 号页表项的存放地址为 `X + 3 * i`。

由于页号是**隐藏**的，因此每个页表项占 3B，存储整个页表至少需要 $\left(3 \times (n + 1) \right) \text{B}$。

> **注意**：页表记录的只是内存块号，而不是内存块的起始地址，J 号内存块的起始地址为 $J \times \text{内存块大小}$。

### 地址转换

进程在内存中**连续存放时**，操作系统是如何实现逻辑地址到物理地址的转换的？

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250618_115111.png" style="zoom:33%;" />



将进程地址空间**分页**后，操作系统该如何实现逻辑地址到物理地址的转换呢？

<span style="color:#4E6688">**特点**</span>：虽然进程的各个页面是**离散存放**，但是页面**内部**是连续存放的。

若要访问逻辑地址 A，则有：

1. 确定逻辑地址 A 对应的**<span style="color:#4E6688">页号</span>** P
2. 找到 P 号页面在内存中的起始地址（需要查页表）
3. 确定逻辑地址 A 的<span style="color:#4E6688">**页内偏移量**</span> W

**逻辑地址 A 对应的物理地址**为 **P 号页面在<u>内存中的起始地址</u>**加上**页内偏移量 W**。

举例而言，在某计算机系统中，页面大小是 50B。某进程逻辑地址空间大小为 200B，则逻辑地址 110 对应的页号、页内偏移量是多少？

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250618120823291.png" alt="image-20250618120823291" style="zoom:33%;" />

- **页号**：$\text{逻辑地址} \mid \text{页面长度}$，也就是取除法的<span style="color:#129990">整数</span>部分
- **页内偏移量**：$\text{逻辑地址} \% \text{页面长度}$，也就是取除法的<span style="color:#129990">余数</span>

因此上述例子页号为 2，页内偏移量为 10。

<span style="color:#732255;font-weight:bold">逻辑地址</span>可以拆分为 `(页号, 页内偏移量)`，通过页号查询页表，可知页面在<u>内存中的起始地址</u>。

页面在内存中的起始地址加上页内偏移量就是实际的物理地址。

> **注意**：在计算机内部，地址是用二进制来表示的，如果<span style="color:#732255">页面大小</span>刚好是<span style="color:#27548A"> 2 的整数幂</span>，则计算机硬件可以很快速地把逻辑地址拆分为 `(页号, 页内偏移量)`。

假设某计算机用 32 个二进制位来表示逻辑地址，页面大小为 4KB = $2^{12} \text{B}$ = 4096B。

**0 号页**的逻辑地址范围应该是 $0 \sim 4095$，用二进制表示应该是：

<img src="/home/leafevans/.config/Typora/typora-user-images/image-20250618140023326.png" alt="image-20250618140023326" style="zoom:50%;" />

**1 号页**的逻辑地址范围应该是 $4096 \sim 8191$，用二进制表示应该是：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250618140124648.png" alt="image-20250618140124648" style="zoom:50%;" />

**2 号页**的逻辑地址范围应该是 $8192 \sim 12287$，用二进制表示应该是：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250618140207660.png" alt="image-20250618140207660" style="zoom:50%;" />

可以发现，前面的 20 位是页号，末尾的 12 位是页内偏移量。

**结论**：若每个页面的大小为<span style="color:#B13BFF"> $2^K \text{B}$</span>，用二进制数表示逻辑地址，则<span style="color:#B13BFF">末尾 K 位</span>即为<span style="color:#B13BFF">页内偏移量</span>，其余部分就是<span style="color:#B13BFF">页号</span>。

假设<span style="color:#B13BFF">物理地址</span>也用 32 个二进制位表示，则由于<u>内存块大小 = 页面大小</u>（代表页内偏移量相等），因此：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250618163007454.png" alt="image-20250618163007454" style="zoom:50%;" />

假设通过查询页表得知 1 号页面存放的内存块号是 9（1001），则：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250618163138391.png" alt="image-20250618163138391" style="zoom:50%;" />

因此逻辑地址 4097 对应的物理地址为**页面在内存中存放的起始地址**加上**页内偏移量**，即：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250618163321076.png" alt="image-20250618163321076" style="zoom:50%;" />

可以看出相当于将后面的 12 位数字替换掉。

**结论**：如果页面大小刚好为 2 的整数幂，则只需把页表中记录的<span style="color:#FF7D29">物理块号拼接上页内偏移量</span>就可以得到对应的<span style="color:#FF7D29">物理地址</span>。（相当于把页号换成页框号）

如果不是的话，需要通过<u>***页框起始物理地址加上页内偏移量***</u>。

---

页面大小是 2 的整数幂有什么好处？

1. **逻辑地址的拆分更加迅速**：如果每个页面大小为 2KB，用二进制数表示逻辑地址，如末尾 K 位即为页内偏移量，其余部分就是页号。因此，如果让每个页面的大小为 2 的整数幕，计算机硬件就可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度
2. **物理地址的计算更加迅速**：根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址

### 逻辑地址结构

分页存储管理的**逻辑地址结构**如下：

| 31……12 |    11……0     |
| :----: | :----------: |
| 页号 P | 页内偏移量 W |

地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量 W。在上述例子中，地址长度为 32 位，其中 0~11 位为<span style="color:#075B5E">**页内偏移量**</span>，或称**页内地址**；12~31 位为**<span style="color:#075B5E">页号</span>**。

<span style="color:#075B5E">如果有 K 位表示**页内偏移量**，则说明该系统中一个页面的大小是 $2^K $个内存单元。</span>

<span style="color:#075B5E">如果有 M 位表示**页号**，则说明在该系统中，一个进程最多允许 $2^M$ 个页面</span>。

有关系如下：

页面大小 ⇔ 页内偏移量位数 ⇔ 逻辑地址结构

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506181811.png" style="zoom:67%;" />

## 基本地址变换机构

**知识总览**：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506180044.png" style="zoom:50%;" />

基本地址变换机构是用于实现逻辑地址到物理地址转换的**一组硬件机构**。

---

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个<span style="color:#4DA8DA">**页表寄存器**</span>（PTR），存放<span style="color:#4DA8DA">页表在内存中的起始地址 F</span> 和<span style="color:#4DA8DA">页表长度 M</span>。进程未执行时，页表的始址和页表长度<span style="color:#4DA8DA">放在**进程控制块（PCB）**中</span>，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

> **注意**：页面大小是 2 的整数幂。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250619005848037.png" alt="image-20250619005848037" style="zoom:50%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250619013814878.png" alt="image-20250619013814878" style="zoom:50%;" />

---

设页面大小为 L，实现逻辑地址 A 到物理地址 E 的变换过程如下：

1. 计算页号 P 和页内偏移量 W（如果用十进制数手算，则 $P = A \mid L$，$W = A \% L$；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）
2. 比较页号 P 和页表长度 M，若 $P \le M$，则产生越界中断，否则继续执行（页号是从 0 开始的，而页表长度至少是 1，因此 $P = M$ 时也会越界）
3. 页表中页号 P 对应的$页表项地址 = 页表起始地址 F + 页号 P \times 页表项长度$，取出该页表项内容 b 即为内存块号（区分页表项长度、页表长度、页面大小的区别；页表长度指的是这个页表中总共有几个页表项，即总共有几个页；页表项长度指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间）
4. 计算 $E = b \times L+W$，用得到的物理地址 $E$ 去访存（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）

---

举例，若页面大小 L 为 1K 字节，页号 2 对应的内存块号 $b = 8$，将逻辑地址 $A=2500$ 转换为物理地址 E。

**等价描述**：某系统<span style="color:#8A784E">**按字节寻址**</span>，逻辑地址结构中，<span style="color:#8A784E">**页内偏移量占 10 位**</span>（说明一个页面的大小为 $2^{10} \text{B} = 1 \text{KB}$，页号 2 对应的内存块号 $b=8$，将逻辑地址 $A=2500$ 转换为物理地址 E。

1. **计算页号、页内偏移量**：

   页号 $P = A \mid L = 2500 \mid 1024 = 2$，页内偏移量 $W = A % L = 2500 % 1024 = 452$

2. 根据题中条件可知，页号 2 没有越界，其存放的内存块号 $b = 8$
   
3. 物理地址 $E = b \times L + W = 8 \times 1024 + 425 = 8644$

在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，<span style="color:#5459AC">页式管理中地址是**一维的**</span>。即，<u>只要给出一个逻辑地址</u>，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。

---

<span style="color:#7965C1">每个页表项的长度是相同的，页号是**隐含**的。</span>

举例，假设某系统物理内存大小为 4GB，页面大小为 4KB，的内存总共会被分为 $\dfrac{2^{32}}{2^{12}} = 2^{20}$ 个内存块，因此内存块号的范围应该是 $0 \sim 2^{20} - 1$。

因此至少要 20 个二进制位才能表示这么多的内存块号，因此至少要 3 个字节才够。（每个字节 8 个二进制位，3 个字节共 24 个二进制位）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250619114835864.png" alt="image-20250619114835864" style="zoom:33%;" />

 

各页表项会按顺序连续地存放在内存中。

如果该页表在内存中存放的起始地址为 `X`，则 M 号页对应的页表项是存放在内存地址为 `X + 3 * M`，一个页面为 4KB，则每个页框可以存放 $4096 \mid 3=1365$ 个页表项，但是这个页框会剩余 $4096 \% 3 = 1 \text{B}$ 页内碎片。因此，1365 号页表项存放的地址为 `X + 3 * 1365 + 1`，无法跨页框的存储。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250619120037566.png" alt="image-20250619120037566" style="zoom:33%;" />

为了像之前计算的一样来查找页表项，假定<span style="color:#7965C1">每个页表项占 **4 字节**</span>，则每个页框刚好可以存放 1024 个页表项。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250619124451946.png" alt="image-20250619124451946" style="zoom:33%;" />

1024 号页表项虽然是存放在下一个页框中的，但是它的地址依然可以用 `X + 4 * 1024` 得出。

<span style="color:#7965C1">**结论**</span>：理论上，页表项长度为 3B 即可表示内存块号的范围，但是，为了<u>*方便页表的查询*</u>，常常会让一个页表项占更多的字节，使得<span style="color:#7965C1">每个页面恰好可以装得下整数个页表项</span>。

进程页表通常是<span style="color:#7965C1">装在**连续的**内存块中</span>的。（便于使用统一的计算方式）

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506191301.png" style="zoom:50%;" />

CPU 在地址变换过程中访问了两次内存，第一次访问内存是查页表，第二次访问内存是访问目标内存单元。

## 具有快表的地址变换机构

**知识总览**：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506191441.png" style="zoom: 40%;" />

是基本地址变换机构的改进版本。

### 快表的定义（TLB）

<span style="color:#725CAD">**快表**</span>，又称<span style="color:#725CAD">**联想寄存器**</span>（TLB，translation lookaside buffer），是一种<span style="color:#725CAD">访问速度比内存快很多</span>的<span style="color:#F97A00">**高速缓存**</span>（<u>***TLB 不是内存***</u>），用来存放<span style="color:#725CAD">最近访问的**页表项的副本**</span>，可以加速地址变换的速度与此对应，内存中的页表常称为<span style="color:#725CAD">**慢表**</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250619151624928.png" alt="image-20250619151624928" style="zoom: 33%;" />

能否把整个页表都放在 TLB 中？不可，要顾虑<u>成本</u>和<u>效率</u>等因素。

### 地址变换过程（TLB）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250619_163311.png" alt="屏幕截图_20250619_163311" style="zoom:50%;" />

1. CPU 给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较
2. 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，<span style="color:#0065F8">访问</span>该物理地址对应的<span style="color:#0065F8">内存单元</span>；因此，若<span style="color:#0065F8">快表命中</span>，则访问某个逻辑地址仅需<span style="color:#0065F8">一次访存</span>即可
3. 如果没有找到匹配的页号，则需要<span style="color:#0065F8">访问内存中的页表</span>，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，<span style="color:#0065F8">访问</span>该物理地址对应的<span style="color:#0065F8">内存单元</span>；因此，若<span style="color:#0065F8">快表未命中</span>，则访问某个逻辑地址需要<span style="color:#0065F8">两次访存</span>（<span style="color:#0065F8">在找到页表项后，应同时将其存入快表</span>，以便后面可能的再次访问；但若快表已满，则必须按照一定的算法对旧的页表项进行替换）

因为查询快表的速度要比查询页表的速度快很多，因此只要快表命中，就可以节省时间。因为局部性原理，一般快表的命中率可以达到 90% 以上。

某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 1us，访问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少？
$$
(1 + 100) \times 0.9 + (1 + 100 + 100) \times 0.1 = 111
$$
有的系统支持<span style="color:#D5451B">快表和慢表同时查找</span>，如果是这样，平均耗时有：
$$
(1 + 100) \times 0.9 + (100 + 100) \times 0.1 = 110.9
$$
若未采用快表机制，则访问一个逻辑地址需要：
$$
100 + 100 = 200
$$
显然，引入快表机制后，访问一个逻辑地址的速度就快多了。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250619180748218.png" alt="image-20250619180748218" style="zoom:50%;" />

### 局部性原理

```c
int i = 0;
int a[100];
while (i < 100) {
    a[i] = i;
    i++;
}
```

这个程序执行时，会很频繁地访问 10 号页面、23 号页面。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250619181324383.png" alt="image-20250619181324383" style="zoom:33%;" />

- <span style="color:#F564A9;font-weight:bold">时间局部性</span>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问（因为程序中存在<u>*大量的循环*</u>）
- <span style="color:#F564A9;font-weight:bold">空间局部性</span>：一且程序访间了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中都是<u>*连续存放的*</u>）

在**<span style="color:#9B7EBD">基本地址变换机构</span>**中，每次要访问一个逻辑地址，都需要**<span style="color:#9B7EBD">查询内存中的页表</span>**；由于局部性原理，<span style="color:#9B7EBD">**可能连续很多次查到的都是同一个页表项**</span>。

| 地址变换机构               | 地址变换过程                                                 | 访问一个逻辑地址的访存次数                                   |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **基本地址变换机构**       | ① 算页号、页内偏移量<br>② 检查页号合法性<br>③ 查页表，找到页面存放的内存块号<br>④ 根据内存块号与页内偏移量得到物理地址<br>⑤ 访问目标内存单元 | 两次访存                                                     |
| **具有快表的地址变换机构** | ① 算页号、页内偏移量<br>② 检查页号合法性<br>③ 查快表：<span style="color:red">若命中</span>，可直接获取内存块号（跳至 ⑤）；<span style="color:red">若未命中</span>则进行 ④<br>④ 查页表获取内存块号，并将页表项复制到快表<br>⑤ 组合物理地址<br>⑥ 访问目标内存单元 | <span style="color:red">快表命中</span>：一次访存<br><span style="color:red">快表未命中</span>：两次访存 |

TLB 和普通 Cache 的区别——TLB 中只有页表项的副本，而普通 Cache 中可能会有<u>*其他各种数据的副本*</u>。

## 两级页表

**知识总览**：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506191900.png" style="zoom:50%;" />

### 单级页表存在的问题

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250619191133923.png" alt="image-20250619191133923" style="zoom:50%;" />

| 31……12 |    11……0     |
| :----: | :----------: |
| 页号 P | 页内偏移量 W |

某计算机系统按字节寻址，支持 32 位的逻辑地址，采用分页存储管理，页面大小为 4KB，页表项长度为 4B。

$4 \text{KB} = 2^{12}\text{B}$，因此页内地址要用 12 位表示，剩余 20 位表示页号。

因此，该系统中用户进程最多有 $2^{20}$ 页。相应的，一个进程的页表中，最多会有 $2^{20} = 1 \text{M} = 1,048,576$ 个页表项，所以一个页表最大需要 $2^{20} \times 4 \text{B} = 2^{22} \text{B}$，共需要 $\dfrac{2^{22}}{2^{12}} = 2^{10}$ 个页框存储该页表。（需要专门给进程分配 $2^{10} = 1024$ 个<u>连续的页框来存放它的页表</u>）

根据页号查询页表的方法：$K 号页对应的页表项存放位置 = 页表始址 + K \times 4$，要在<span style="color:#5459AC">所有的页表项都**连续存放**</span>的基础上才能用这种方法找到页表项。

根据**局部性原理**可知，大部分情况下，<span style="color:#483AA0">进程在一段时间内**只需要访问某几个页面**就可以正常运行了</span>，因此<span style="color:#CA7842">没有必要让整个页表都**常驻内存**</span>。

存在以下两个问题：

1. 页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框（此时与离散分配存储管理的思想是相悖的）
2. 没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面

---

如何解决进程在内存中必须连续存储的问题？将进程地址空间分页，并为其建立一张页表，记录各页面的存放位置。

类似的，为了解决**页表必须连续存放**的问题，把必须连续存放的页表再分页。

可将长长的页表进行分组，使每个内存块刚好可以放入一个分组。（比如上个例子中，页面大小 4KB，每个页表项 4B，每个页面可存放 1K 个页表项，因此每 1K 个连续的页表项为一组，每组刚好占一个内存块，再将各组离散地放到各内存块中；此外，有 $\frac{2^{20}}{2^{10}} = 2^{10}$ 组，可以发现外层组的数量是由页面大小决定的）

另外，要为离散分配的页表再建立一张页表，称为<span style="color:#F79B72">页目录表</span>，或称<span style="color:#F79B72">外层页表</span>，或称<span style="color:#F79B72">顶层页表</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250619231858710.png" alt="image-20250619231858710" style="zoom:50%;" />

| 31……22   |  21……12  |   11……0    |
| -------- | :------: | :--------: |
| 一级页号 | 二级页号 | 页内偏移量 |

10 位的一级页号刚好可表示 $0 \sim 1023$，类似的，二级的 10 位也可以表示。

### 地址变换过程

举例，将 `(0000000000, 0000000001, 111111111111)` 转换为物理地址。（用十进制表示）

1. 按照地址结构将逻辑地址拆分为三部分
2. 从 PCB 中读出<u>*页目录表始址*</u>，再根据一级页号查<u>*页目录表*</u>，找到下一级页表在内存中的位置
3. 根据二级页表查表，找到最终想访问的内存块号
4. 结合页内偏移量得到物理地址

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250619234820073.png" alt="image-20250619234820073" style="zoom:50%;" />

---

对于问题二，可以在需要访问页面时才把页面调入内存（虚拟存储技术），可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250620000724720.png" alt="image-20250620000724720" style="zoom:50%;" />

---

> **注意**：
>
> 1. 若采用多级页表机制，则<span style="color:#129990">各级页表的大小**不能超过一个页面**</span>：
>
>    例如，某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要<u>*采用**多少级**页表*</u>，<u>*页内偏移量为**多少位***</u>？
>
>    $页面大小=4\text{KB}=2^{12}\text{B}$，按字节编址，因此页内偏移量为 12 位，页号为 $40-12=28$ 位，页面大小为 $2^{12}\text{B}$，页表项大小为 $4\text{B}$，则每个页面可存放 $\dfrac{2^{12}}{4}=2^{10}$ 个页表项，因此各级页表最多包含 $2^{10}$ 个页表项，需要 10 位二进制位才能映射到 $2^{10}$ 个页表项，因此每一级的页表对应页号应为 10 位；总共 28 位的页号至少要分为三级。
>
>    （如果只分为两级页表，则一级页号占 18 位，也就是说页目录中最多可能有 $2^{18}$ 个页表项，显然，***<u>一个页面是放不下这么多页表项的</u>***）
>
> 2. 两级页表的<span style="color:#F79B72">**访存次数**</span>分析（假设没有快表结构）：
>
>    - **第一次访存**：访问内存中的页目录表
>    - **第二次访存**：访问内存中的二级页表
>    - **第三次访存**：访问目标内存单元
>
>    对内存利用率的上升带来的是访问效率的下降，N 级页表访问一个逻辑地址需要 N + 1 次访存。

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506200040.png" style="zoom:50%;" />

要能根据逻辑地址位数、页面大小、页面项大小确定多级页表的逻辑地址结构。

## 基本分段存储管理方式

**知识总览**：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506200506.png" style="zoom:50%;" />

与**分页**最大的区别就是离散分配时所分配地址空间的<u>***基本单位***</u>不同。

### 分段

<span style="color:#64E2B7">**进程的地址空间**</span>：按照程序<span style="color:#FFB823">**自身的逻辑**</span>关系<span style="color:#FFB823">划分为**若干个段**</span>，每个段都有一个段名（在低级语言中，程序员使用段名来编程），<span style="color:#FFB823">每段从 0 开始编址</span>。

**<span style="color:#B13BFF">内存分配规则</span>**：以段为单位进行分配，<span style="color:#687FE5">每个段在内存中**占据连续空间**</span>，但<span style="color:#687FE5">各段之间可以不相邻</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250620130524489.png" alt="image-20250620130524489" style="zoom:45%;" />

由于是按逻辑地址功能模块划分，用户<span style="color:#03A6A1">编程更方便，程序的可读性更高</span>。（编译程序会将**段名**转换为**段号**）

```assembly
LOAD 1,  [D] | <A>;  // 将分段 D 中的 A 单元内的值读入寄存器 1
STORE 1, [X] | <B>;  // 将寄存器 1 的内容存入 X 分段的 B 单元中
```

分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成。如：

| 31……16 |  15……0   |
| :----: | :------: |
|  段号  | 段内地址 |

段号的位数决定了每个进程**最多**可以分几个段，段内地址位数决定了每个段的**最大**长度是多少。

上述例子中，若系统是按字节寻址的，则段号占 16 位，因此在该系统中，每个进程最多有 $2^{16} = 64 \text{K}$ 个段；段内地址占 16 位，因此每个段的最大长度为 $2^{16} = 64 \text{KB}$。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250620132604930.png" alt="image-20250620132603494" style="zoom:40%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250620132644337.png" alt="image-20250620132644337" style="zoom: 33%;" />

### 段表

程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称<span style="color:#FFC107">**段表**</span>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250620132926675.png" alt="image-20250620132926675" style="zoom:50%;" />

1. 每个段对应一个段表项，其中记录了该段在内存中的<span style="color:#06923E">起始位置</span>（又称<span style="color:#06923E">**基址**</span>）和<span style="color:#06923E">段的长度</span>（与分页存储不同，段并不<u>*等长*</u>，且存储的是**基址**，而不是**内存块号**）
2. <span style="color:#06923E">各个**段表项的长度是相同**的</span>。例如，某系统按字节寻址，采用分段存储管理，逻辑地址结构为 `(段号 16 位, 段内地址 16 位)`，因此用 16 位即可表示最大段长。物理内存大小为 4GB（可用 32 位表示整个物理内存地址空间）。因此，可以让每个段表项占 $16+32=48$ 位，即 6B。由于段表项长度相同，因此<span style="color:#E67514">段号可以是隐含的，不占存储空间</span>；若段表存放的起始地址为 M，则 K 号段对应的段表项存放的地址为 `M + K * 6`

### 地址变换

```assembly
LOAD 1, [D] | <A>;  // 将分段 D 中 A 单元内的值读入寄存器 1
```

经过编译程序编译后，形成等价的机器指令。

“取出**段号为 2，段内地址为 1024**的内存单元中的内容，放到寄存器 1 中。”

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250620141457577.png" alt="image-20250620141457577" style="zoom: 50%;" />



<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250620143524954.png" alt="image-20250620143524954" style="zoom:67%;" />

### 分段、分页管理的对比

<span style="color:#CA7842">页</span>是<span style="color:#CA7842">信息的物理单位</span>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，<span style="color:#CA7842">对用户是不可见的</span>。

<span style="color:#CA7842">段</span>是<span style="color:#CA7842">信息的逻辑单位</span>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<span style="color:#CA7842">分段对用户是可见的</span>，用户编程时需要显式地给出段名。

页的大小固定且由系统决定。段的长度<u>*却不固定*</u>，决定于用户编写的程序。

<span style="color:#CA7842">分页</span>的用户进程<span style="color:#CA7842">地址空间是**一维的**</span>，程序员只需给出一个记忆符即可表示一个地址。

<span style="color:#CA7842">分段</span>的用户进程<span style="color:#CA7842">地址空间是**二维的**</span>，程序员在标识一个地址时，既要给出段名，也要给出段内地址。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250620151350499.png" alt="image-20250620151350499" style="zoom:50%;" />

<span style="color:#FE5D26">分段</span>比分页<span style="color:#FE5D26">更容易实现信息的**共享与保护**</span>。

不能被修改的代码称为<span style="color:#A4B465">**纯代码**</span>或<span style="color:#A4B465">**可重入代码**</span>（不属于临界资源），这样的代码是可以共享的。（比如，有一个代码段只是简单的输出，`"Hello World!"`）

可修改的代码是不能共享的。（比如，有个代码段中有<u>***很多变量***</u>，各进程并发地同时访问可能造成<u>*数据不一致*</u>）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250620152056322.png" alt="image-20250620152056322" style="zoom:50%;" />

为什么页面难以实现？

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250620152430447.png" alt="image-20250620152430447" style="zoom:50%;" />

访问一个逻辑地址需要几次访存？

- <span style="color:#328E6E">**分页（单级页表）**</span>：第一次访存——查内存中的页表，第二次访存——访问目标内存单元；总共<span style="color:#328E6E">两次访存</span>
- <span style="color:#328E6E">**分段**</span>：第一次访存——查内存中的段表，第二次访存——访问目标内存单元；总共<span style="color:#328E6E">两次访存</span>

与分页系统类似，分段系统中也<span style="color:#328E6E">可以引入***快表***机构</span>，将近期访问过的段表项放到快表中，这样<span style="color:#328E6E">可以少一次访问</span>，加快地址变换速度。

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506201536.png" style="zoom: 67%;" />
