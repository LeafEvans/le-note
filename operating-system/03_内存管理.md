# 内存管理

## 内存的基础知识

**知识总览**：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506161345.png" style="zoom:50%;" />

### 内存的定义与作用

内存可存放数据。程序执行前<span style="color:#03A6A1;font-weight:bold">需要先放到内存中才能被 CPU 处理</span>——缓和 CPU 与硬盘之间的速度矛盾。

在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250616_135704.png" style="zoom: 33%;" />

解决方法就是给内存的存储单元编地址。与酒店类似，内存中也有一个个的**小房间**，每个小房间就是一个<span style="color:#FF4F0F">**存储单元**</span>。

内存地址从 0 开始，<span style="color:#4300FF">**每个地址对应一个存储单元**</span>；如果计算机<span style="color:#4300FF">**按字节编址**</span>，则<span style="color:#4300FF">每个存储单元大小</span>为<span style="color:#4300FF"> 1 字节</span>，即 1B，即 8 个二进制位。

如果<span style="color:#D70654">字长为 16 位</span>的计算机<span style="color:#D70654;font-weight:bold">按字编址</span>，则<span style="color:#D70654">每个存储单元大小</span>为<span style="color:#D70654"> 1 个字</span>；每个字的大小为 16 个二进制位。

> **注意**：
> $$
> 2^{10} = 1 \text{K} \\
> 2^{20} = 1 \text{M} \\
> 2^{30} = 1 \text{G}
> $$
> 例如 4GB 指的是该内存可以存放 $4 \times 2^{30}$ 个字节。如果是按字节编址的话，也就是有 $4 \times 2^{30} = 2^{32}$ 个**小房间**。
>
> 如此多**小房间**，需要 $2^{32}$ 个地址才能一一标识，所以地址需要用 32 个二进制位来表示（$0 \sim 2^{32} - 1$）。

### 指令的工作原理

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616144304391.png" alt="image-20250616144304391" style="zoom:50%;" />

某个寄存器，其地址为 00000011(3)。（有的系统中，寄存器和内存可能统一编址）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616144433501.png" alt="image-20250616144433501" style="zoom:50%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616144743482.png" alt="image-20250616144743482" style="zoom: 33%;" />

上述数据传送指令就是将地址为 01001111 的数据传送到 00000011 对应地址的内存单元，执行完后，00000011 中就会有 10 这个数据。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616144940573.png" alt="image-20250616144940573" style="zoom:33%;" />

上述加法指令代表将地址为 00000011 的数据加上 00000001。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616150151174.png" alt="image-20250616150151174" style="zoom: 33%;" />

拥有和第一个指令同样的操作码，说明也是数据传送指令。将地址为 00000011 的数据传送回 01001111 地址的内存单元处。

---

指令的工作基于**地址**，每个地址对应一个数据的存储单元。

可见，我们写的代码要翻译成 CPU 能识别的指令。这些指令会告诉 CPU 应该去内存的哪个地址读/写数据，这个数据应该做什么样的处理。在这个例子中，我们默认<span style="color:#FF0000">让这个进程的相关内容从地址 0 开始连续存放</span>，指令中的地址参数直接给出了变量 `x` 的实际存放地址（<span style="color:#FF0000">物理地址</span>）。

**如果这个进程不是从地址 0 开始存放的，会影响指令的正常执行吗？**

下面是物理地址从 0 开始的情况：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250616_151827.png" style="zoom:50%;" />

下面是物理地址不是从 0 开始的情况，可以看到程序中是逻辑地址，而装入时的物理地址是要重新计算的：
<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250616_152231.png" style="zoom:50%;" />

### 装入的三种方式——绝对装入

<span style="color:#CA7842;font-weight:bold">绝对装入</span>：在编译时，如果知道程序将放到内存中的哪个位置，编译程序<u>*将产生绝对地址的目标代码*</u>，装入程序按照装入模块中的地址，将程序和数据装入内存。

例如知晓装入模块要从地址 1000 的地方开始存放：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250616_153415.png" style="zoom:50%;" />

绝对转入灵活性差，<span style="color:#F7374F">只适用于单道程序环境</span>。（这个可执行程序在这台电脑上可用，并不代表在另外一台电脑上可用）

### 装入的三种方式——可重定位装入

<span style="color:#FF6500">**静态重定位**</span>：又称<span style="color:#3674B5">可重定位装入</span>。编译、链接后的装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行<span style="color:#3674B5">**重定位**</span>，<u>将逻辑地址变换为物理地址</u>。（地址变换是在装入时一次完成的）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250616_160036.png" style="zoom:50%;" />

静态重定位的特点是在一个作业装入内存时，<span style="color:#2D4F2B">**必须分配其要求的全部内存空间**</span>，如果没有足够的内存，就不能装入该作业。

作业一旦进入内存后，<span style="color:#2D4F2B;font-weight:bold">在运行期间就不能再移动</span>，也不能再申请内存空间。

### 装入的三种方式——动态运行时转入

<span style="color:#725CAD">**动态重定位**</span>：又称<span style="color:#00CAFF">动态运行时装入</span>。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是<span style="color:#00CAFF">把地址转换推退到程序真正要执行时才进行</span>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<span style="color:#00CAFF">重定位寄存器</span>的支持。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图_20250616_161426.png" style="zoom:50%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616162747160.png" alt="image-20250616162747160" style="zoom:50%;" />

采用动态重定位时，<span style="color:#F564A9">允许程序在内存中发生移动</span>。

并且可将程序分配到不连续的存储区中；在程序运行前只需<u>*装入它的部分代码即可投入运行*</u>，然后在程序运行期间，根据需要动态申请分配内存：便于程序段的共享，可以向用户提供更灵活的存储空间，提供一个比实际存储空间大得多的**虚拟地址空间**。

### 从写程序到程序运行

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616163511094.png" alt="image-20250616163511094" style="zoom:33%;" />

- **编译**：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言<span style="color:#CB0404">翻译为机器语言</span>）
- **链接**：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块
- **装入（装载）**：由装入程序将装入模块装入内存运行

### 链接的三种方式

1. **静态链接**：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个*<u>完整的可执行文件</u>*（装入模块），之后不再拆开

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616163802856.png" alt="image-20250616163802856" style="zoom: 33%;" />

2. **装入时动态链接**：将各目标模块装入内存时，边装入边链接的链接方式

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616163957605.png" alt="image-20250616163957605" style="zoom:33%;" />
   
3. **运行时动态链接**：在程序执行中<u>*需要该目标模块时，才对它进行链接*</u>；其优点是便于修改和更新，便于<u>*实现对目标模块的共享*</u>

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250616164359748.png" alt="image-20250616164359748" style="zoom:33%;" />

---

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-202506161647.png" style="zoom:50%;" />



