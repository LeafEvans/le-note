# 索引

## 概述

索引（index）是帮助 MySQL <span style="color:#F075AE">高效获取数据</span>的<span style="color:#F075AE">数据结构</span>（<span style="color:#F075AE">有序</span>）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

<img src="../../../images/database/image_20260119_133945.webp" style="zoom:50%;" />

> [!tip]
>
> 上述二叉树索引结构仅为一个示意图，并非真实的索引结构。

|                             优势                             |                             劣势                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|          提高数据检索的效率，降低数据库的 I/O 成本           |                     索引列也需要占用空间                     |
| 通过索引列对数据表进行排序，降低数据排序的成本，降低 CPU 的消耗 | 索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行 `INSERT`、`UPDATE`、`DELETE` 时，效率降低 |

## 结构

### 介绍

MySQL 的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：

|                    索引结构                    |                             描述                             |
| :--------------------------------------------: | :----------------------------------------------------------: |
| <span style="color:#B153D7">B+Tree 索引</span> | <span style="color:#B153D7">最常见的索引，大部分引擎都支持 B+ 树索引</span> |
|                   Hash 索引                    | 底层数据结构是用哈希表实现的，只有<span style="color:#F63049">精准匹配</span>索引列的查询才有效，不支持<span style="color:#F63049">范围查询</span> |
|               R-tree（空间索引）               | 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
|             Full-text（全文索引）              | 是一种通过建立倒排索引，快速匹配文档的方式；类似于 Lucene、Solr、ES |

|    索引     |      InnoDB      | MyISAM | Memory |
| :---------: | :--------------: | :----: | :----: |
| B+Tree 索引 |       支持       |  支持  |  支持  |
|  Hash 索引  |      不支持      | 不支持 |  支持  |
| R-tree 索引 |      不支持      |  支持  | 不支持 |
|  Full-text  | 5.6 版本之后支持 |  支持  | 不支持 |

> [!tip]
>
> 无特别说明，索引均为 B+ 树结构组织。

### B-Tree

**二叉树**：

<img src="../../../images/database/image_20260119_140938.webp" style="zoom: 60%;" />

**缺点**：顺序插入时易退化为单链表，查询性能大幅下降；大数据量场景下树的层级过深，检索效率显著降低。

**红黑树**：大数据量情况下，层级较深，检索速度慢。

---

B-Tree，<span style="color:#FA5C5C">多路</span>平衡查找树。

以最大度数（max-degree）为 5 的 5 阶 B-Tree 为例（每个节点最多存储 4 个 key、5 个指针）：

<img src="../../../images/database/image_20260119_142248.webp" style="zoom:50%;" />

> [!tip]
>
> 树的度数指的是每一个节点的子节点个数。

插入 100、65、169、368、900、556、780、35、215、1200、234、888、158、90、1000、88、120、268、250 数据为例。

<img src="../../../images/database/image_20260119_174925.webp" style="zoom: 60%;" />

---

<img src="../../../images/database/image_20260119_164608.webp" style="zoom:80%;" />

<img src="../../../images/database/image_20260119_164638.webp" style="zoom:80%;" />

<img src="../../../images/database/image_20260119_164718.webp" style="zoom:80%;" />

<img src="../../../images/database/image_20260119_164747.webp" style="zoom:80%;" />

<img src="../../../images/database/image_20260119_164842.webp" style="zoom:80%;" />

<img src="../../../images/database/image_20260119_164931.webp" style="zoom:80%;" />

<img src="../../../images/database/image_20260119_165021.webp" style="zoom:80%;" />

<img src="../../../images/database/image_20260119_165046.webp" style="zoom:80%;" />

<img src="../../../images/database/image_20260119_165110.webp" style="zoom:80%;" />

<img src="../../../images/database/image_20260119_165351.jpg" style="zoom:80%;" />

<img src="../../../images/database/image_20260119_165634.jpg" style="zoom:80%;" />

<img src="../../../images/database/image_20260119_165920.jpg" style="zoom:80%;" />

<img src="../../../images/database/image_20260119_165937.jpg" style="zoom:80%;" />

<img src="../../../images/database/image_20260119_165938.jpg" style="zoom: 80%;" />

### B+Tree

以最大度数（max-degree）为 4 的 4 阶 B+Tree 为例：

<img src="../../../images/database/image_20260119_170823.png" style="zoom:50%;" />

插入 100、65、169、368、900、556、78、35、215、1200、888、158、90、1000、88、120、268、250 数据为例。

<img src="../../../images/database/image_20260119_174715.png" style="zoom: 60%;" />

---

<img src="../../../images/database/image_20260119_174151.png" style="zoom:80%;" />

<img src="../../../images/database/image_20260119_174424.webp" style="zoom: 80%;" />

<img src="../../../images/database/image_20260119_174458.webp" style="zoom:80%;" />

<img src="../../../images/database/image_20260119_174601.webp" style="zoom:80%;" />

相对于 B-Tree：

1. 所有数据都会出现在**叶子节点**。
2. 叶子节点形成一个**单向链表**。

---

MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，形成了带有顺序指针的 B+Tree，提高区间访问的性能。

<img src="../../../images/database/image_20260119_175220.webp" style="zoom:50%;" />

### Hash

哈希索引就是采用了一定的 Hash 算法，将键值换算成新的 Hash 值，映射到对应的槽位上，然后存储在 Hash 表中。

若两个（或多个）键值，映射到一个相同的槽位上，它们就产生了 Hash 冲突（也称为 Hash 碰撞），可以通过链表来解决。

<img src="../../../images/database/image_20260119_180343.png" style="zoom:50%;" />

**Hash 索引特点**：

1. Hash 索引仅可用于对等比较（`=`、`IN`），不支持范围查询（`BETWEEN`、`<`、`>`……）。
2. 无法利用索引完成排序操作。
3. 查询效率高，通常仅需一次检索即可，效率通常高于 B+Tree 索引。

在 MySQL 中，支持 Hash 索引的是 Memory 引擎，而 InnoDB 中具有自适应 Hash 功能，Hash 索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的。

---

**为什么 InnoDB 存储引擎选择 B+Tree 索引结构？**

- 相对于二叉树，层级更少，搜索效率高。
- 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低。
- 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作。

## 分类

|                    分类                     |                        含义                        |           特点           |   关键字   |
| :-----------------------------------------: | :------------------------------------------------: | :----------------------: | :--------: |
| <span style="color:#FF6500">主键索引</span> |              针对于表中主键创建的索引              | 默认自动创建，只能有一个 | `PRIMARY`  |
| <span style="color:#FF6500">唯一索引</span> |          避免同一个表中某数据列中的值重复          |        可以有多个        |  `UNIQUE`  |
| <span style="color:#FF6500">常规索引</span> |                  快速定位特定数据                  |        可以有多个        |            |
| <span style="color:#FF6500">全文索引</span> | 全文索引查找的是文本中的关键词，而非比较索引中的值 |        可以有多个        | `FULLTEXT` |

在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：

|                             分类                             |                            含义                            |         特点         |
| :----------------------------------------------------------: | :--------------------------------------------------------: | :------------------: |
| <span style="color:#FF0060">聚集索引</span>（Clustered Index） | 将数据存储与索引放到了一起，索引结构的叶子节点保存了行数据 | 必须有，而且只有一个 |
| <span style="color:#FF0060">二级索引</span>（Secondary Index） | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 |     可以存在多个     |

**聚集索引选取原则**：

- 若存在主键，主键索引即聚集索引。
- 若不存在主键，将使用第一个唯一（`UNIQUE`）索引作为聚集索引。
- 若表无主键，也没有合适的唯一索引，则 InnoDB 会自动生成一个 `rowid` 作为隐藏的聚集索引。

<img src="../../../images/database/image_20260122_113342.webp" style="zoom:50%;" />

<img src="../../../images/database/image_20260122_113745.webp" style="zoom:50%;" />

---

1. **以下 SQL 语句，哪个执行效率高，为什么？**

   ```mariadb
   SELECT * FROM user WHERE id = 10;
   
   SELECT * FROM user WHERE name = 'Arm';
   ```

   > [!note]
   >
   > `id` 为主键，`name` 字段已创建索引。

   第一条 SQL 执行效率更高。

   - `id` 是主键，主键默认是聚簇索引，数据按主键物理存储，查询时可直接定位到数据行，无需额外回表。
   - `name` 是普通索引，查询时需要先通过普通查询找到对应的主键值，再去主键索引中获取完整数据（回表操作），多了一次 I/O 开销，效率低于主键查询。

2. **InnoDB 主键索引的 B+Tree 多高呢？**

   **假设**：单条数据大小为 1KB，InnoDB 数据页可存储 16 条该规格的数据；InnoDB 索引指针占用 6 字节，`BIGINT` 类型主键占用 8 字节。

   - **高度为 2**：$8 n + 6 (n + 1) = 16 \times 1024$，算出 n 约为 1170；$1171 \times 16 = 18736$。
   - **高度为 3**：$1171 \times 1171 \times 16 = 21939856$。

## 语法

### 创建语法

```mariadb
CREATE [UNIQUE | FULLTEXT] INDEX index_name ON table_name (index_col_name, ...);
```

**建表时添加索引的基本结构**：

```mariadb
CREATE TABLE 表名 (
  -- 先定义字段
  字段名1 数据类型 [约束],
  字段名2 数据类型 [约束],
  -- 再定义索引（放在字段定义之后）
  索引类型 索引名 (字段名),
  -- 多个索引依次定义
  另一索引类型 另一索引名 (字段名1, 字段名2) -- 联合索引
);
```

> [!tip]
>
> 普通索引、唯一索引中 `INDEX` 和 `KEY` 完全等价；主键索引需用 `PRIMARY KEY`（`KEY` 不可单独使用）；全文索引优先用 `FULLTEXT INDEX`，`FULLTEXT KEY` 虽合法但极少使用。

**按照下列需求，完成索引的创建**：

1. `name` 字段为姓名字段，该字段的值可能会重复，为该字段创建索引。

   ```mariadb
   CREATE INDEX idx_user_name ON user (name);
   ```

   <img src="../../../images/database/image_20260122_130445.webp" style="zoom:50%;" />

2. `phone` 手机号字段的值，是非空且唯一的，为该字段创建唯一索引。

   ```mariadb
   CREATE UNIQUE INDEX uniq_user_phone ON user (phone);
   ```

   <img src="../../../images/database/image_20260122_132443.webp" style="zoom:50%;" />

3. 为 `profession`、`age`、`status` 创建联合索引。

   ```mariadb
   CREATE INDEX idx_user_profession_age_status ON user (profession, age, status);
   ```

   <img src="../../../images/database/image_20260122_133213.webp" style="zoom:50%;" />

4. 为 `email` 建立合适的索引来提升查询效率。

   ```mysql
   CREATE INDEX idx_user_email ON user (email);
   ```

   <img src="../../../images/database/image_20260122_133406.webp" style="zoom:50%;" />

### 查看索引

```mariadb
SHOW INDEX FROM table_name;
```

```mariadb
SHOW INDEX FROM user;
```

<img src="../../../images/database/image_20260122_125825.webp" style="zoom:50%;" />

```mariadb
SHOW INDEX FROM user\G
```

<img src="../../../images/database/image_20260122_125958.webp" style="zoom:50%;" />

> [!tip]
>
> 在 MySQL 命令行客户端中，末尾用 `\G` 替代分号（`;`）可以把查询结果以“竖向”格式输出——每一列单独占一行，便于查看列多或字段值很长的记录。

### 删除索引

```mariadb
DROP INDEX index_name ON table_name;
```

```mariadb
DROP INDEX idx_user_email ON user;
```

<img src="../../../images/database/image_20260122_133213.webp" style="zoom:50%;" />

## SQL 性能分析

### SQL 执行频率

MySQL 客户端连接成功后，通过 `SHOW [SESSION | GLOBAL] STATUS` 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的 `INSERT`、`UPDATE`、`DELETE`、`SELECT` 的访问频次：

```mariadb
SHOW GLOBAL STATUS LIKE 'Com_______';
```

<img src="../../../images/database/image_20260123_014829.webp" style="zoom:50%;" />

执行一次查询操作后：

<img src="../../../images/database/image_20260123_015206.webp" style="zoom:50%;" />

发现 `Com_select` 的值加 1。

> [!tip]
>
> `Com` 是 **Command** 的缩写，`Com_xxx` 是 MySQL/MariaDB 内置的**命令执行次数计数器**，用来统计各类 SQL 命令在当前会话（SESSION）或全局（GLOBAL）范围内的执行次数。

### 慢查询日志

慢查询日志用于记录所有执行耗时超过指定阈值（参数 `long_query_time`，单位为秒，默认 10 秒）的 SQL 语句。

<img src="../../../images/database/image_20260123_021025.webp" style="zoom:50%;" />

MySQL 的慢查询日志默认未开启，需在 MySQL 配置文件（Linux 系统常见路径为 `/etc/my.cnf`，不同系统路径可能略有差异）中配置如下信息：

```ini
# 开启 MySQL 慢日志查询开关
slow_query_log = 1
# 设置慢日志的时间为 2 秒，SQL 语句执行时间超过 2 秒，就会视为慢查询，记录慢查询日志
long_query_time = 2
```

> [!tip]
>
> 现代 Linux 发行版通常不再将所有配置集中写入单一的 `/etc/my.cnf`，而是采用了**模块化**的目录设计（如 `/etc/my.cnf.d/`）。
>
> <img src="../../../images/database/image_20260123_025015.webp" style="zoom:50%;" />
>
> 因此，我们需要编辑该目录下的特定文件来应用配置：MariaDB 请修改 `mariadb-server.cnf`，而 MySQL 通常修改 `mysqld.cnf`。

配置完毕后，通过以下指令重启 MySQL 服务器进行测试，查看慢日志文件中记录的信息 `/var/lib/mysql/localhost-slow.log`：

```bash
sudo systemctl restart mariadb
```

> [!note]
>
> 若为 MySQL：
>
> ```bash
> # 部分系统下服务名为 mysqld
> sudo systemctl restart mysql
> ```

<img src="../../../images/database/image_20260123_031414.jpg" style="zoom:50%;" />

<img src="../../../images/database/image_20260123_031925.jpg" style="zoom:50%;" />

> [!note]
>
> 若未显示指定文件名，默认命名规则为：`[主机名]-show.log`。

<img src="../../../images/database/image_20260123_034614.jpg" style="zoom: 50%;" />

### Profile 详细

`SHOW PROFILE` 命令可以在进行 SQL 优化时，帮助我们精确分析语句执行的时间消耗分布。使用前，可通过 `have_profiling` 参数验证当前 MySQL 是否支持该功能：

```mariadb
SELECT @@have_profiling;
-- SHOW VARIABLES LIKE 'have_profiling';
```

<img src="../../../images/database/image_20260123_105118.png" style="zoom:50%;" />

Profiling 默认是关闭的，可以通过 `SET` 语句在 **Session** 或 **Global** 级别进行开启。

<img src="../../../images/database/image_20260123_105853.png" style="zoom:50%;" />

```mariadb
SET [SESSION | GLOBAL] @@profiling = 1;
```

<img src="../../../images/database/image_20260123_110010.png" style="zoom:50%;" />

> [!note]
>
> `SELECT` 系统变量时**必须**加 `@@` 以避免与字段名混淆；`SET` 赋值时 `@@` 虽然可选，但建议加上以明确语义。
>
> **指定作用域时**：
>
> - 若使用 `@@`，写法为 `@@global.变量名` 或 `@@session.变量名`。
> - 若不使用 `@@`，则必须带上 `GLOBAL` 或 `SESSION` 关键字。

执行一系列的业务 SWL 操作，然后通过如下指令查看指令的执行耗时：

```mariadb
# 查看每一条 SQL 的耗时基本情况
SHOW profiles;

# 查看指定 query_id 的 SQL 语句各个阶段的耗时情况
SHOW PROFILE FOR QUERY query_id;

# 查看指定 query_id 的 SQL 语句 CPU 的使用情况
SHOW PROFILE CPU FOR QUERY query_id;
```

<img src="../../../images/database/image_20260123_111848.png" style="zoom:50%;" />

<img src="../../../images/database/image_20260123_111819.png" style="zoom:50%;" />

<img src="../../../images/database/image_20260123_112030.bmp" style="zoom:50%;" />

### Explain 执行计划

`EXPLAIN` 或者 `DESC` 命令获取 MySQL 如何执行 `SELECT` 语句的信息，包括 `SELECT` 语句执行过程中表如何连接和连接的顺序。

```mariadb
# 直接在 SELECT 语句前加上关键字 EXPLAIN/DESC
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
```

<img src="../../../images/database/image_20260123_113444.webp" style="zoom:50%;" />
