## 单元测试

## 单元测试基础

Go 语言通过内置的 `testing` 框架和 `go test` 命令实现单元测试，核心目标是验证函数逻辑正确性、保障代码可维护性，提前暴露设计或实现错误。

### 核心规范

单元测试的文件和函数有**严格命名规则**，违反会导致测试无法执行：

- **测试文件**：必须以 `_test.go` 结尾（如 `calc_test.go`），推荐与被测试文件放在同一目录（如 `calc.go` 和 `calc_test.go` 同属 `main` 包）。
- **测试函数**：
  1. 必须以 `Test` 开头（如 `TestAdd`，对应测试 `ADD` 函数）。
  2. 唯一参数必须是 `*testing.T`（框架传入，用于日志打印和结果标记）。
  3. 无返回值。

### 基础示例

以计算工具类 `calc.go` 为例，演示完整单元测试流程。

#### 被测试代码（`calc.go`）

```go
package main

// Add 计算两个整数的和
func Add(a, b int) int {
	return a + b
}

// Mol 计算两个整数的积
func Mul(a, b int) int {
	return a * b
}

// Div 计算两个整数的商（简化版，未处理除数为 0）
func Div(a, b int) int {
	return a / b
}
```

#### 测试代码（`calc_test.go`）

```go
package main

import "testing"

// TestAdd 测试 Add 函数：覆盖正常值、负数、边界值（如 0）
func TestAdd(t *testing.T) {
	// 用例 1：正常正数相加
	if ans := Add(1, 2); ans != 3 {
		t.Errorf("Add(1, 2) 预期结果为 3，实际得到 %d", ans)
	}

	// 用例 2：负数相加
	if ans := Add(-10, -20); ans != -30 {
    t.Errorf("Add(-10, -20) 预期结果 -30，实际得到 %d", ans)
	}

	// 用例 3：边界值（含 0）
	if ans := Add(0, 5); ans != 5 {
		t.Errorf("Add(0, 5) 预期结果为 5，实际得到 %d", ans)
	}
}

// TestDiv 测试 Div 函数：覆盖正常情况和异常情况（除数为 0）
func TestDiv(t *testing.T) {
	// 正常用例：整除
	if ans := Div(10, 2); ans != 5 {
		t.Errorf("Div(10, 2) 预期结果为 5，实际得到 %d", ans)
	}

	// 异常用例：除数为 0（此处会触发 panic，需特殊处理）
	defer func() {
		if err := recover(); err == nil {
			t.Errorf("Div(10, 0) 未触发除数为 0 的 panic，测试失败")
		}
	}()
	_ = Div(10, 0)
}
```

### 命令行工具（`go test`）

通过 `go test` 命令执行测试，常用参数如下：

| 命令                  | 作用说明                                                     |
| --------------------- | ------------------------------------------------------------ |
| `go test`             | 执行当前包下所有测试用例，仅输出最终结果（PASS/FAIL）        |
| `go test -v`          | 详细模式：显示每个测试函数的执行过程和日志（推荐调试时使用） |
| `go test -run 匹配符` | 执行指定测试函数 / 子测试，如：<br />- `go test - run TestAdd`（仅执行 `TestAdd`）<br />- `go test -run TestAdd/a1`（仅执行 `TestAdd` 的 `a1` 子测试） |
| `go test -count=1`    | 禁用测试缓存（Go 默认缓存测试结果，修改代码后建议加此参数确保重新执行） |

## 测试框架日志方法

`testing.T` 提供多种日志函数，用于打印信息和标记测试结果。

| 方法       | 功能说明                                                     |
| ---------- | ------------------------------------------------------------ |
| `t.Log`    | 打印普通日志（类似 `fmt.Print`），仅在 `-v` 模式下可见       |
| `t.Logf`   | 格式化打印普通日志（类似 `fmt.Printf`），仅 `-v` 模式可见    |
| `t.Error`  | 打印错误日志，标记测试失败（非致命）                         |
| `t.Errorf` | 格式化打印错误日志，标记测试失败（非致命）                   |
| `t.Fatal`  | 打印致命错误日志，标记测试失败并立即终止当前测试函数（后续代码不执行） |
| `t.Fatalf` | 格式化打印致命错误日志，标记测试失败并立即终止当前测试函数   |

**示例对比**：

- `t.Error("计算错误")`：打印错误后，继续执行后续用例。
- `t.Fatal("除数为 0")`：打印错误后，立即停止当前 `Test.Div` 函数，后续用例不执行。

## 子测试：批量管理用例

当一个函数需要多个测试用例（如正常值、边界值、异常值）时，**子测试**可以优雅地批量管理，支持单独执行某个用例，便于调试。

### 两种实现方式

#### 方式 1：显示调用 `t.Run()`（适合少量用例）。

```go
func TestAdd(t *testing.T) {
	// 子测试 1：正数相加
	t.Run("positive_nums", func(t *testing.T) {
		if ans := Add(2, 3); ans != 5 {
			t.Fatalf("2 + 3 预期 5，实际 %d", ans)
		}
	})

	// 子测试 2：负数相加
	t.Run("negative_nums", func(t *testing.T) {
		if ans := Add(-2, -3); ans != -5 {
			t.Fatalf("-2 + (-3) 预期 -5，实际 %d", ans)
		}
	})

	// 子测试 3：含 0 的相加
	t.Run("with_zero", func(t *testing.T) {
		if ans := Add(0, 3); ans != 3 {
			t.Fatalf("0 + 3 预期 3，实际 %d", ans)
		}
	})
}
```

#### 方式 2：表格驱动测试（适合大量用例）

用结构体数组定义所有用例，通过循环批量执行，可拓展性强。

```go
func TestAdd(t *testing.T) {
	// 定义测试用例表格：包含用例名、输入 A、输入 B、预期结果
	testCases := []struct {
		name     string // 用例名（唯一，便于识别）
		a, b     int    // 输入参数
		expected int    // 预期结果
	}{
		{"postive: 2+3", 2, 3, 5},
		{"negative: -2+(-3)", -2, -3, -5},
		{"zero: 0+5", 0, 5, 5},
		{"max: 1e9+1", 1e9, 1, 1e9 + 1}, // 边界值：大数相加
	}

	// 循环执行所有用例
	for _, tc := range testCases {
		// 子测试：用例名作为子测试标识
		t.Run(tc.name, func(t *testing.T) {
			actual := Add(tc.a, tc.b)
			if actual != tc.expected {
				t.Errorf("%d+%d 预期 %d，实际 %d",
					tc.a, tc.b, tc.expected, actual)
			}
		})
	}
}
```

### 子测试专属命令

- 执行所有子测试：`go test -v -run TestAdd`
- 执行指定子测试：`go test -v -run TestAdd/zero: 0+5`（匹配用例名中的关键词）

## `TestMain`：自定义测试生命周期

`TestMain` 是测试的**全局入口**，用于自定义测试流程（如初始化资源、清理资源），仅在当前测试文件中生效。

### 核心作用

- 测试前：初始化环境（如连接数据库、加载配置、创建临时文件）。
- 测试中：执行所有测试函数（通过 `m.Run()`）。
- 测试后：清理环境（如关闭数据库连接、删除临时文件）。

### 完整示例

```go
package main

import (
    "fmt"
    "os"
    "testing"
    // 假设引入数据库驱动
    // _ "github.com/go-sql-driver/mysql"
)

// setup 测试前初始化：如连接数据库
func setup() {
    fmt.Println("=== 测试前初始化：连接数据库 ===")
    // 实际代码：db, err := sql.Open(...)
}

// teardown 测试后清理：如关闭数据库
func teardown() {
    fmt.Println("=== 测试后清理：关闭数据库 ===")
    // 实际代码：db.Close()
}

// Test1 普通测试函数1
func Test1(t *testing.T) {
    fmt.Println("执行测试1：Test1")
}

// Test2 普通测试函数2
func Test2(t *testing.T) {
    fmt.Println("执行测试2：Test2")
}

// TestMain 全局测试入口（必须命名为TestMain，参数为*m.testing.M）
func TestMain(m *testing.M) {
    // 1. 测试前初始化
    setup()

    // 2. 执行所有测试函数，返回测试结果码（0=成功，非0=失败）
    exitCode := m.Run()

    // 3. 测试后清理
    teardown()

    // 4. 退出程序（必须调用，否则测试会卡住）
    os.Exit(exitCode)
}

```

### 注意事项

- `TestMain` 中**必须调用 `m.Run()`**，否则所有测试函数不会执行。
- `m.Run()` 的返回值是退出码，必须传给 `os.Exit()`，否则测试流程无法正常结束。
- `TestMain` 本身不会被 `go test` 视为测试函数，仅作为入口。

## 单元测试最佳实践

1. **用例独立**：每个测试用例不依赖其他用例（如不共享全局变量，避免用例间干扰）。
2. **覆盖全面**：至少覆盖 3 类场景：
   - 正常业务逻辑（如 `Add(2, 3)`）
   - 边界值（如 0、最大值、最小值）
   - 异常场景（如 `Div(10, 0)`、空指针）
3. **函数命名清晰**：测试函数名 = Test + 被测试函数名（如 `TestAdd`），子测试名描述场景（如 `negative_nums`）。
4. **避免冗余代码**：用表格驱动测试减少重复代码（如 `TestAdd` 的 `testCases`）。
5. **不依赖外部环境**：测试中如需数据库 / 缓存，优先用 mock 工具（如 `gomock`），避免依赖真实服务。

