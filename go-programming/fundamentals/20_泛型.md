# 泛型

Go 在 Go 1.18 版本中，正式引入了泛型，成为 Go 语言中的一个重要特性。

## 概述

### 泛型的定义

**泛型（Generics）**是一种编程思想，它允许在编写代码时使用未知的类型。

泛型可以增加代码的灵活性以及可复用性，同时还可以提高代码的安全性和可读性。泛型在 C++、Java 和 Python 等语言中已经被广泛应用，但在 Go 中一直未被支持。

### Go 泛型的背景

在 Go 语言中，由于缺乏泛型，开发者需要为每种类型都便携一个相应版本，这就导致了代码冗余和维护成本的提高。同时，也使得一些常见的算法及数据结构无法实现。因此，Go 社区一直在呼吁加入泛型特性。

经过多年的等待及探索，Go 1.18 版本终于加入了泛型特性。

### Go 泛型的特点

- **基于类型约束的泛型**：Go 泛型通过类型约束来实现泛型，这意味着泛型函数或类型可以接受特定的类型。
- **编译时类型安全**：Go 泛型通过编译时类型检查来保证类型安全，有助于避免运行时错误。
- **支持多种类型**：Go 泛型支持多种类型，包括基本类型和自定义类型。

## 语法

在 Golang 中，泛型语法包括**类型参数**、**类型约束**、**泛型函数**和**泛型类型**等。

### 泛型函数

```go
func FuncName[T Type](params) returnType {
  // Function body
}
```

- `T`：泛型类型参数
- `Type`：具体的类型
- `params`：函数的参数
- `returnType`：函数的返回值类型

```go
package main

import "fmt"

func toSlice[T any](args ...T) []T {
	return args
}

func main() {
	strings := toSlice("hello", "world")
	nums := toSlice(1, 2, 3)
	fmt.Println(strings)
	fmt.Println(nums)
}
```

<img src="../../images/image-202510031623.webp" style="zoom:80%;" />

### 泛型类型

除了泛型函数外，Go 1.18 版本还引入了泛型类型。泛型类型的语法如下：

```go
type TypeName[T Type] struct {
  // Fields
}
```

- `TypeName`：泛型类型名称
- `T`：泛型类型参数
- `Type`：具体的类型

以一个可以存储任意类型数据的泛型栈类型示例：

```go
package main

import "fmt"

type Stack[T any] struct {
	data []T
}

func (s *Stack[T]) Push(x T) {
	s.data = append(s.data, x)
}

func (s *Stack[T]) Pop() T {
	n := len(s.data)
	x := s.data[n-1]
	s.data = s.data[:n-1]
	return x
}

func main() {
	var s Stack[int]
	s.Push(10)
	s.Push(20)
	s.Push(30)
	fmt.Println(s.Pop())
	fmt.Println(s.Pop())
	s.Push(40)
	fmt.Println(s.Pop())
	fmt.Println(s.Pop())

	var strStack Stack[string]
	strStack.Push("hello")
	strStack.Push("world")
	fmt.Println(strStack.Pop())
	fmt.Println(strStack.Pop())
}
```

<img src="../../images/image-202510031629.webp" style="zoom:80%;" />

## 泛型约束

使用泛型时，需要对泛型类型进行一定的约束。例如，我们希望某个泛型函数或类型只能接受特定类型的参数，或者特定类型的参数必须实现某个接口。

在 Go 中，可以使用泛型约束来实现这些需求。

### 类型约束

类型约束可以让泛型函数或类型只接受特定类型的参数。在 Go 中，类型约束通过**接口**来定义。

例如，下面是一个泛型函数，其可接受实现了 `fmt.Stringer` 接口的类型：

```go
func Print[T fmt.Stringer](x T) {
  fmt.Println(x.String())
}
```

这里，`T` 被约束为“任何实现了 `fmt.Stringer` 接口的类型”。由于 `fmt.Stringer` 定义了 `String() string` 方法，因此在函数体内可以安全地调用 `x.String()`。只有满足该约束的类型（即拥有 `String() string` 方法的类型）才能作为 `T` 的实参传入，否则会在编译时报错。

> [!tip]
>
> Go 的接口是隐式实现的，只要类型定义了所需方法，就自动满足约束，无需显式声明。

### 约束语法

类型约束通过在类型参数后指定一个接口类型来实现。

例如，下面的泛型函数使用 `fmt.Stringer` 和 `io.Reader` 作为类型约束：

```go
func Print[T, fmt.Stringer, U io.Reader](x T, y U) {
  fmt.Println(x.String())
  _, _ = io.Copy(os.Stdout, y)
}
```

在上述例子中，`T` 被约束为“任何实现了 `fmt.Stringer` 接口的类型”，`U` 被约束为“任何实现了 `io.Reader` 接口的类型”。

函数接收两个参数 `x` 和 `y`，并分别调用它们的 `String()` 方法和 `Read()` 方法（通过 `io.Copy`）来输出字符串表示和读取数据。只有满足对应接口约束的类型才能作为实参传入，否则会在编译时报错。

### 接口约束

```go
type MyType[T fmt.Stringer] struct {
  data T
}

func (m *MyType[T]) String() string {
  return m.data.String()
}
```

在此例中，`T` 被约束为“任何实现了 `fmt.Stringer` 接口的类型”。由于 `fmt.Stringer` 要求类型提供 `String() string` 方法，因此在 `MyType[T]` 的方法中可以安全地调用 `m.data.String()`。只有满足该接口约束的类型才能作为 `T` 的实参，否则会在编译时报错。

### 泛型特化

