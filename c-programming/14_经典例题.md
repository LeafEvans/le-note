# 经典例题

## 最大公约数

**题目内容**

给定两个数，求这两个数的最大公约数。

输入：

```bash
20 40
```

输出：

```bash
20
```

```c
#include <stdio.h>

int main(void) {
  int a, b, c;  // 定义了三个整形变量

  scanf("%d %d", &a, &b);  // 输入
  while (c = a % b) {
    a = b;
    b = c;
  }

  // 将 a / b 的余数赋值给 c
  // 并且利用 C 语言的真假特性（即零为假，非零为真）
  // 制定循环

  printf("%d", b);  // 输出除数 b

  return 0;
}
```

**解析**：

根据辗转相除法，取两个数，一个充当被除数，一个充当除数，求两者最大公约数。当被除数除以除数的余数为零时，除数即为最大公约数。当被除数除以除数的余数不为零，此时将被除数替换为原来的除数，除数替换为原来的余数；然后重复上述的步骤，当余数为零时，此时除数就为最大公约数。

**扩展**：

```c
// 最大公约数
#include <stdio.h>

int main(void) {
  int a = 0, b = 0, c = 0;

  scanf("%d %d", &a, &b);

  int ai = a, bi = b;

  while (c = a % b) {
    a = b;
    b = c;
  }
  // 两个数相乘除以最小公倍数就是最大公倍数，把公因子化为唯一一个
  printf("%d\n", (ai * bi) / b);
  // 那个公约数可以和一个因子结合成为一个数，另一个因子结合为另一个数
  return 0;
}
```

递归：

```c
long long gcd(long long a, long long b) {
  if (b == 0) return a;
  return gcd(b, a % b);
}
```

## 出生日期输入输出

### 描述

输入一个人的出生日期（包括年月日），将该生日中的年、月、日分别输出。

**数据范围**：

- 年份满足 $1990 \leq y \leq 2015$

- 月份满足 $1 \leq m \leq 12$

- 日满足 $1 \leq d \leq 30$

#### 输入描述

输入只有一行，出生日期，包括年月日，年月日之间的数字没有分隔符。

#### 输出描述

三行，第一行为出生年份，第二行为出生月份，第三行为出生日期。输出时如果月份或天数为 1 位数，需要在 1 位数前面补 0。

### 示例

输入：

```bash
20130225
```

输出：

```bash
year=2013
month=02
date=25
```

### 解析

```c
#include <stdio.h>

int main(void) {
  int year, month, day;

  scanf("%4d%2d%2d", &year, &month, &day);
  printf("year=%d\nmonth=%02d\nday=%02d\n", year, month, day);

  return 0;
}
```

`%4d%2d%2d` 表示输入一个 8 位数，分成 4 位数、2 位数、2 位数放在三个不同的变量中。

在 `scanf` 函数中，`%md`（m 表示一个常数）会读取 m 位数。而 `printf` 函数也有相似的效果，即输出 m 位数。

而前面加上 `%0` 则会将空缺的位（即空格）用 0 来填充。（类似的还有 `%.2f` 之类的来表示小数点后两位，`%-2d` 代表左对齐两格，`%2d` 代表右对齐两格。还有 `%*2d` 代表不读取这两位数，如 `scanf("%2d%*2d%2d", &a, &b);` 代表输入一个 6 位数，前面两位赋给 a，后面两位赋给 b，中间两位不读取）

## 学生基本信息输入输出

### 描述

依次输入一个学生的学号，以及 3 科（C 语言，数学，英语）成绩，在屏幕上输出该学生的学号，3 科成绩。

> **注意**：输出成绩时需进行四舍五入且保留 2 位小数。

数据范围：学号满足 $1\leq n \leq 20000000$，各科成绩使用百分制，且不可能出现负数。

#### 输入描述

学号以及 3 科成绩，学号和成绩之间用英文分号隔开，成绩之间用英文逗号隔开。

#### 输出描述

学号，3 科成绩，输出格式详见输出样例。

### 示例

输入：

```bash
17140216;80.845,90.55,100.00
```

输出：

```bash
The each subject score of No. 17140216 is 80.85, 90.55, 100.00.
```

### 解析

```c
#include <stdio.h>

int main(void) {
  int id = 0;

  float c = 0.0f, math = 0.0f, eng = 0.0f;
  scanf("%d;%f,%f,%f", &id, &c, &math, &eng);
  printf("The each subject score of No. %d is %.2f, %.2f, %.2f", id, c, math,
         eng);

  return 0;
}
```

定义浮点型时在 0.0 后加上 f 是因为浮点数默认是 `double` 类型的，而不是 `float` 类型的。

## 小乐乐找最大数

### 描述

小乐乐获得 4 个最大数，请帮他编程找到最大的数。

#### 输入描述

一行，4 个整数，用空格分开。

#### 输出描述

一行，一个整数，为输入的 4 个整数中最大的整数。

#### 示例

输入：

```bash
5 8 2 5
```

输出：

```bash
8
```

### 解析

```c
#include <stdio.h>

int main(void) {
  int arr[4] = {0};  // 定义了一个大小为四的数组
  int i = 0;         // 定义了一个变量 i
  int max = 0;

  while (i < 4)  // 使用循环遍历数组，对每个元素进行输入
  {
    scanf("%d", &arr[i]);
    i++;
  }
  i = 0;  // 重新将 i 定义为零

  max = arr[0];  // 先假定最大数为数组第一个元素

  while (i < 4) // 使用循环将 max 与数组内每一个元素作比较，定义新的 max
  {
    if (arr[i] > max) max = arr[i];
    i++;
  }
  printf("%d", max);  // 输出 max

  return 0;
}
```

打擂台！

```c
#include <stdio.h>

int main(void) {
  int max = 0;  // 定义三个变量
  int i = 1;    // i = 1，使得等会还有三次输入
  int n = 0;

  scanf("%d", &max);  // 假定最大值
  while (i < 4)       // 利用循环，比较新输入的值与 max 的大小
  {
    scanf("%d", &n);
    if (n > max) max = n;  // 若新输入的更大，则将 ma x替换为 U+n
    i++;
  }
  printf("%d", max);

  return 0;
}
```

## 求 n 的阶乘

```c
#include <stdio.h>

int main(void) {
  int n = 0, i = 0, ret = 1;  // 定义三个变量

  scanf("%d", &n);            // 输入 n 的值
  for (i = 1; i <= n; i++) {  // 每次循环都会增大 i 的值
    ret *= i;                 // ret 每次乘增大的i的值，直到 i 等于 n
  }
  printf("%d", ret);  // 输出

  return 0;
}
```

（考察循环语句的知识）

## 求 1! + 2! + ... + 10! 的值

### 方法一

```c
#include <stdio.h>

int main(void) {
  int n = 0, i = 0, ret = 1, sum = 0;  // 定义了四个变量

  // n 的循环
  for (n = 1; n <= 10; n++) {
    // i 的循环，并且在每次的外层循环结束后，初始化 ret
    for (i = 1, ret = 1; i <= n; i++) {
      ret *= i;  // 与求 n 的阶乘方法类似
    }
    sum += ret;  // 求 sum 的值
  }
  printf("%d", sum);  // 打印

  return 0;
}
```

### 方法二

```c
#include <stdio.h>

int main(void) {
  int i = 0, j = 1, n = 0;  // 定义三个整形

  for (i = 1; i <= 10; i++) {  // for 循环
    j *= i;                    // 每次循环，每个阶乘都乘一个比最大数大一的数
    n += j;                    // 形成新的阶乘，而后求和
  }
  printf("%d", n);  // 输出

  return 0;
}
```

## 二分法查找指定元素（有序数组）

### 普通版

```c
#include <stdio.h>

int main(void) {
  // 定义有序整型数组
  int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

  // 从标准输入读取要查找的元素
  int n = 0;
  scanf("%d", &n);

  // 计算数组大小并初始化左右边界及中间位置
  int sz = sizeof(arr) / sizeof(arr[0]);
  int leaf = 0;
  int right = sz - 1;
  int mid = (leaf + right) / 2;

  // 循环执行二分查找
  while (leaf <= right) {
    mid = (leaf + right) / 2;
    if (arr[mid] < n) {  // 如果中间元素小于指定元素，则调整左边界即找右侧
      leaf = mid + 1;
    } else if (arr[mid] > n) {
      // 如果中间元素大于指定元素，则调整右边界即找左侧
      right = mid - 1;
    } else {  // 如果中间元素恰好等于指定元素，则退出循环
      break;
    }
  }

  // 根据查找结果输出提示信息
  if (arr[mid] == n) {
    printf("找到了，下标是 %d\n", mid);
  } else if (leaf > right) {
    printf("找不到\n");
  }

  return 0;
}

```

若 `i` 大于指定数组的大小，如 `n = 17`，则 `n` 始终大于 `right`，则会一直执行 `else if` 语句，最终使得左边界大于右边界，跳出循环。而后执行外部的 `else if` 语句。

`mid = (leaf + right) / 2` 语句可用 `mid = leaf + (right - leaf) / 2` 语句来替代，防止 `leaf + right` 的数据超出整形所能表示的范围导致数据溢出，从而造成数据的缺失。

### 函数版

```c
#include <stdio.h>

int binary_search(int arr[10], int x, int y) {
  int leaf = 0;
  int right = y - 1;

  while (leaf <= right) {
    int mid = leaf + (right - leaf) / 2;
    if (x < arr[mid]) {
      right = mid - 1;
    } else if (x > arr[mid]) {
      leaf = mid + 1;
    } else {
      return mid;
    }
  }
  return -1;
}

int main(void) {
  int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  int k = 0;
  int n = 0;
  int sz = sizeof(arr) / sizeof(arr[0]);

  scanf("%d", &k);
  if ((n = binary_search(arr, k, sz)) == -1) {
    printf("没找到,超出寻找范围\n");
  } else {
    printf("找到了，下标是%d\n", n);
  }

  return 0;
}
```

在 C 语言中，数组作为函数参数时会退化为指针类型，此时无法在函数内部直接求得数组的元素个数。

这是因为数组传递给函数时，只传递了数组的首地址，并没有传递数组的长度信息。

所以，当你在函数内部使用 `sizeof(arr) / sizeof(arr[0])` 的方式计算数组的长度时，实际上是计算了指针的大小除以数组元素的大小，结果始终为 1 或者任意固定的值，无法得到正确的数组长度。

为了解决这个问题，你需要通过额外的参数将数组的长度传递给函数。

例如，在你修复的代码中，你添加了一个参数 `y` 来表示数组的长度，并将其作为二分查找的边界条件。这样，你就能在函数内部正确地使用这个长度信息。

## 字符串由两端向中间显现

```c
#include <stdio.h>
#include <string.h>

int main(void) {
  char arr1[] = "Welcome to SCU!!!!";  // 定义两个字符数组
  char arr2[] = "##################";
  int i = 0, j = strlen(arr2) - 1;  // 定义左右边界

  // 替换完中间两个数字后，又进行了
  // i++、j--，导致不满足循环条件，跳出循环，无打印
  // 因此通过改变循环条件是，使 i < j + 2 时跳出循环
  // 就是在进行完 i++、j-- 的计算后，i = 9、j = 8
  while (i < j + 2) {
    printf("%s\n", arr2);  // 满足条件，继续循环
    arr2[i] = arr1[i], arr2[j] = arr1[j];
    i++, j--;
  }

  return 0;
}
```

输出效果：

<img src="../images/image-202508260954.png" style="zoom:80%;" />

## 模拟用户登录情景

```c
#include <stdio.h>
#include <string.h>

int main(void) {
  int i = 0;
  char passwd[20];

  for (i = 1; i < 4; i++) {
    printf("请输入密码:>");
    scanf("%s", passwd);
    if (strcmp(passwd, "abc123") == 0) {
      printf("登录成功\n");
      break;
    } else if (i < 3) {
      printf("密码错误，您还有 %d 次机会", 3 - i);
    } else {
      printf("您的账号已锁定");
    }
  }

  return 0;
}
```

## 字母大小写转换

通过 `while` 循环可以进行多组数据的输入，当读取不成功的时候，就会跳出循环。

```c
#include <stdio.h>

int main(void) {
  char ch = 0;

  getchar();
  // 当 scanf 读取成功时，它会返回成功读到数据的个数
  // 否则返回 EOF，跳出循环
  // 再一次循环时，可以读取换行符，下面两个条件判断语句不执行
  while (scanf("%d", &ch) == 1) {
    if (ch > 'a' && ch < 'z')
      printf("%c", ch - ('a' - 'A'));
    else if (ch > 'A' && ch < 'Z')
      printf("%c", ch + ('a' - 'A'));
  }

  return 0;
}
```

## 打印 100～200 之间的素数

### 版本一

```c
#include <stdio.h>

int main(void) {
  int i = 0;  // 定义变量

  for (i = 100; i <= 200; i++)  // 制定循环
  {
    int j = 0, flag = 1;  // 定义两个变量

    for (j = 2; j < i; j++) {  // 判断 i 是否为素数
      if (i % j == 0) {        // 判断模是否为 0
        flag = 0;              // 如果模为 0
        break;                 // 改变 flag 的值
      }  // 跳出这层循环
    }
    if (flag == 1)        // 如果 flag 为 1
      printf("%d\n", i);  // 说明在循环过程中
  }  // flag 一直没有被改变

  return 0;  // 即所有的 2 ～ i - 1 的数
}  // 都无法整除 i，打印
```

### 版本二

```c
for (j = 2; j <= sqrt(i); j++)
```

将第二层循环条件改变。

因为如果一个数不是素数，它的两个因子中的其中一个，必定小于该数的平方根，只要判断有无小于平方根而大于 1 的那个因子即可。

如果有，就会整除；如果无，在该平方根之后也不可能找到另一个因子。

### 版本三

```c
for (i = 101; i <= 200; i += 2)
```

将第一层循环条件改变。因为一个数如果是素数，必定不是偶数，所以循环条件改成奇数判断。

### 函数版

```c
#include <math.h>
#include <stdio.h>

int is_prime(int n) {
  int i = 0;

  for (i = 2; i <= sqrt(n); i++) {
    if (n % i == 0) return 0;  // 当遇到整除的时候，就会返回 0
  }

  return 1;  // 当没有整除的时候，就会返回 1
}

int main(void) {
  int i = 0;
  int count = 0;

  for (i = 101; i <= 200; i += 2) {
    if (is_prime(i)) {
      printf("%d\n", i);
      count++;
    }
  }
  printf("\ncount = %d\n", count);

  return 0;
}

```

## 调用一次函数，num 的值加一

错误示范：

```c
#include <stdio.h>

void Add(int *x) { *x++; }

int main(void) {
  int num = 0;

  Add(&num);
  Add(&num);
  printf("%d\n", num);

  return 0;
}
```

`*x++` 这个语句因为没有括号，执行流程是这样的：

先对指针变量 `x` 进行解引用，再对指针变量 `x` 进行 `++` 操作。

因此：

```c
#include <stdio.h>

void Add(int *x) { (*x)++; }

int main(void) {
  int num = 0;

  Add(&num);
  Add(&num);
  printf("%d\n", num);

  return 0;
}
```

`(*x)++` 来正确的表示。

因此，在解引用操作中，最好把解引用的指针变量用小括号给圈起来。

## 从大到小输出

```c
#include <stdio.h>

int main(void) {
  int a = 0;
  int b = 0;
  int c = 0;
  int temp = 0;

  scanf("%d %d %d", &a, &b, &c);
  if (b > a) {
    temp = a;
    a = b;
    b = temp;
  }
  if (c > a) {
    temp = a;
    a = c;
    c = temp;
  }
  if (c > b) {
    temp = c;
    c = b;
    b = temp;
  }
  printf("%d %d %d\n", a, b, c);

  return 0;
}
```

## 汉诺塔问题

大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

<img src="../images/image-202508260956.gif" style="zoom:50%;" />

若有 n 个圆盘，由参考系，将 A 柱最底下的圆盘当成地面，先做 `A->B` 的 n - 1 个汉诺塔问题。然后在将 A 柱最底下的圆盘由 `A -> C`，而后再做 `B -> C` 的 n - 1 汉诺塔问题。

由此，代码如下：

```c
#include <stdio.h>

void move(char A, char B, int n) {
  // 定义 move 函数，实现两柱圆盘移动
  printf("把第%d个圆盘从%c->%c\n", n, A, B);
}

void HanoiTower(char A, char B, char C, int n) {
  if (1 == n) {  // 若 n = 1，直接 A->C
    move(A, C, n);
  } else {  // n > 1
    HanoiTower(A, C, B, n - 1);
    // 先实现 A->B 的 n - 1 个汉诺塔问题
    move(A, C, n);
    // 移动 A 柱底层圆盘
    HanoiTower(B, A, C, n - 1);
    // 再实现 B->C 的 n - 1 个汉诺塔问题
  }
}
```

## 韩信点兵

### 描述

都听说过“韩信点兵，多多益善”这个成语，韩信才智过人，从不直接清点人数。只要让士兵 33 人一排，55 人一排，77 人一排的变换队形，查看队尾人数便能清点队伍总人数。

### 输入

第 1 行是一个整数 n，表示随后有 n 组数据。每组数据占一行，包括三种队形的队尾人数 a、b、c，用空格隔开。已知队伍总人数不小于 10，不大于 100。

### 输出

对每组数据，输出相应的队伍总人数，并换行。不存在则输出 `Impossible`，并换行。

### 示例

#### 输入

```c
3
1 1 2
2 4 6
2 3 6
```

#### 输出

```c
16
Impossible
83
```

### 解析

```c
int count_soliders(int num1, int num2, int num3)  // 暴力穷举
{
  int i = 10;

  while (1) {
    if (i > 100) return 0;
    if ((i % 3 == num1) && (i % 5 == num2) &&
        (i % 7 == num3))  // 满足条件就输出
      return i;
    i++;
  }
}
```

## 回文数

### 描述

程序中输入一个正整数，请判断他是否为回文数。

> **注意**：类似 1234321、123321 等这样，顺序和逆序相同的整数称为回文数。

### 输入

一个正整数 n。

### 输出

若 n 是回文数，输出 `Yes`，否则输出 `No`。

### 解析

```c
#include <stdio.h>

int is_palindrome(int num) {
  int orignal_num = num;  // 原本的数
  int reverse_num = 0;    // 倒着的数

  // 限定条件，当 num > 0 时，才会循环
  // 因为它是整数除法，所以最后不会产生小数，而是零
  while (num) {                                 // 零为假，跳出循环
    reverse_num = reverse_num * 10 + num % 10;  // 先加上取余得到个位
    // 一次循环后，num 除以 10 再赋给 num
    // 而反转数个位上的 2 乘上 10，变成十位上的 2
    num /= 10;
  }  // 之后再加上新的 num 取模得到的新的个位，如此循环，形成与原数顺序相反的数
  if (orignal_num == reverse_num)  // 判断顺序与倒序是否相等
    return 1;
  else
    return 0;
}
```

## 字符串逆序

### 方法一

```c
#include <string.h>

void swap(char *a, char *b) {
  char temp = *a;

  *a = *b;
  *b = temp;
}

void reverse_string(char *str) {
  int leaf = 0;
  // 注意右下标是字符串长度减一
  // strlen 可以在数组中使用，本质上也是将指针传给它
  // 与运算符 sizeof 不同
  int right = strlen(str) - 1;
  while (leaf < right) {
    swap(&str[leaf], &str[right]);
    leaf++;
    right--;
  }
}
```

### 方法二

```c
void reverse_string(char *str) {  // 传字符串第一个字符的地址
  char tem = *str;                // 将第一个字符赋给临时变量 tem
  int len = strlen(str);          // 计算字符串的长度

  *str = *(str + len - 1);  // 将最后一个字符赋给第一个字符
  *(str + len - 1) = '\0';  // 最后一个字符赋值为 '\0'，形成新的字符末尾
  // 计算下一次递归的字符串长度，当 2 个字符及以上后
  // 进行递归（因为 2 个字符及以上才要交换）
  if (strlen(str + 1) > 1)
    // 进行递归，每次递归都会创建一个新的临时变量存储字符串第一个字符
    reverse_string(str + 1);
  *(str + len - 1) = tem;  // 将临时变量赋给字符串最后一个字符
}
```

<img src="../images/image-202508260900.png" style="zoom:70%;" />

## n 的 k 阶乘

```c
double Pow(int n, int k) {  // 注意 k 的不同情况
  if (k > 0)
    return n * Pow(n, k - 1);
  else if (k < 0)
    return (1.0 / n) * Pow(n, k + 1);
  else
    return 1;
}
```

## 整除问题

### 描述

输入 n 个正整数，输出其中最小的能整除 3 的数。

### 输入

每行输入包含一组测试数据，包含 N + 1 个整数，之间用空格分隔。 第 1 个整数代表 n（$1 \le N \le 100$），后面 n 个整数是需要统计的数据。

### 输出

如果存在满足条件的数，那么输出该数，如果没有则输出 Null。

### 样例

| 输入       | 输出 |
| ---------- | ---- |
| 4 42 7 6 2 | 6    |
| 4 1 4 7 13 | Null |

### 解析

```C
#include <stdio.h>

int main(void) {
  int arr1[100] = {0};  // 用于存储输入数据的数组 1
  int arr2[100] = {0};  // 用于存储数组 1 中能被整除的元素
  int n = 0;            // 组数 n
  int i = 0;            // 两个用于循环的变量 i 和 j
  int j = 0;
  int min = 0;  // 最小值初始化为 0

  scanf("%d", &n);
  for (i = 0; i < n; i++) {
    scanf("%d", &arr1[i]);
    if (arr1[i] % 3 == 0) {
      // 下标为 j 的数组 2 元素被赋值为能被 3 整除的数组 1 的元素
      arr2[j] = arr1[i];
      j++;  // 存储的元素个数等于 j
    }
  }
  min = arr2[0];  // 假设 arr[0] 是数组的最小值
  // 大于 0 而不是大于等于 0
  // 因为如果在大于 0 时，arr[j] 仍大于 arr[0]
  // 说明 arr[0] 就是最小值，减少 1 次循环
  while (j > 0) {
    // 在数组 2 中最大的数组元素下标为 j - 1，因此从它开始
    if (arr2[j - 1] < min)  
      min = arr2[j - 1];    // 如果更小，则替换
    j--;
  }
  // 非 0 即为真，执行 if 语句；0 即为假，执行 else 语句
  if (min)  
    printf("%d\n", min);
  else
    printf("Null\n");

  return 0;
}
```

## 数字翻转

### 描述

现在有任意两个正整数，问它们两个数翻转的和是否等于两个数的和的翻转。比如 12、34 便满足该条件，即 $12+34=46$，而 $64=21+43$。

### 输入

先输入一个正整数表示将要测试数据的组数 n。每行两个正整数 a 和 b（$0<a,b \le 10000$）。

### 输出

如果满足题目的要求输出 `YES`，否则输出 `NO` 。

### 输入示例

```bash
2

12 34

99 1
```

### 输出示例

```bash
YES

NO
```

### 解析

```C
#include <stdio.h>

int reverse_num(int origal_num)  // 回文数求法
{
  int reverse_num = 0;

  while (origal_num) {
    reverse_num = reverse_num * 10 + origal_num % 10;
    origal_num /= 10;
  }

  return reverse_num;
}

int main(void) {
  int n = 0;
  int i = 0;

  scanf("%d", &n);
  for (i = 0; i < n; i++) {
    int x = 0;
    int y = 0;

    scanf("%d %d", &x, &y);
    if (x + y == reverse_num(reverse_num(x) + reverse_num(y)))  // 题目所述
      printf("YES\n");
    else
      printf("NO\n");
  }

  return 0;
}
```

## 打酱油

### 描述

小明带着 n 元钱去买酱油。酱油 10 块钱一瓶，商家进行促销，每买 3 瓶送 1 瓶，或者每买 5 瓶送 2 瓶。请问小明最多可以得到多少瓶酱油。

### 输入

输入的第一行包含一个整数 n，表示小明可用于买酱油的钱数。n 是 10 的整数倍，n 不超过 300。

### 输出

输出一个整数，表示小明最多可以得到多少瓶酱油。

### 样例

| 输入 | 输出 |
| ---- | ---- |
| 40   | 5    |
| 80   | 11   |

### 解析

```C
#include <stdio.h>

int main(void) {
  int n = 0;  // 钱数
  int a = 0;  // 瓶数

  scanf("%d", &n);
  n /= 10;              // 基本瓶数，没加附赠的
  a = n + (n / 5) * 2;  // 先算 5 瓶的有几组，有几组就几组 * 2
  n %= 5;     // 将 n 赋值为它取模 5 的数，就是除了 5 个 5 个分组，还剩几瓶
  if (n / 3)  // 把剩的几瓶 / 3，就可以看到剩的几瓶至多可以分为几个 3 组了
    a += n / 3;
  printf("%d", a);  // 打印出瓶数

  return 0;
}
```

## 中忍考试

### 描述

正巧今天是鸣人升为中忍的日子，他决定带着他的小伙伴们去一乐大吃一顿庆祝庆祝。

来到一乐门前时，鸣人惊呆了，门前已经排了好几列队伍了，而且每个队伍中的人还都不少。

鸣人已经饿的肚子咕咕叫了，他想知道排哪列队伍可以最快吃上饭。

我们规定排队的人有 3 种，并且每种食物的制作时间都不同。具体如下：

- A 种人：中忍考试没过，一个人伤心的出来吃闷饭，这种人会点 1 碗拉面 + 1 份烤肉 + 1 杯饮料

- B 种人：有说有笑的情侣，两个人都通过了中忍考试，他们会点 2 碗拉面 + 1 份烤肉

- C 种人：一家三口，两个中年人带一个孩子，围观中忍考试的观众，他们会点 3 碗拉面 + 3 份烤肉 + 2 杯饮料

每种食物的制作时间在输入要求中给出。

### 输入

每组第一行输入 4 个正整数 n、l、k、y，n 表示队伍列数，l 表示拉面的制作时间，k 表示烤肉的制作时间，y 表示饮料的制作时间。

所有正整数均在 32 位 `int` 范围内。

接下来 n 行，每行输入一个字符串，表示此列队伍排队情况，

字符串仅由 A、B、C 这三个字母组成，每个字母对应题目描述中的某种人，字符串长度不超过 100。

### 输出

对于每组输入，输出可以让鸣人最快吃上饭的那个队伍的排队时间。

### 样例输入

```bash
3 3 4 1
ABCABC
AACC
ACBAA
```

### 样例输出

```bash
57
```

### 解析

```c
#include <stdio.h>

int main(void) {
  int i = 0;
  int n = 0;
  int l = 0;
  int k = 0;
  int y = 0;
  int min = -1;  // 先定义为 0

  scanf("%d %d %d %d", &n, &l, &k, &y);
  for (i = 0; i < n; i++) {
    int time = 0;
    int j = 0;
    char team[100] = {'\0'};

    scanf("%s", team);  // 输入字符串
    for (j = 0; team[j] != '\0'; j++) {
      if (team[j] == 'A')  // 满足条件就输出按照题述作运算
        time += (l + k + y);
      else if (team[j] == 'B')
        time += (2 * l + k);
      else if (team[j] == 'C')
        time += (3 * l + 3 * k + 2 * y);
    }
    // 如果 min 还为 -1，则将 time 的值赋给 min，因为 time 必大于 0
    if (min > time || min == -1) min = time;
  }
  printf("%d\n", min);

  return 0;
}
```

## 计算电梯时间

### 描述

某城市最高的建筑只有一部电梯。一份电梯升降任务表由 n 个正整数组成，这些数字表示电梯按照给定的顺序停留的楼层号。

电梯升一层花费 6 秒钟，降一层花费 4 秒钟，并且每次停留花费 5 秒钟。

对于每一份任务表，你要计算出完成全部升降任务所花费的总时间。一开始，电梯在第 0 层，并且最终完成任务时电梯不必一定返回到 0 层。

### 输入

第 1 行是一个整数 T，表示随后有 T 组数据。

每组数据包含 1 个正整数 n，以及 n 个正整数。

### 输出

对每组数据，输出总时间，并换行。

### 样例

| 输入  | 输出 |
| ----- | ---- |
| 2     |      |
| 1     |      |
| 2     |      |
| 3     | 17   |
| 2 3 1 | 41   |

### 解析

```C
#include <stdio.h>

int main(void) {
  int T = 0;
  int i = 0;

  scanf("%d", &T);  // T 组数据
  for (i = 0; i < T; i++) {
    int j = 0;
    int N = 0;              // N 个正整数
    int current_floor = 0;  // 初始楼层为 0
    int total_time = 0;

    scanf("%d", &N);
    for (j = 0; j < N; j++) {
      int last_floor = current_floor;  // 定义一个变量存储上一次的楼层数

      scanf("%d", &current_floor);
      if (current_floor > last_floor)  // 用选择语句进行比较，并计算时间
        total_time += (current_floor - last_floor) * 6 + 5;
      else if (current_floor < last_floor)
        total_time += (last_floor - current_floor) * 4 + 5;
    }
    printf("%d\n", total_time);  // 打印出总时间
  }

  return 0;
}
```

## 最大公约数

### 描述

输入两个正整数 m 和 n，输出 m 和 n 的最大公约数。

### 输入

第 1 行是一个整数 T，表示随后有 T 组数据。每组数据占一行，包含两个整数，用空格隔开。

### 输出

对每组数据输出两个整数的最大公约数，并换行。

### 样例

| 输入 | 输出 |
| ---- | ---- |
| 3    |      |
| 2 5  | 1    |
| 4 6  | 2    |
| 3 9  | 3    |

### 解析

```c
#include <stdio.h>

int main(void) {
  int T = 0, i = 0;

  scanf("%d", &T);
  for (i = 0; i < T; i++) {
    int m = 0, n = 0, a = 0;

    scanf("%d %d", &m, &n);
    while (a = m % n) {
      // 通过辗转相除法来求最大公约数，当取模为 0 时跳出循环
      m = n;  // 将 n 赋给 m
      n = a;  // 将取模的结果 a 赋给 n，而后下一次循环计算 n % (m % n) 的结果
    }  // 跳出循环后，此时的除数就是最大公约数
    printf("%d\n", n);
  }

  return 0;
}
```

## 求两个整数之间的倒数和

### 描述

给定两个整数，求解这两个整数范围内的所有整数的倒数的总和。注意遇到整数 0 时，直接加上 0。

### 输入

第 1 行是一个整数 n，表示随后有 n 组数据。每组数据占一行，包含 2 个整数，a、b 用空格隔开。

### 输出

对每组数据输出范围（包含边界整数）之间相应的倒数和，要求保留三位小数，并换行。

### 样例

| 输入 | 输出  |
| ---- | ----- |
| 3    |       |
| 1 1  | 1.000 |
| 2 0  | 1.500 |
| -1 1 | 0.000 |

### 解析

```c
#include <stdio.h>

int main(void) {
  int n = 0, i = 0;

  scanf("%d", &n);
  for (i = 0; i < n; i++) {
    int a = 0, b = 0, min = 0, max = 0;
    float sum = 0.0f;

    scanf("%d %d", &a, &b);
    if (a > b)  // 判断 a、b 是最小值和最大值
      max = a, min = b;
    else
      max = b, min = a;
    while (min <= max) {
      if (min == 0) {  // 当 min 为 0 时，加 1 然后跳过
        min++;
        continue;
      }
      sum += 1.0 / min;
      min++;
    }
    printf("%.3f\n", sum);  // 小数点后 3 位
  }

  return 0;
}
```

## 鸡兔同笼

### 描述

鸡兔同笼，共有 x 个头、y 只脚，求问鸡兔各有几只？（假设鸡兔都是健全的，且 $x,y > 0$）

### 输入

第一行是一个整数 n，表示一共有 n 组测试用例；下面一共有 n 组输入，每组输入为两个正整数，分别表示头和脚的数量，中间用空格隔开。

### 输出

对于每一组输入数据，若数据合理（即有整数解），则分别输出鸡兔的数量，用空格隔开；若输入数据有问题，则输出 `error`；每组输出单独占一行。

### 样例

| 输入 | 输出  |
| ---- | ----- |
| 2    |       |
| 1 1  | error |
| 2 6  | 1 1   |

### 解析

$$
\begin{cases}
r+c=x\\
4r+2c=y
\end{cases}
$$

由此，得到：

$$
\begin{cases}
2r=y-2x\\
c=x-r
\end{cases}
$$

可知：

```c
#include <stdio.h>

int main() {
  int n = 0;

  scanf("%d", &n);
  while (n)  // 用 n，减少一个变量 i 的创建
  {
    int x = 0, y = 0;

    scanf("%d %d", &x, &y);
    // 由方程可知，该值必须为偶数和非负整数
    if ((y - 2 * x) % 2 != 0 || y - 2 * x < 0)
      printf("error\n");
    else {
      int r = (y - 2 * x) / 2;  // 定义兔子为 r，鸡为 c
      int c = x - r;            // 两式皆由公式而来

      if (r >= 0 && c >= 0)
        printf("%d %d\n", c, r);  // 两个数都大于 0
      else
        printf("error\n");  // 不符不输出
    }
    n--;
  }

  return 0;
}
```

## 第二小的整数

### 描述

找出整数序列中第二小的数。

### 输入

第 1 行是一个整数 n，表示随后有 n 组数据。每组数据占一行，第一个整数 m，$1 \leq m \leq 100$，表示随后有 m 个整数。

### 输出

对每组数据，输出第二小的数。如果第二小的数不存在，则输出 `ERROR`。

### 样例

输入：

```bash
4
7 3 1 2 4 5 6 7
4 5 5 8 13
1 2
4 3 3 3 3
```

输出：

```bash
2
8
ERROR
ERROR
```

### 解析

```c
#include <stdio.h>

int main(void) {
  int n = 0;

  scanf("%d", &n);
  while (n) {
    int m = 0, i = 0, min_2 = 0, arr[100] = {0};

    scanf("%d", &m);
    for (i = 0; i < m; i++) {
      scanf("%d", &arr[i]);
    }
    for (i = 0; i < m - 1; i++) {  // 用排序算法对数组内元素从小到大进行排序
      int j = 0;

      for (j = 0; j < m - 1 - i; j++) {
        if (arr[j + 1] < arr[j]) {
          int temp = arr[j + 1];

          arr[j + 1] = arr[j];
          arr[j] = temp;
        }
      }
    }
    min_2 = arr[0];  // 假定 min_2 的值为最小值
    for (i = 0; i < m; i++) {
      if (arr[i] != arr[0]) {
        min_2 = arr[i];  // 找到第一个不等于最小值的数,赋给 n_2
        break;
      }
    }
    if (min_2 == arr[0])  // 如果还是等于最小值，输出 ERROE
      printf("ERROR\n");
    else
      printf("%d\n", min_2);
    n--;
  }

  return 0;
}
```

## 统计二进制中 1 的个数

写一个函数返回参数二进制中 1 的个数。

比如：15,0000,1111，4  个 1。

```c
// 方法 1，但是负数不可以
#include <stdio.h>

int count_num_of_1(int num) {
  int count = 0;

  while (num) {
    if (num % 2 == 1) count++;
    num /= 2;
  }

  return count;
}

int main(void) {
  int num = 0, n = 0;

  scanf("%d", &num);
  n = count_num_of_1(num);
  printf("%d\n", n);

  return 0;
}
```

```c
// 方法 1（升级版）
int count_num_of_1(unsigned int num) {
  // 进行小的改造，将有符号数转换为无符号数
  // 比如 -1，此时在函数中就被当成一个非常大的正数来进行计算
  int count = 0;  // 虽然传的是有符号数，但是形参被当成无符号数来传参

  while (num) {
    if (num % 2 == 1) count++;
    num /= 2;
  }

  return count;
}
```

```c
// 方法 2
int count_num_of_1(int num) {
  int i = 0, count = 0;

  // 进行按位与 1 的操作，如果 LSB 是 1，就 ++
  // 每一次右移操作都会更新 LSB 来进行关系运算
  for (i = 0; i < 32; i++) {
    if ((num >> i) & 1 == 1) count++;
  }

  return count;
}
```

在介绍方法 3 前，先介绍：

```bash
n = 15;
n = n & (n - 1);
1111 n
1110 n - 1
1110 n
1101 n - 1
1100 n
1011 n - 1
1000 n
0111 n - 1
0000
```

上述方法可以看出 `n & (n - 1)` 的效果，当计算一次该式，就会使二进制数字的 1 少一个，循环的次数与 1 的个数相等，直至算到 0。

这个式子是通过借位来实现少 1 的。

**最优解**，因此有：

```c
// 方法 3
int c_count_num_of_1(int num) {
  int count = 0;

  while (num) {
    num = num & (num - 1);  // 计算该式
    count++;                // 个数加一
  }

  return count;
}
```

同时，该式可以判断一个数是否为 $2^n$，因为：

```bash
2 10
4 100
8 1000
16 10000
```

由此可知，在 $2^n$ 中只有一位是 1，因此：

```c
if (n & (n - 1) == 1) {}
```

可以写出这样的代码。

## 打印“X”图案

```c
#include <stdio.h>

int main(void) {
  int n = 0, i = 0;

  // 这样可以满足多组输入，这是一种写法
  while (scanf("%d", &n) == 1) {
    for (i = 0; i < n; i++) {
      int j = 0;

      for (j = 0; j < n; j++) {
        if (i == j || i == n - 1 - j)
          printf("*");
        else
          printf(" ");
      }
      printf("\n");
    }
  }

  return 0;
}
```

<img src="../images/image-202311041136.png" style="zoom:80%;" />

## 伪回文数

### 描述

输入一个正整数， 判断它是不是一个伪回文数。（回文数是顺着看和倒着看都一样的数，例如 `1221`，`12321` 都是回文数，伪回文数是改动一个数字就能变成回文数的数，1 位数不是伪回文数）

### 输入

第一行输入一个正整数 n，表示下面有 n 组数据。每组数据为一个正整数，能够用 `int` 保存，占用一行。

### 输出

对于每组数据，若是伪回文数，输出 `yes`，否则输出 `no`。

### 样例

输入：

```shell
2
122
12321
```

输出：

```bash
yes
no
```

### 解析

```c
#include <stdio.h>

int isPseudoPalindrome(int num)  // 定义一个函数来判断伪回文数
{
  int orignal = num;    // 原始的数
  int reverse = 0;      // 反转的数
  int differCount = 0;  // 不同位的个数

  while (num)  // 回文数求法，不再赘述
  {
    reverse = reverse * 10 + num % 10;
    num /= 10;
  }
  if (orignal == reverse)  // 为回文数必不为伪回文数
    return 0;              // 返回 0 代表假
  else {
    while (orignal) {
      if (orignal % 10 != reverse % 10)
        differCount++;  // 计算反转数与原数不同位的个数
      orignal /= 10;
      reverse /= 10;
    }
  }  // 值得注意的是，举例 122、221，一共有两个不同的位
  if (differCount == 2)  // 因此当不同位的个数为 2 时，返回 1，代表真
    return 1;
  else
    return 0;
}

int main(void) {
  int n = 0;

  scanf("%d", &n);
  while (n--) {
    int num = 0;

    scanf("%d", &num);
    if (isPseudoPalindrome(num))  // 调用函数，真则打印 yes，假则打印 no
      printf("yes\n");
    else
      printf("no\n");
  }
  return 0;
}
// 扩展：在 C++ 中有动态数组的概念，可以利用动态数组来解决该问题
```

## 找子串

### 描述

请在输入的一段字符串里面查找给定的子串，找到后用 `/* */` 注释起来再输出。子串不区分大小写，即 `one`、`One` 和 `ONE` 是同一个子串。另外子串不会重叠出现。

### 输入

每个输入包含一个测试数据，第一行输入一行待查找的字符串，以回车结束。

第二行输入要查找的子串，以回车结束。字符串最长长度不超过 100100。

### 输出

如果找到子串，则在子串前面加 `/*`，后面加上 `*/`， 把子串(保持原样)注释起来再输出。没有找到就输出原字符串。

### 样例 1

#### 输入

```shell
You are the best!
are
```

#### 输出

```sh
You /*are*/ the best!
```

### 样例 2

#### 输入

```bash
You are the best!
E
```

#### 输出

```bash
You ar/*e*/ th/*e*/ b/*e*/st!
```

### 解析

```c
#include <stdio.h>
#include <string.h>

int main(void) {
  int i = 0, j = 0;
  char str1[100] = {0};
  char str2[100] = {0};

  fgets(str1, 100, stdin);
  fgets(str2, 100, stdin);
  str1[strlen(str1) - 1] = '\0';  // 去掉末尾的 '\n'
  str2[strlen(str2) - 1] = '\0';  // 去掉末尾的 '\n'

  int len1 = strlen(str1);
  int len2 = strlen(str2);

  while (i < len1) {
    if (strncasecmp(&str1[i], str2, len2) == 0) {
      printf("/*%.*s*/", len2, &str1[i]);
      i += len2;
    } else {
      printf("%c", str1[i]);
      i++;
    }
  }

  return 0;
}
```

## 今天星期几

### 描述

已知 1900 年 1 月 1 日是星期一，问这天之后的任意一天是星期几？

### 输入

1900 年 1 月 1 日以后的任一合法日期，格式为 yyyy-MM-dd，如 2000-01-01。

### 输出

输入日期所对应的星期。

### 样例

#### 输入

```bash
2017-11-11
```

#### 输出

```sh
Saturday
```

### 解析

```c
#include <stdio.h>

int zeller(int year, int month, int day) {  // 蔡勒公式
  if (month == 1 || month == 2) {  // 将 1 月和 2 月当成上一年的 13、14 月
    month += 12;
    year--;
  }

  int c = year / 100;  // c 代表世纪数
  int y = year % 100;  // 代表后两位数，如 1949 年中的 49 年
  int m = month;       // 月份
  int d = day;         // 日期
  int w = y + y / 4 + c / 4 - 2 * c + 26 * (m + 1) / 10 + d - 1;  // 星期几为w%7

  if (w < 0)  // 对负数的取模运算
    w = (w % 7 + 7) % 7;
  else
    w %= 7;

  return w;
}

int main(void) {
  int year = 0, month = 0, day = 0;

  scanf("%d-%d-%d", &year, &month, &day);

  char *week[] = {"Sunday",   "Monday", "Tuesday", "Wednesday",
                  "Thursday", "Friday", "Saturday"};
  int result = zeller(year, month, day);

  printf("%s\n", week[result]);

  return 0;
}
```

$$
w = \left(\left[\frac{c}{4}\right] - 2c + y + \left[\frac{y}{4}\right] + \left[\frac{13 \times (m + 1)}{5}\right] + d - 1 \right) \text{MOD7}
$$

## 喝汽水

喝汽水，1 瓶汽水 1 元，2 个空瓶可以换一瓶汽水，给 20 元，可以喝多少瓶汽水？

```c
#include <stdio.h>

int main(void) {
  int money = 0;

  scanf("%d", &money);

  int total = money;
  int empty = money;

  while (empty / 2) {    // 当空瓶数大于 1 时才可以换
    total += empty / 2;  // 剩的空瓶每两个换汽水，喝的汽水增加
    // 剩下的空瓶等于把上次剩的两个两个换了的加上没换的
    empty = empty / 2 + empty % 2;
  }
  printf("%d\n", total);  // 打印出总瓶数

  return 0;
}
```

## N 皇后问题

### 描述

N 皇后问题是一个经典的问题，描述如下：在 $N \times N$ 的方格棋盘需要放置 n 个皇后，使得它们不相互攻击，即任意 2 个皇后不允许处在同一排、同一列，也不允许处在与棋盘边框成 45 度角的斜线上。

对于给定的 n，请输出有多少种合法的放置方法。

### 输入

多组数据，每组数据格式如下：

每行一个正整数 n（$0 < N \leq 10$），表示棋盘和皇后的数量。

### 样例

#### 输入

```bash
8
```

#### 输出

```bash
92
```

### 解析

```c
#include <stdio.h>

#define MAX_N 10

int count = 0;  // 计数器

// 这是一个判断是否可以放置的函数
int is_safe(int board[MAX_N][MAX_N], int row, int col, int N) {
  int i = 0, j = 0;  // 循环变量

  for (i = 0; i < row; i++)  // 判断元素所在的这一列是否有皇后
    if (board[i][col] == 1) return 0;

  // 判断左上角对角线是否有皇后
  for (i = row, j = col; i >= 0 && j >= 0; i--, j--)
    if (board[i][j] == 1) return 0;

  // 判断右上角对角线是否有皇后
  for (i = row, j = col; i >= 0 && j < N; i--, j++)
    if (board[i][j] == 1) return 0;

  return 1;  // 没有，说明可以放，返回 1
}

void solve_NQueens(int board[MAX_N][MAX_N], int row, int N) {
  int i = 0;  // 循环变量

  if (row == N) {
    // 如果所有行都被遍历过了，说明找到一种解法，++count
    ++count;
    return;
  }

  for (i = 0; i < N; i++)             // 遍历该行所有列
    if (is_safe(board, row, i, N)) {  // 安全，可以放置
      board[row][i] = 1;              // 放置
      // 这一行没得放了，进入下一行
      solve_NQueens(board, row + 1, N);
      // 该种方法无论可行与否都将此位置重新设为 0，进行下一种方案的讨论
      board[row][i] = 0;
    }
}

int main(void) {
  int N = 0;
  int board[MAX_N][MAX_N] = {0};

  while (scanf("%d", &N) != EOF) {
    count = 0;
    solve_NQueens(board, 0, N);
    printf("%d\n", count);
  }

  return 0;
}
```

**举例**：2 个 N 皇后，第一个放在第一行第一列，而后进入递归；检测第二行第一列，不能放置；检测第二行第二列，不能放置；此时 row 等于 1，那个判断条件也不满足，该方案失败。退出递归后，将该位置设为 0，进行下一列的判断。可知每一个可行方案第一行必有一个 N 皇后，所以每一次递归都从第一行开始。

## 字符串逆序

### 输入

```sh
I like Beijing.
```

### 输出

```sh
Beijing. like I
```

### 解析

```c
#include <stdio.h>
#include <string.h>

void swap(char *a, char *b) {  // 交换两个字符
  char temp = *a;

  *a = *b;
  *b = temp;
}

void reverse(char *leaf, char *right) {
  // 逆序字符串用的函数
  while (leaf < right) {
    swap(leaf, right);
    leaf++, right--;
  }
}

int main(void) {
  char str[101] = {0};  // 定义一个 101 大小的字符数组来放置

  fgets(str, 100, stdin);  // 输入字符串
  str[strcspn(str, "\n")] = '\0';

  int len = strlen(str);        // 计算字符串的大小
  char *leaf = str;             // 定义整个字符串的左下标
  char *right = &str[len - 1];  // 右下标

  reverse(leaf, right);  // 逆序整个字符串

  char *start = str;  // 将子串的左下标定义为 str[0] 的地址

  while (*start)  // 当首元素的地址不为 0 时，进行循环
  {
    char *end = start;  // 定义右下标开始与左下标相同

    // 当右下标不为 0 或者空格时，end++
    while (*end != ' ' && *end != '\0') end++;
    // 跳出循环，说明此时 end 指向的不为字符，end - 1 为子串最后一个字符
    reverse(start, end - 1);
    // 如果此时 end 指向的不为字符串结束标志，那就进行下一个单词的逆序
    if (*end != '\0') end++;
    start = end;  // 将 start 赋值为 end
  }
  printf("%s\n", str);

  return 0;
}
```

## 字符串排序

### 描述

输入一串字符串，按字母顺序的顺序将它们排序输出。

### 输入

输入多组测试数据（每组测试数据占一行），每组数据为一个字符串。

### 输出

当输入的字符串包含数字和字母之外的字符时，输出 `Input Error`。否则，分别输出排序前后的字符串（排序的顺序为 0～9、A～Z、a～z），换行输出。特别地，当输入为 `exit` 时，输出 `End Of Input`，测试结束。

### 样例

<img src="../images/image-202311211815.png" style="zoom: 70%;" />

### 解析

```c
#include <ctype.h>  // 判断字符类型的函数所需的头文件
#include <stdio.h>
#include <string.h>

void swap_ch(char *a, char *b) {  // 交换字符的函数
  char temp = *a;

  *a = *b;
  *b = temp;
}

// 冒泡排序，因为这些字符在 ASCII 码中都是有序排放
void bubble_sort_ch(char str[], int len) {
  int i = 0, j = 0;

  for (i = 0; i < len - 1; i++) {
    for (j = 0; j < len - 1 - i; j++) {
      if (str[j] > str[j + 1]) swap_ch(&str[j], &str[j + 1]);
    }
  }
}

int main(void) {
  int flag = 1;  // 判断是否有输入错误的变量
  char str1[100000] = {0};
  char str2[100000] = {0};

  while (1) {
    int i = 0;

    fgets(str1, 100000, stdin);  // 输入的函数

    // 因为末尾的 '\n' 也会进去，所以换成结束标志
    // 而 strcspn 是找相应字符位置的函数
    str1[strcspn(str1, "\n")] = '\0';
    // 便历整个数组 1
    for (i = 0; i < strlen(str1); i++) {
      if (isalnum(str1[i]) == 0)  // 发现不符字符，将判断的那个变量赋值为 0
        flag = 0;
    }
    if (strcmp(str1, "exit") == 0) {
      // 判断这个字符是否和退出字符相等
      printf("End Of Input\n");
      break;
    } else if (flag == 0) {  // 判断输入对错
      printf("Input Error\n");
      flag = 1;  // 重新定义为 1，进行下一次循环
      continue;  // 跳过下列循环
    }
    // 将字符串 1 拷贝到字符串 2
    strcpy(str2, str1);
    // 将字符串 2 的顺序给排了
    bubble_sort_ch(str2, strlen(str2));
    printf("%s\n%s\n", str1, str2);  // 输出
  }

  return 0;
}
```

## 字符串匹配

### 描述

给定字符串 a 和字符串 b，求字符串 b 第一次在字符串 a 中出现的位置。（字符串长度不超过 1000 个字符）

### 输入

第 1 行是一个整数 n，表示有 n 组测试数据，接着是各组测试数据的字符串 a 和字符串 b。

### 输出

对每组测试数据输出字符串 b 第一次出现在字符串 a 中的位置，并换行。

### 样例

<img src="../images/image-202311212308.png" style="zoom:70%;" />

### 解析

```c
#include <stdio.h>
#include <string.h>

int main(void) {
  int i = 0, n = 0;
  char str1[1001] = {0};
  char str2[1001] = {0};

  scanf("%d", &n);
  for (i = 0; i < n; i++) {
    scanf("%s %s", str1, str2);
    //  strstr 函数返回在 str1 找到的第一个的 str2 的首字符地址
    printf("%d\n", strstr(str1, str2) - str1 - 1);
  }
  // 将该首字符地址减去 str1 的首字符地址再减去 1，就是它所谓的在 str1 的位置

  return 0;
}
```

## 倒序打印字符串

### 描述

给你一个长度 $\leq 100$ 的字符串，倒序打印它。**以 `"]"` 结束, `"]"` 不需要打印。**

包括数字（0～9），字母（'A'～'Z'，'a'～'z'），空白（换行 `'\n'` 以及空格）。

### 输入

一个长度 $\leq 100$ 的字符串。

### 输出

倒序输出字符串。

### 样例

<img src="../images/image-202311212313.png" style="zoom:70%;" />

### 解析

```c
#include <stdio.h>
#include <string.h>

int main(void) {
  int i = 0;
  char ch = '\0';
  char str[101] = {0};

  while ((ch = getchar()) != ']') {
    str[i] = ch;  // 将该字符赋给字符串中的相应
    ++i;          // 下标 ++，看下一个元素
  }
  for (i = strlen(str) - 1; i >= 0; i--) {
    printf("%c", str[i]);
  }

  return 0;
}
```

## 字符串合并

### 描述

现有两个字符串，请将两个字符串中的非数字和非字母的字符去掉，并将剩下的字符串合并成一个新的有序（按照 ASCII 码序升序）字符串，并打印合并后的字符串。

> **注意**：输入的每个字符串中不包含换行符、空白符或缩进符

### 输入

两个字符串。

### 输出

合并后的字符串。

### 样例 1

<img src="../images/image-202311212316.png" style="zoom:80%;" />

### 样例 2

<img src="../images/image-202311212317.png" style="zoom: 80%;" />

### 答案

```c
#include <ctype.h>
#include <stdio.h>
#include <string.h>

void swap_ch(char *a, char *b) {
  char temp = *a;

  *a = *b;
  *b = temp;
}

void bubble_sort_ch(char str[], int len) {
  int i = 0, j = 0;

  for (i = 0; i < len - 1; i++) {
    for (j = 0; j < len - 1 - i; j++) {
      if (str[j] > str[j + 1]) swap_ch(&str[j], &str[j + 1]);
    }
  }
}

int main(void) {
  int i = 0, j = 0;
  char str1[10001] = {0};
  char str2[10002] = {0};

  fgets(str1, 10001, stdin);
  str1[strcspn(str1, "\n")] = '\0';
  for (i = 0; i < strlen(str1); ++i) {
    if (isalnum(str1[i])) {  // 判断该字符是否符合
      str2[j] = str1[i];     // 若符合放在数组 2，同时数组 2 的下标 ++
      ++j;
    }
  }
  bubble_sort_ch(str2, strlen(str2));  // 排序字符串
  printf("%s\n", str2);

  return 0;
}
```

## 奇偶数交换

```c
#include <stdio.h>

void move_arr(int arr[], int sz) {
  // 交换奇偶位置的函数，将奇数放在数组前面，偶数放在数组后面
  int l = 0, r = sz - 1;  // 定义左右下标

  // 当左下标小于右下标时，执行循环
  while (l < r) {
    // 之所以加上 l < r 的条件是为了防止数组越界
    while (l < r && arr[l] % 2 == 1) {
      l++;  // 取模为 1 的时候，说明该元素是奇数，可以放在前面，那就跳过
    }  // 循环停止的时候，说明遇到偶数了
    while (l < r && arr[r] % 2 == 0) {  // 右下标，同理
      r--;
    }

    if (l < r) {  // 交换这两个元素
      int tmp = arr[l];
      arr[l] = arr[r];
      arr[r] = tmp;
      l++, r--;  // 交换完后进入下一个元素的交换
    }
  }
}

int main(void) {
  int i = 0;
  int arr[10] = {0};
  int sz = sizeof(arr) / sizeof(arr[0]);

  for (i = 0; i < sz; i++) {
    scanf("%d", arr + i);
  }

  move_arr(arr, sz);
  for (i = 0; i < sz; i++) {
    printf("%d ", arr[i]);
  }

  return 0;
}
```

<img src="../images/image-202311271750.png" style="zoom:80%;" />

## 二义性编码

### 描述

有一个消息包含 A～Z，消息通过以下规则编码：

```bash
A -> 1
B -> 2
...
Z -> 26
```

给你一个加密过后的信息，求有多少种解码方式。（加密过后的信息不超过 70 个字符）

### 输入

第 1 行是一个整数 n，表示有 n 组测试数据，接着是各组测试数据的字符串。

### 输出

对每组测试数据输出解码方式。

2 因为 12 代表有（AB、L）2 中解码方式。

### 样例

| 输入 | 输出 |
| ---- | ---- |
| 2    |      |
| 12   | 2    |
| 123  | 3    |

### 解析

```c
#include <stdio.h>
#include <string.h>

int num_decoding(char *str) {
  int i = 0;
  int len = strlen(str);
  // 该数组存储到第 i 个位置时（注意：不是 i - 1）
  // 前 i 个元素解码方式的个数
  int dp[71] = {0};
  // i = 0，为空字符串，假设空字符串有一种解码方式（便于解体）
  dp[0] = 1;
  // 第一个字符的解码方式先假设为 1（不管第 1 个字符是否为 '0'）
  dp[1] = 1;
  // 当字符串为空字符串或者第一个字符为字符 '0'
  if (len == 0 || str[0] == '0') return 0;  // 0 种解码方法
  // 如果第一个字符有解码方式，那就从第二个字符开始计算数量
  for (i = 2; i <= len; i++) {
    // 定义一位数，存储当前位置的数字字符转换的数值
    int one_digit = str[i - 1] - '0';
    // 定义两位数，存储当前位置和前一个位置组成转换后的数值
    int two_digit = (str[i - 2] - '0') * 10 + one_digit;
    // 注意：dp[i] 代表第 i 个位置，str[i - 1] 代表第 i 个位置

    if (one_digit >= 1) {  // 当这个数大于 1 时

      // 如果当前位置满足一个数的解码方式，那么它与前 n 个数
      // 说明它至少有与前一位的数共组的 dp[i - 1] 种解码方式
      dp[i] += dp[i - 1];
    }
    // 当这个数大于 10 且小于 26 时
    // 如果当前位置和前一个位置满足两个数的解码方式
    // 说明它至少有与前两位的数共组的 dp[i - 2] 种解码方式
    // 此时要把当前位置的字符与前一个位置的字符当成一个整体来与前面的字符组成新的解码方式
    if (two_digit >= 10 && two_digit <= 26) {
      dp[i] += dp[i - 2];
    }
  }

  return dp[len];
}

int main(void) {
  int n = 0, i = 0;
  char str[71] = {0};

  scanf("%d", &n);
  for (i = 0; i < n; i++) {
    scanf("%s", str);
    printf("%d\n", num_decoding(str));
  }

  return 0;
}
```

## 考试成绩单

### 描述

有 n 个学生成绩信息（包括学号、姓名、语文成绩、英语成绩、数学成绩、总成绩）要求算出总成绩、并按照总成绩排名输出，总成绩相同，按照姓名的字典序输出。

定义结构体入下：

```c
struct student {
  char name[21];   // 姓名
  int sno;         // 学号
  double chinese;  // 语文
  double english;  // 英语
  double math;     // 数学
  double sum;      // 总成绩
};
```

### 输入

第 1 行是一个整数 n，表示有 n 个学生信息，接着是各个学生的信息。（学生信息按照姓名，学号，语文成绩、英语成绩、数学成绩的顺序输入，各个数据之间空格隔开）

### 输出

学生信息排序之后输出。

### 样例

<img src="../images/image-202312052020.png" style="zoom:80%;" />

### 解析

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct student {
  char name[21];
  int sno;
  double chinese;
  double english;
  double math;
  double sum;
};  // 题目给定的结构体

// qsort 所需的比较函数
int cmp_struct(const void *e1, const void *e2) {
  // 将强制类型转换后的值赋给新的变量
  struct student *stu1 = (struct student *)e1;
  struct student *stu2 = (struct student *)e2;

  // 当两者的总分不相等时
  // 当前者小于后者，返回 -1，代表降序，因为返回 1 代表升序
  if (stu1->sum != stu2->sum) {
    return stu1->sum - stu2->sum > 0 ? -1 : 1;
  } else {
    // 两者相等，返回那个字符串比较
    return strcmp(stu1->name, stu2->name);
  }  // strcmp 可以通过姓名字典序来排，若前者大于后者，返回 1
     // 前者小于后者，返回 -1
}

int main(void) {
  int n = 0;
  int i = 0;
  struct student s[10000];

  scanf("%d", &n);
  for (i = 0; i < n; i++) {
    scanf("%s %d %lf %lf %lf",
          s[i].name,  // 注意第一个输入的元素是字符串
          &s[i].sno,  // 其余要进行取地址操作
          &s[i].chinese, &s[i].english, &s[i].math);
    s[i].sum = s[i].chinese + s[i].english + s[i].math;  // 算出总数
  }

  qsort(s, n, sizeof(s[0]), cmp_struct);  // 用 qsort 函数进行排序
  for (i = 0; i < n; i++) {
    // 打印
    printf("[name:%s,sum:%d,sno:%d]\n", s[i].name, (int)s[i].sum, s[i].sno);
  }

  return 0;
}
```

## 求给定范围内的素数

### 描述

输入一个正整数 n，求出小于等于该正整数的所有素数。

### 输入

正整数（$n \leq 10000$）。

### 输出

小于等于输入整数 n 所有素数，每个素数之间以空格分割，输出结束后换行。

<img src="../images/image-202312052037.png" style="zoom:80%;" />

### 解析

```c
#include <math.h>
#include <stdbool.h>
#include <stdio.h>

bool is_prime(int num) {
  int i = 2;

  for (i = 2; i <= sqrt(num); i++) {
    // 如果这个数不是素数
    // 它的其中一个因子必小于等于它的平方根
    if (num % i == 0)  // 如果存在一个数使得这个数能不被整除
      return false;    // 该数不是素数
  }

  return true;  // 否则该数是素数
}

int main(void) {
  int i = 0;
  int n = 0;

  scanf("%d", &n);
  for (i = 2; i <= n; i++) {
    if (is_prime(i)) printf("%d ", i);
  }
  printf("\n");

  return 0;
}
```

### 拓展

质数又称素数。一个大于 1 的自然数，除了 1 和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数（规定 1 既不是质数也不是合数）。

## 字符串排序

### 描述

输入 4 个字符串，先将它们排序输出；再输入一个字符串，重新排序输出。

### 输入

先输入 4 个字符串，然后再输入一个字符串，将 5 个字符串重新排序并输出。

> **注意**：每个字符串占一行，且每个字符串不大于 20 个字符。

### 输出

将先输入的 4 个字符串按 ASCII 码顺序排序并输出；再将插入新字符串后的 5 个字符串排序并输出。

> **注意**：插入前后的字符串空一行。

## 样例

<img src="../images/image-202312071932.png" style="zoom:67%;" />

### 解析

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int cmpStr(const void *e1, const void *e2) {
  // 这个比较函数传进去的是数组每个元素的地址
  // 而每个元素又是一个地址，所以这个指针要被强制类型转换为二级指针，然后解引用得到每个字符串的首元素地址
  // 之后作为参数输入strcmp函数进行比较
  return strcmp(*(char **)e1, *(char **)e2);
}

int main(void) {
  char str1[21] = {0};
  char str2[21] = {0};
  char str3[21] = {0};
  char str4[21] = {0};
  char str5[21] = {0};
  char *arr[5] = {str1, str2, str3, str4, str5};

  for (int i = 0; i < 4; i++) {
    scanf("%s", arr[i]);
  }

  qsort(arr, 4, sizeof(arr[0]), cmpStr);
  for (int i = 0; i < 4; i++) {
    printf("%s\n", arr[i]);
  }
  printf("\n");

  scanf("%s", arr[4]);
  qsort(arr, 5, sizeof(arr[0]), cmpStr);
  for (int i = 0; i < 5; i++) {
    printf("%s\n", arr[i]);
  }

  return 0;
}
```

## 猜名次

题目内容：

5 位运动员参加了 10 米台跳水比赛，有人让他们预测比赛结果：

- A 选手说：B 第二，我第三

- B 选手说：我第二，E 第四

- C 选手说：我第一，D 第二

- D 选手说：C 最后，我第三

- E 选手说：我第四，A 第一

比赛结束后，每位选手都说对了一半，请编程确定比赛的名次。

```c
#include <stdio.h>

int main(void) {
  int a = 0;
  int b = 0;
  int c = 0;
  int d = 0;
  int e = 0;

  for (a = 1; a <= 5; a++) {
    for (b = 1; b <= 5; b++) {
      for (c = 1; c <= 5; c++) {
        for (d = 1; d <= 5; d++) {
          for (e = 1; e <= 5; e++) {
            if ((b == 2) + (a == 3) == 1 && ((b == 2) + (e == 4) == 1) &&
                ((c == 1) + (d == 2) == 1) && ((c == 5) + (d == 3) == 1) &&
                ((e == 4) + (a == 1) == 1)) {
              if (a * b * c * d * e == 120) {
                printf("a = %d, b = %d, c = %d, d = %d, e = %d\n", a, b, c, d,
                       e);
              }
            }
          }
        }
      }
    }
  }

  return 0;
}
```

运用穷举法，把每种情况列举出来。外层的那个 `if` 语句可以判断一半真并且一半假（因为如果两个都为真，放回 2；都为假，返回 0）；但是还有一些重复名次的情况，因此再加上一个判断条件（`a * b * c * d *e` 等于 `1 * 2 * 3 * 4 * 5`）。

## 猜凶手

题目内容：

日本某地发生了一件谋杀案，警察通过排查确定杀人区手必为 4 个嫌疑犯的一个，以下为 4 个嫌疑们的供词：

- A 说：不是我
- B 说：是 C
- C 说：是 D
- D 说：C 在胡说

已知 3 个人说了真话，1 个人说的是假话，现在请根据这些信息写一个程序来确定到底谁是凶手。

```c
#include <stdio.h>

int main(void) {
  int killer = 0;

  for (killer = 'a'; killer <= 'd'; ++killer) {
    if ((killer != 'a') + (killer == 'c') + (killer == 'd') + (killer != 'd') ==
        3) {
      printf("%c", killer);
    }
  }

  return 0;
}
```

## 杨辉三角

```c
#include <stdio.h>

#define MAX_LEN 10

int main(void) {
  int arr[MAX_LEN][MAX_LEN] = {0};
  int n = 0;

  scanf("%d", &n);

  for (int i = 0; i < n; i++) {
    for (int j = 0; j <= i; j++) {
      if (j == 0 || j == i) {
        arr[i][j] = 1;
      } else {
        arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1];
      }
    }
  }

  for (int i = 0; i < n; i++) {
    for (int j = 0; j <= i; j++) {
      printf("%-4d", arr[i][j]);
    }
    printf("\n");
  }

  return 0;
}
```

## 左旋字符串

## 只出现两次的数

### 描述

输入 n 个整数，找出输入的整数中只出现 22 次的数。

### 输入

每个输入包含一个测试用例，第 1 行输入整数 n ($1≤n≤20$)；第 2 行输入 n 个整数，之间用空格分隔。

### 输出

输出只出现 2 次的整数，存在多个则用空格分隔，按首次出现的顺序输出。如果没有，则输出 `none`。

#### 样例 1

**输入**：

```sh
5
5 2 3 4 3
```

**输出**：

```bash
3
```

#### 样例 2

**输入**：

```bash
6
2 3 3 2 5 6
```

**输出**：

```bash
2 3
```

#### 样例 3

**输入**：

```bash
4
3 4 5 6
```

**输出**：

```bash
none
```

#### 答案

```c
#include <stdio.h>

int main(void) {
  int flag = 1;
  int n = 0;
  int count[21] = {0};

  scanf("%d", &n);
  int arr[n];

  for (int i = 0; i < n; ++i) {
    scanf("%d", &arr[i]);
    count[arr[i]]++;
  }

  for (int i = 1; i <= n; ++i) {
    if (count[i] == 2) {
      printf("%d ", i);
      count[i] = 0;
      flag = 0;
    }
  }

  if (flag) {
    printf("none\n");
  } else {
    printf("\n");
  }

  return 0;
}
```
