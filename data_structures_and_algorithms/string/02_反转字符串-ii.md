# 反转字符串 II

## 题目

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

**示例 1**：

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

**示例 2**：

```
输入：s = "abcd", k = 2
输出："bacd"
```

**提示**：

- `1 <= s.length <= 104`
- `s` 仅由小写英文组成
- `1 <= k <= 104`

## 思路

该题也是模拟，实现题目中规定的反转规则即可。

无需通过计数器来统计 `2 * k` 个字符，只需在遍历字符串时，让 `i += 2 * k` 即可，然后判断是否有需要反转的区间。

因此找的是每 `2 * k` 大小的区间的起点。

**所以需要按照固定规律一段一段地处理字符串时，要思考在 `for` 循环的表达式上进行操作。**

Go 语言代码如下：

```go
func reverseStr(s string, k int) string {
	bytes := []byte(s)
	n := len(s)
	for i := 0; i < n; i += 2 * k {
		end := i + k
		if end > n {
			end = n
		}
		reverse(bytes[i:end])
	}
	return string(bytes)
}

func reverse(s []byte) {
	left := 0
	right := len(s) - 1
	for left < right {
		s[left], s[right] = s[right], s[left]
		left++
		right--
	}
}
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`

