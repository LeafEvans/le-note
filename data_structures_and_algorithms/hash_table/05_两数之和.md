# 两数之和

## 题目

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出**和为目标值** *`target`* 的那**两个**整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

**示例 1**：

```sh
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2**：

```sh
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3**：

```sh
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示**：

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

**进阶**：你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？

## 思路

简单解法是使用两层 `for` 循环查找，时间复杂度为 `O(n^2)`。

**什么时候使用哈希表？**

当需要查询一个元素是否出现过，或一个元素是否在集合中时，需要第一时间想到哈希表。

本题中需要一个集合存放遍历过的元素，然后遍历数组时去询问该集合某元素是否遍历过，也即是是否出现在这个集合。

此时使用哈希法。

本题不仅需要知道元素是否有遍历过，而且也需要知道其对应的下标，**因此使用键值对结构存放**，key 存放元素，value 存放下标，使用 map 数据结构。

使用数组及 set 做哈希法的缺陷：

- 数组大小受限，而且元素很少、哈希值过大会造成内存空间的浪费。
- set 是一个集合，里面放的元素只能是一个 key，而该题目不仅需要判断 `complement` 是否存在，还需要记录 `complement` 的下标，因此 set 也无法使用。

而后明确两点：

- map 用来做什么？
- map 中的 key 和 value 分别表示什么？

map 目的是用来存放访问过的元素，因为遍历数组时，需要记录之前遍历元素的值以及其下标，这样才可找到与当前元素匹配的（即相加等于 `target`）。

为了快速判断某个元素是否已在数组中出现过，我们可以将数组元素作为键（key），其对应的下标作为值（value），存入哈希表（map）中。 

因此，map 的结构为：{ 元素值 → 对应下标 }。

在遍历数组时，对于当前元素，我们检查 map 中是否存在一个键，使得它与当前元素构成目标匹配（例如两数之和等于目标值）。  
- 如果存在，则找到了所需的配对。
- 如果不存在，则将当前元素及其下标存入 map，以便后续元素进行匹配。  

这样，map 中始终保存的是我们已经遍历过的元素及其位置，从而支持高效的后续查找。

过程如下：

<img src="../../images/image-202511031447.svg"  />

```go
func twoSum(nums []int, target int) []int {
	hashMap := make(map[int]int)
	for i, num := range nums {
		complement := target - num
		if j, ok := hashMap[complement]; ok {
			return []int{i, j}
		}
		hashMap[num] = i
	}
	return nil
}
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`

