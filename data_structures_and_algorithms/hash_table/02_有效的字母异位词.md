# 有效的字母异位词

## 题目

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的**字母异位词**。

> [!tip]
>
> **字母异位词**：字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。

**示例 1**：

```sh
输入: s = "anagram", t = "nagaram"
输出: true
```

**示例 2**：

```sh
输入: s = "rat", t = "car"
输出: false
```

**提示**：

- `1 <= s.length, t.length <= 5 * 104`
- `s` 和 `t` 仅包含小写字母

**进阶**：如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

## 思路

使用暴力解法，两层 `for` 循环，同时记录字符是否出现，明显时间复杂度为 `O(n^2)`。

**数组就是一个简单哈希表**，且该题中只有小写字符，因此可以定义一个数组，来记录字符串 `s` 中字符出现的次数。

需要定义一个 `count` 数组，大小为 26，初始化为 0，因为字符 a 至字符 z 的 ASCII 也是 26 个连续的数值。

<img src="../../images/image-202510301929.gif" style="zoom:80%;" />

定义一个数组 `count` 来统计字符串 `s` 中字符出现的次数。

需要将字符映射到数组也就是哈希表的索引下标上，**因为字符 a 到字符 z 的 ASCII 是 26 个连续的数值，因此字符 a 的映射为下标 0，相应的字符 在映射为下标 25**。

在遍历字符串 s 时，**只需要将 `s[i] - 'a'` 所在的元素做 `+1` 操作即可，并不需要记住字符 `a` 的 ASCII，只需求出一个相对数值即可**，这样就将字符串 `s` 中字符出现的次数统计出来。

接着遍历字符串 `t`，将其每个字符在哈希表中对应的计数值减 1。

之后检查，若 `record` 数组有元素不为 0，则说明字符串 `s` 或 `t` 不是字母异位词。

时间复杂度为 `O(n)`，空间上因为定义一个常量大小的数组，因此空间复杂度为 `O(1)`。

```go
func isAnagram(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}
	count := [26]int{}
	for _, char := range s {
		count[char-'a']++
	}
	for _, char := range t {
		count[char-'a']--
	}
	return count == [26]int{}
}
```

> [!tip]
>
> 在 Go 语言中，数组是值类型，可以直接使用 `==` 进行比较。

使用 Go 内置的 `map` 类型：

```go
func isAnagram(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}
	count := make(map[rune]int)
	for _, char := range s {
		count[char]++
	}
	for _, char := range t {
		count[char]--
		if count[char] < 0 {
			return false
		}
	}
	return true
}
```

在 `s` 和 `t` 长度相等的情况下，如果它们不是字母异位词（即字符出现次数不匹配），那么在遍历 `t` 时，必然会出现某个字符的计数变为负数的情况。