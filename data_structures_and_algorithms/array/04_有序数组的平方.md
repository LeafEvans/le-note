# 有序数组的平方

## 题目

给你一个按**非递减顺序**排序的整数数组 `nums`，返回**每个数字的平方**组成的新数组，要求也按**非递减顺序**排序。

**示例 1**：

```sh
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**示例 2**：

```sh
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

**提示**：

- `1 <= nums.length <= 10⁴`
- `-10⁴ <= nums[i] <= 10⁴`
- `nums` 已按**非递减顺序**排序

**进阶**：

- 请你设计时间复杂度为 `O(n)` 的算法解决本问题

## 思路

### 暴力排序

在每个数平方后进行排序：

```go
import "slices"

func sortedSquares(nums []int) []int {
	for k, v := range nums {
		nums[k] = v * v
	}
	slices.Sort(nums)
	return nums
}
```

这个算法的时间复杂度为 `O(n+nlogn)`，即 `O(nlogn)` 的时间复杂度。

### 双指针法

数组本身有序，只是负数平方之后可能成为最大数。

因此数组值平方的最大值仅可能在数组两端，不可能为中间。

此时可以考虑双指针法，`left` 指向最左侧，`right` 指向最右侧。

定义一个新数组 `res`，使其与数组 `nums` 大小一致。

- 若 `nums[left] * nums[left] >= nums[right] * nums[right]`，则 `res[pos] = nums[left] * nums[left]`，而后 `pos--`。
- 若 `nums[left] * nums[left] < nums[right] * nums[right]`，则 `res[pos] = nums[right] * nums[right]`，则 `res[pos] = nums[right] * nums[right]`，而后 `pos--`。

<img src="../../images/image-202510182352.gif" style="zoom:80%;" />

因此 Go 代码如下：

```go
func sortedSquares(nums []int) []int {
	n := len(nums)
	left, right, pos := 0, n-1, n-1
	res := make([]int, n)

	for left <= right {
		leftSq := nums[left] * nums[left]
		rightSq := nums[right] * nums[right]
		if leftSq >= rightSq {
			res[pos] = leftSq
			left++
		} else {
			res[pos] = rightSq
			right--
		}
		pos--
	}

	return res
}
```

时间复杂度为 `O(n)`。
