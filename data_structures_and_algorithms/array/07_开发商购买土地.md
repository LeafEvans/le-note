# 开发商购买土地

## 题目

https://kamacoder.com/problempage.php?pid=1044

给定一个 `n` 行 `m` 列的整数矩阵，表示一个城市区域中每个区块的土地价值。你需要将整个区域**沿某一行或某一列**切一刀，划分为两个**非空**的连续子区域，分别分配给 A 公司和 B 公司。目标是使两个子区域的土地总价值之差的绝对值最小。

**注意**：  

- 切分只能是**横向**（整行之间）或**纵向**（整列之间）
- 每个子区域必须至少包含一个区块（即不能在最外侧切分）

**输入描述**： 

第一行包含两个正整数 `n` 和 `m`（`1 <= n, m <= 100`，且 `n` 和 `m` 不同时为 1）。  

接下来 `n` 行，每行包含 `m` 个正整数，表示每个区块的土地价值。

**输出描述**： 

输出一个整数，表示所有合法切分方式中，两个子区域土地总价值之差的最小绝对值。

**示例**：

```sh
输入：
3 3
1 2 3
2 1 3
1 2 3

输出：
0
```

**解释**： 

若沿第 2 列右侧进行纵向切分（即在第 2 列和第 3 列之间切）：

```sh
1 2 | 3
2 1 | 3
1 2 | 3
```

左侧子区域总和为 `1+2+2+1+1+2=9`，右侧为 `3+3+3=9`，两者之差的绝对值为 `∣9−9∣=0`，达到最小可能值。

**提示**：

- 所有区块权值均为正整数
- 切分线必须严格在行之间或列之间，不能穿过区块
- 保证至少存在一种合法切分方式（因 `n` 和 `m` 不同时为 1）

## 思路

暴力解法需枚举分割线，并用两层循环累加两侧区域，时间复杂度达 `O(n^3)`，效率低下。

本题可借助**前缀和**优化：预处理行方向和列方向的前缀和后，任意行区间或列区间的总和均可在 `O(1)` 时间内计算（如行区间 `[a, b]` 的和为 `rowSum[b] - rowSum[a - 1]`）。

> [!tip]
>
> 使用 `a - 1` 是因为前缀和定义为从第 0 行（或列）到当前行（或列）的闭区间和，边界处理需保持一致。

通过该方法，整体复杂度可降至 `O(n * m)`，高效支持所有合法划分。

```go
package main

import (
	"bufio"
	"fmt"
	"math"
	"os"
	"strconv"
	"strings"
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	var n, m int
	scanner.Scan()
	fmt.Sscanf(scanner.Text(), "%d %d", &n, &m)

	matrix := make([][]int, n)
	for i := 0; i < n; i++ {
		matrix[i] = make([]int, m)
		scanner.Scan()
		fields := strings.Fields(scanner.Text())
		for j := 0; j < m; j++ {
      x, _ := strconv.Atoi(fields[j])
			matrix[i][j] = x
		}
	}

	prefix := make([][]int, n+1)
	for i := 0; i < n+1; i++ {
		prefix[i] = make([]int, m+1)
	}

	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			prefix[i+1][j+1] = matrix[i][j] + prefix[i][j+1] + prefix[i+1][j] - prefix[i][j]
		}
	}

	total := prefix[n][m]
	minDiff := total

	for i := 1; i < n; i++ {
		top := prefix[i][m]
		bottom := total - top
		diff := int(math.Abs(float64(top - bottom)))
		if diff < minDiff {
			minDiff = diff
		}
	}

	for j := 1; j < m; j++ {
		left := prefix[n][j]
		right := total - left
		diff := int(math.Abs(float64(left - right)))
		if diff < minDiff {
			minDiff = diff
		}
	}

	fmt.Println(minDiff)
}
```

时间复杂度为 `O(n²)`。

本题还可以通过优化后的暴力求解来实现：在按行遍历时，每当遍历到行尾时进行统计；在按列遍历时，每当遍历到列尾时进行统计。

时间复杂度也为 `O(n²)`。

```go
package main

import (
	"bufio"
	"fmt"
	"math"
	"os"
	"strconv"
	"strings"
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	var n, m int
	scanner.Scan()
	fmt.Sscanf(scanner.Text(), "%d %d", &n, &m)

	matrix := make([][]int, n)
	total := 0
	for i := 0; i < n; i++ {
		matrix[i] = make([]int, m)
		scanner.Scan()
		fields := strings.Fields(scanner.Text())
		for j := 0; j < m; j++ {
			x, _ := strconv.Atoi(fields[j])
			matrix[i][j] = x
			total += x
		}
	}

	minDiff := total

	partialSum := 0
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			partialSum += matrix[i][j]
		}
		diff := int(math.Abs(float64(total - 2*partialSum)))
		if diff < minDiff {
			minDiff = diff
		}
	}

	partialSum = 0
	for j := 0; j < m; j++ {
		for i := 0; i < n; i++ {
			partialSum += matrix[i][j]
		}
		diff := int(math.Abs(float64(total - 2*partialSum)))
		if diff < minDiff {
			minDiff = diff
		}
	}

	fmt.Println(minDiff)
}
```

