# 反转链表

## 题目

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 1**：

<img src="../../images/image-202510232219" style="zoom:67%;" />

```sh
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2**：

<img src="../../images/image-202510232220" style="zoom:67%;" />

```sh
输入：head = [1,2]
输出：[2,1]
```

**示例 3**：

```sh
输入：head = []
输出：[]
```

**提示**：

- 链表中节点的数目范围是 `[0, 5000]`
- `-5000 <= Node.val <= 5000`

**进阶**：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

## 思路

重新定义一个新链表，实现链表元素的反转，其实这是对内存空间的浪费。

因此只需改变链表的 `next` 指针的指向，直接将链表反转，而不用重新定义一个新链表。

<img src="../../images/image-202510232232.png" style="zoom:67%;" />

之前链表的头节点为元素 1，反转之后头节点为元素 5，此处没有添加或者删除节点，仅仅是改变 `next` 指针的方向。

<img src="../../images/image-202510232235.gif" style="zoom:67%;" />

首先定义一个 `current` 指针，指向头节点，而后定义一个 `prev` 指针，初始化为 `nil`。

而后开始反转，首先将 `current->next` 节点使用 `next` 指针保存。

> [!tip]
>
> 之所以要保存是因为接下来要改变 `current->next` 的指向了，将 `current->next` 指向 `prev`，此时反转了第一个节点。

之后继续按照上述代码逻辑进行即可，移动 `prev` 和 `current` 指针。

最后，`current` 指针指向了 `nil`，循环结束，链表反转成功。此时 `return prev` 即可，`prev` 指针指向了新的头节点。

### 双指针法

```go
func reverseList(head *ListNode) *ListNode {
	var prev *ListNode
	current := head
	for current != nil {
		next := current.Next
		current.Next = prev
		prev = current
		current = next
	}
	return prev
}
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`

### 递归法

递归法相对抽象，本质上逻辑与双指针一致，在 `current == nil` 时循环结束，不断将 `current` 指向 `prev` 的过程。

在双指针法中，`current` 初始化为 `head`、`prev` 初始化为 `nil`；在递归法中逻辑一致，只是写法不同。

```go
func reverse(prev, current *ListNode) *ListNode {
	if current == nil {
		return prev
	}
	next := current.Next
	current.Next = prev
	return reverse(current, next)
}

func reverseList(head *ListNode) *ListNode {
	return reverse(nil, head)
}
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`