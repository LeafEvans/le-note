# 移除链表元素

## 题目

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回**新的头节点**

。

**示例 1**：

<img src="../../images/data_structures_and_algorithms/image_20251023_095400.png" style="zoom:67%;" />

```sh
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

**示例 2**：

```sh
输入：head = [], val = 1
输出：[]
```

**示例 3**：

```sh
输入：head = [7,7,7,7], val = 7
输出：[]
```

**提示**：

- 列表中的节点数目在范围 `[0, 104]` 内
- `1 <= Node.val <= 50`
- `0 <= val <= 50`

## 思路

此处以链表 `[1 4 2 4]` 举例，移除元素 4。

<img src="../../images/data_structures_and_algorithms/image_20251023_100000.png" style="zoom: 50%;" />

移除完节点后，有：

<img src="../../images/data_structures_and_algorithms/image_20251023_100100.png" style="zoom: 50%;" />

对普通节点的移除操作，让其上一个节点的 `next` 指针指向其下一个节点即可。

但因为单链表的特殊性，只能指向下一个节点，上述图文中删除的是链表中的第二个和第四个节点，若删除的是头节点如何呢？

- 直接使用原来的链表来进行删除操作。
- 设置一个虚拟头节点来进行删除操作。

**方法 1**：

<img src="../../images/data_structures_and_algorithms/image_20251023_100600.png" style="zoom: 50%;" />

移除头节点和移除其他节点的操作不一致，因为链表的其他节点都是通过前一个节点来移除当前节点，而**头节点无前一个节点**。

**如何移除头节点呢？**只需将头节点向后移动一位即可，这样就从链表中移除了一个头节点。

<img src="../../images/data_structures_and_algorithms/image_20251023_100800.png" style="zoom: 50%;" />

这样就移除了一个头节点，但是使用此方法需要为头节点当独编写一段处理逻辑，操作方法无法得到统一。

```go
func removeElements(head *ListNode, val int) *ListNode {
	for head != nil && head.Val == val {
		head = head.Next
	}

	current := head
	for current != nil && current.Next != nil {
		if current.Next.Val == val {
			current.Next = current.Next.Next
		} else {
			current = current.Next
		}
	}

	return head
}
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`

**方法 2**：

可以设置一个**虚拟头节点**（哨兵节点），这样原链表的所有节点均可按照统一的方式进行移除。

在原链表中，移除元素 1。

<img src="../../images/data_structures_and_algorithms/image_20251023_101200.png" style="zoom: 50%;" />

给链表添加一个虚拟头节点作为新的头节点，此时移除这个旧头节点元素 1。

此时移除链表头节点和移除链表其他节点的方式统一了。

最后，要 `return dummyHead.Next`，它才是真正的头节点。

```go
func removeElements(head *ListNode, val int) *ListNode {
	dummy := &ListNode{}
	dummy.Next = head
	current := dummy

	for current.Next != nil {
		if current.Next.Val == val {
			current.Next = current.Next.Next
		} else {
			current = current.Next
		}
	}

	return dummy.Next
}
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`
